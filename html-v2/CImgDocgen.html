<!DOCTYPE html5>

<html>

<head>

<title> The CImg Template Library - Documentation </title>
<script src="docgen.js"></script>

</head>

<body>

[++Title] \name The CImg Template Library â€“ Documentation [++EndTitle]

//! Contains &lt;i&gt;all classes and functions&lt;/i&gt; of the \CImg library.
/**
   This namespace is defined to avoid functions and class names collisions
   that could happen with the inclusion of other C++ header files.
   Anyway, it should not happen often and you should reasonably start most of your
   \CImg-based programs with
   \code
   #include "CImg.h"
   using namespace cimg_library;
   \endcode
   to simplify the declaration of \CImg Library objects afterwards.
**/
namespace cimg_library_suffixed ;

//! Avoid warning messages due to unused parameters. Do nothing actually.
    template&lt;typename T&gt;
    inline void unused(const T&amp;, ...) ;

//! Set current \CImg exception mode.
    /**
       The way error messages are handled by \CImg can be changed dynamically, using this function.
       \param mode Desired exception mode. Possible values are:
       - \c 0: Hide library messages (quiet mode).
       - \c 1: Print library messages on the console.
       - \c 2: Display library messages on a dialog window.
       - \c 3: Do as \c 1 + add extra debug warnings (slow down the code!).
       - \c 4: Do as \c 2 + add extra debug warnings (slow down the code!).
     **/
    inline unsigned int&amp; exception_mode(const unsigned int mode) ;

//! Return current \CImg exception mode.
    /**
       \note By default, return the value of configuration macro \c cimg_verbosity
    **/
    inline unsigned int&amp; exception_mode() ;

//! Set current \CImg openmp mode.
    /**
       The way openmp-based methods are handled by \CImg can be changed dynamically, using this function.
       \param mode Desired openmp mode. Possible values are:
       - \c 0: Never parallelize.
       - \c 1: Always parallelize.
       - \c 2: Adaptive parallelization mode (default behavior).
     **/
    inline unsigned int openmp_mode(const unsigned int mode) ;

//! Return current \CImg openmp mode.
    inline unsigned int openmp_mode() ;

//! Instances of \c CImgException are thrown when errors are encountered in a \CImg function call.
  /**
     \par Overview

      CImgException is the base class of all exceptions thrown by \CImg (except \b CImgAbortException).
      CImgException is never thrown itself. Derived classes that specify the type of errord are thrown instead.
      These classes can be:

      - \b CImgAbortException: Thrown when a computationally-intensive function is aborted by an external signal.
        This is the only \c non-derived exception class.

      - \b CImgArgumentException: Thrown when one argument of a called \CImg function is invalid.
      This is probably one of the most thrown exception by \CImg.
      For instance, the following example throws a \c CImgArgumentException:
      \code
      CImg&lt;float&gt; img(100,100,1,3); // Define a 100x100 color image with float-valued pixels
      img.mirror('e');              // Try to mirror image along the (non-existing) 'e'-axis
      \endcode

      - \b CImgDisplayException: Thrown when something went wrong during the display of images in CImgDisplay instances.

      - \b CImgInstanceException: Thrown when an instance associated to a called \CImg method does not fit
      the function requirements. For instance, the following example throws a \c CImgInstanceException:
      \code
      const CImg&lt;float&gt; img;           // Define an empty image
      const float value = img.at(0);   // Try to read first pixel value (does not exist)
      \endcode

      - \b CImgIOException: Thrown when an error occurred when trying to load or save image files.
      This happens when trying to read files that do not exist or with invalid formats.
      For instance, the following example throws a \c CImgIOException:
      \code
      const CImg&lt;float&gt; img("missing_file.jpg");  // Try to load a file that does not exist
      \endcode

      - \b CImgWarningException: Thrown only if configuration macro \c cimg_strict_warnings is set, and
      when a \CImg function has to display a warning message (see cimg::warn()).

      It is not recommended to throw CImgException instances by yourself,
      since they are expected to be thrown only by \CImg.
      When an error occurs in a library function call, \CImg may display error messages on the screen or on the
      standard output, depending on the current \CImg exception mode.
      The \CImg exception mode can be get and set by functions cimg::exception_mode() and
      cimg::exception_mode(unsigned int).

      \par Exceptions handling

      In all cases, when an error occurs in \CImg, an instance of the corresponding exception class is thrown.
      This may lead the program to break (this is the default behavior), but you can bypass this behavior by
      handling the exceptions by yourself,
      using a usual &lt;tt&gt;try { ... } catch () { ... }&lt;/tt&gt; bloc, as in the following example:
      \code
      #define "CImg.h"
      using namespace cimg_library;
      int main() {
        cimg::exception_mode(0);                                    // Enable quiet exception mode
        try {
          ...                                                       // Here, do what you want to stress CImg
        } catch (CImgException&amp; e) {                                // You succeeded: something went wrong!
          std::fprintf(stderr,"CImg Library Error: %s",e.what());   // Display your custom error message
          ...                                                       // Do what you want now to save the ship!
          }
        }
      \endcode
  **/
  class CImgException : public std::exception ;

//! Return a C-string containing the error message associated to the thrown exception.
    const char *what() const throw() ;

//! Return a C-string containing the error message associated to the thrown exception.
    const char *what() const throw() ;

//! Contains \a low-level functions and variables of the \CImg Library.
  /**
     Most of the functions and variables within this namespace are used by the \CImg library for low-level operations.
     You may use them to access specific const values or environment variables internally used by \CImg.
     \warning Never write &lt;tt&gt;using namespace cimg_library::cimg;&lt;/tt&gt; in your source code. Lot of functions in the
     &lt;tt&gt;cimg:: namespace&lt;/tt&gt; have the same names as standard C functions that may be defined in the global
     namespace &lt;tt&gt;::&lt;/tt&gt;.
  **/
  namespace cimg ;

//! Keycodes (architecture-dependent)
  /**
  **/
    const unsigned int keyF1         = 2U;
    const unsigned int keyF2         = 3U;
    const unsigned int keyF3         = 4U;
    const unsigned int keyF4         = 5U;
    const unsigned int keyF5         = 6U;
    const unsigned int keyF6         = 7U;     
    const unsigned int keyF7         = 8U;     
    const unsigned int keyF8         = 9U;     
    const unsigned int keyF9         = 10U;    
    const unsigned int keyF10        = 11U;    
    const unsigned int keyF11        = 12U;    
    const unsigned int keyF12        = 13U;    
    const unsigned int keyPAUSE      = 14U;    
    const unsigned int key1          = 15U;    
    const unsigned int key2          = 16U;    
    const unsigned int key3          = 17U;    
    const unsigned int key4          = 18U;    
    const unsigned int key5          = 19U;    
    const unsigned int key6          = 20U;    
    const unsigned int key7          = 21U;    
    const unsigned int key8          = 22U;    
    const unsigned int key9          = 23U;    
    const unsigned int key0          = 24U;    
    const unsigned int keyBACKSPACE  = 25U;    
    const unsigned int keyINSERT     = 26U;    
    const unsigned int keyHOME       = 27U;    
    const unsigned int keyPAGEUP     = 28U;    
    const unsigned int keyTAB        = 29U;    
    const unsigned int keyQ          = 30U;    
    const unsigned int keyW          = 31U;    
    const unsigned int keyE          = 32U;    
    const unsigned int keyR          = 33U;    
    const unsigned int keyT          = 34U;    
    const unsigned int keyY          = 35U;    
    const unsigned int keyU          = 36U;    
    const unsigned int keyI          = 37U;    
    const unsigned int keyO          = 38U;    
    const unsigned int keyP          = 39U;    
    const unsigned int keyDELETE     = 40U;    
    const unsigned int keyEND        = 41U;    
    const unsigned int keyPAGEDOWN   = 42U;    
    const unsigned int keyCAPSLOCK   = 43U;    
    const unsigned int keyA          = 44U;    
    const unsigned int keyS          = 45U;    
    const unsigned int keyD          = 46U;    
    const unsigned int keyF          = 47U;    
    const unsigned int keyG          = 48U;    
    const unsigned int keyH          = 49U;    
    const unsigned int keyJ          = 50U;    
    const unsigned int keyK          = 51U;    
    const unsigned int keyL          = 52U;    
    const unsigned int keyENTER      = 53U;    
    const unsigned int keySHIFTLEFT  = 54U;    
    const unsigned int keyZ          = 55U;    
    const unsigned int keyX          = 56U;    
    const unsigned int keyC          = 57U;    
    const unsigned int keyV          = 58U;    
    const unsigned int keyB          = 59U;    
    const unsigned int keyN          = 60U;    
    const unsigned int keyM          = 61U;    
    const unsigned int keySHIFTRIGHT = 62U;    
    const unsigned int keyARROWUP    = 63U;    
    const unsigned int keyCTRLLEFT   = 64U;    
    const unsigned int keyAPPLEFT    = 65U;    
    const unsigned int keyALT        = 66U;    
    const unsigned int keySPACE      = 67U;    
    const unsigned int keyALTGR      = 68U;    
    const unsigned int keyAPPRIGHT   = 69U;    
    const unsigned int keyMENU       = 70U;    
    const unsigned int keyCTRLRIGHT  = 71U;    
    const unsigned int keyARROWLEFT  = 72U;    
    const unsigned int keyARROWDOWN  = 73U;    
    const unsigned int keyARROWRIGHT = 74U;    
    const unsigned int keyPAD0       = 75U;    
    const unsigned int keyPAD1       = 76U;    
    const unsigned int keyPAD2       = 77U;    
    const unsigned int keyPAD3       = 78U;    
    const unsigned int keyPAD4       = 79U;    
    const unsigned int keyPAD5       = 80U;    
    const unsigned int keyPAD6       = 81U;    
    const unsigned int keyPAD7       = 82U;    
    const unsigned int keyPAD8       = 83U;    
    const unsigned int keyPAD9       = 84U;    
    const unsigned int keyPADADD     = 85U;    
    const unsigned int keyPADSUB     = 86U;    
    const unsigned int keyPADMUL     = 87U;    
    const unsigned int keyPADDIV     = 88U;    

//! Value of the mathematical constant PI
    const double PI = 3.14159265358979323846;

    // Define a 10x13 binary font (small sans).
    static const char *const data_font_small[] = ;

//! Get/set default output stream for the \CImg library messages.
    /**
       \param file Desired output stream. Set to \c 0 to get the currently used output stream only.
       \return Currently used output stream.
    **/
    inline std::FILE* output(std::FILE *file) ;

//! Display a warning message on the default output stream.
    /**
       \param format C-string containing the format of the message, as with &lt;tt&gt;std::printf()&lt;/tt&gt;.
       \note If configuration macro \c cimg_strict_warnings is set, this function throws a
       \c CImgWarningException instead.
       \warning As the first argument is a format string, it is highly recommended to write
       \code
       cimg::warn("%s",warning_message);
       \endcode
       instead of
       \code
       cimg::warn(warning_message);
       \endcode
       if \c warning_message can be arbitrary, to prevent nasty memory access.
    **/
    inline void warn(const char *const format, ...) ;

//! Return a reference to a temporary variable of type T.
    template&lt;typename T&gt;
    inline T&amp; temporary(const T&amp;) ;

//! Exchange values of variables \c a and \c b.
    template&lt;typename T&gt;
    inline void swap(T&amp; a, T&amp; b) ;

//! Exchange values of variables (\c a1,\c a2) and (\c b1,\c b2).
    template&lt;typename T1, typename T2&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2) ;

//! Exchange values of variables (\c a1,\c a2,\c a3) and (\c b1,\c b2,\c b3).
    template&lt;typename T1, typename T2, typename T3&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3) ;

//! Exchange values of variables (\c a1,\c a2,...,\c a4) and (\c b1,\c b2,...,\c b4).
    template&lt;typename T1, typename T2, typename T3, typename T4&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3, T4&amp; a4, T4&amp; b4) ;

//! Exchange values of variables (\c a1,\c a2,...,\c a5) and (\c b1,\c b2,...,\c b5).
    template&lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3, T4&amp; a4, T4&amp; b4, T5&amp; a5, T5&amp; b5) ;

//! Exchange values of variables (\c a1,\c a2,...,\c a6) and (\c b1,\c b2,...,\c b6).
    template&lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3, T4&amp; a4, T4&amp; b4, T5&amp; a5, T5&amp; b5, T6&amp; a6, T6&amp; b6) ;

//! Exchange values of variables (\c a1,\c a2,...,\c a7) and (\c b1,\c b2,...,\c b7).
    template&lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3, T4&amp; a4, T4&amp; b4, T5&amp; a5, T5&amp; b5, T6&amp; a6, T6&amp; b6,
                     T7&amp; a7, T7&amp; b7) ;

//! Exchange values of variables (\c a1,\c a2,...,\c a8) and (\c b1,\c b2,...,\c b8).
    template&lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8&gt;
    inline void swap(T1&amp; a1, T1&amp; b1, T2&amp; a2, T2&amp; b2, T3&amp; a3, T3&amp; b3, T4&amp; a4, T4&amp; b4, T5&amp; a5, T5&amp; b5, T6&amp; a6, T6&amp; b6,
                     T7&amp; a7, T7&amp; b7, T8&amp; a8, T8&amp; b8) ;

//! Return the endianness of the current architecture.
    /**
       \return \c false for &lt;i&gt;Little Endian&lt;/i&gt; or \c true for &lt;i&gt;Big Endian&lt;/i&gt;.
    **/
    inline bool endianness() ;

//! Reverse endianness of all elements in a memory buffer.
    /**
       \param[in,out] buffer Memory buffer whose endianness must be reversed.
       \param size Number of buffer elements to reverse.
    **/
    template&lt;typename T&gt;
    inline void invert_endianness(T* const buffer, const cimg_ulong size) ;

//! Reverse endianness of a single variable.
    /**
       \param[in,out] a Variable to reverse.
       \return Reference to reversed variable.
    **/
    template&lt;typename T&gt;
    inline T&amp; invert_endianness(T&amp; a) ;

//! Return the value of a system timer, with a millisecond precision.
    /**
       \note The timer does not necessarily starts from \c 0.
    **/
    inline cimg_uint64 time() ;

//! Start tic/toc timer for time measurement between code instructions.
    /**
       \return Current value of the timer (same value as time()).
    **/
    inline cimg_uint64 tic() ;

//! End tic/toc timer and displays elapsed time from last call to tic().
    /**
       \return Time elapsed (in ms) since last call to tic().
    **/
    inline cimg_uint64 toc() ;

//! Sleep for a given numbers of milliseconds.
    /**
       \param milliseconds Number of milliseconds to wait for.
       \note This function frees the CPU resources during the sleeping time.
       It can be used to temporize your program properly, without wasting CPU time.
    **/
    inline void sleep(const unsigned int milliseconds) ;

//! Wait for a given number of milliseconds since the last call to wait().
    /**
       \param milliseconds Number of milliseconds to wait for.
       \return Number of milliseconds elapsed since the last call to wait().
       \note Same as sleep() with a waiting time computed with regard to the last call
       of wait(). It may be used to temporize your program properly, without wasting CPU time.
    **/
    inline unsigned int wait(const unsigned int milliseconds) ;

//! Cut (i.e. clamp) value in specified interval.
    template&lt;typename T, typename t&gt;
    inline T cut(const T&amp; val, const t&amp; val_min, const t&amp; val_max) ;

//! Bitwise-rotate value on the left.
    template&lt;typename T&gt;
    inline T rol(const T&amp; a, const unsigned int n=1) ;

//! Bitwise-rotate value on the right.
    template&lt;typename T&gt;
    inline T ror(const T&amp; a, const unsigned int n=1) ;

//! Return absolute value of a value.
    template&lt;typename T&gt;
    inline T abs(const T&amp; a) ;

//! Return hyperbolic arcosine of a value.
    inline double acosh(const double x) ;

//! Return hyperbolic arcsine of a value.
    inline double asinh(const double x) ;

//! Return hyperbolic arctangent of a value.
    inline double atanh(const double x) ;

//! Return the sinc of a given value.
    inline double sinc(const double x) ;

//! Return base-2 logarithm of a value.
    inline double log2(const double x) ;

//! Return square of a value.
    template&lt;typename T&gt;
    inline T sqr(const T&amp; val) ;

//! Return cubic root of a value.
    template&lt;typename T&gt;
    inline double cbrt(const T&amp; x) ;

//! Return the minimum between three values.
    template&lt;typename t&gt;
    inline t min(const t&amp; a, const t&amp; b, const t&amp; c) ;

//! Return the minimum between four values.
    template&lt;typename t&gt;
    inline t min(const t&amp; a, const t&amp; b, const t&amp; c, const t&amp; d) ;

//! Return the minabs between two values.
    template&lt;typename t&gt;
    inline t minabs(const t&amp; a, const t&amp; b) ;

//! Return the maximum between three values.
    template&lt;typename t&gt;
    inline t max(const t&amp; a, const t&amp; b, const t&amp; c) ;

//! Return the maximum between four values.
    template&lt;typename t&gt;
    inline t max(const t&amp; a, const t&amp; b, const t&amp; c, const t&amp; d) ;

//! Return the maxabs between two values.
    template&lt;typename t&gt;
    inline t maxabs(const t&amp; a, const t&amp; b) ;

//! Return the sign of a value.
    template&lt;typename T&gt;
    inline T sign(const T&amp; x) ;

//! Return the nearest power of 2 higher than given value.
    template&lt;typename T&gt;
    inline cimg_uint64 nearest_pow2(const T&amp; x) ;

//! Return the modulo of a value.
    /**
       \param x Input value.
       \param m Modulo value.
       \note This modulo function accepts negative and floating-points modulo numbers, as well as variables of any type.
    **/
    template&lt;typename T&gt;
    inline T mod(const T&amp; x, const T&amp; m) ;

//! Return the min-mod of two values.
    /**
       \note &lt;i&gt;minmod(\p a,\p b)&lt;/i&gt; is defined to be:
       - &lt;i&gt;minmod(\p a,\p b) = min(\p a,\p b)&lt;/i&gt;, if \p a and \p b have the same sign.
       - &lt;i&gt;minmod(\p a,\p b) = 0&lt;/i&gt;, if \p a and \p b have different signs.
    **/
    template&lt;typename T&gt;
    inline T minmod(const T&amp; a, const T&amp; b) ;

//! Return rounded value.
    /**
       \param x Value to be rounded.
       \param y Rounding precision.
       \param rounding_type Type of rounding operation (\c 0 = nearest, \c -1 = backward, \c 1 = forward).
       \return Rounded value, having the same type as input value \c x.
    **/
    template&lt;typename T&gt;
    inline T round(const T&amp; x, const double y, const int rounding_type=0) ;

//! Return sqrt(x^2 + y^2).
    template&lt;typename T&gt;
    inline T hypot(const T x, const T y) ;

//! Return the factorial of n
    inline double factorial(const int n) ;

//! Return the number of permutations of k objects in a set of n objects.
    inline double permutations(const int k, const int n, const bool with_order) ;

//! Calculate fibonacci number.
    // (Precise up to n = 78, less precise for n&gt;78).
    inline double fibonacci(const int n) ;

//! Calculate greatest common divisor.
    inline long gcd(long a, long b) ;

//! Convert character to lower case.
    inline char lowercase(const char x) ;

//! Convert C-string to lower case.
    inline void lowercase(char *const str) ;

//! Convert character to upper case.
    inline char uppercase(const char x) ;

//! Convert C-string to upper case.
    inline void uppercase(char *const str) ;

//! Return \c true if input character is blank (space, tab, or non-printable character).
    inline bool is_blank(const char c) ;

//! Read value in a C-string.
    /**
       \param str C-string containing the float value to read.
       \return Read value.
       \note Same as &lt;tt&gt;std::atof()&lt;/tt&gt; extended to manage the retrieval of fractions from C-strings,
       as in &lt;em&gt;"1/2"&lt;/em&gt;.
    **/
    inline double atof(const char *const str) ;

//! Compare the first \p l characters of two C-strings, ignoring the case.
    /**
       \param str1 C-string.
       \param str2 C-string.
       \param l Number of characters to compare.
       \return \c 0 if the two strings are equal, something else otherwise.
       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
    **/
    inline int strncasecmp(const char *const str1, const char *const str2, const int l) ;

//! Compare two C-strings, ignoring the case.
    /**
       \param str1 C-string.
       \param str2 C-string.
       \return \c 0 if the two strings are equal, something else otherwise.
       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
    **/
    inline int strcasecmp(const char *const str1, const char *const str2) ;

//! Ellipsize a string.
    /**
       \param str C-string.
       \param l Max number of characters.
       \param is_ending Tell if the dots are placed at the end or at the center of the ellipsized string.
    **/
    inline char *strellipsize(char *const str, const unsigned int l=64,
                              const bool is_ending=true) ;

//! Ellipsize a string.
    /**
       \param str C-string.
       \param res output C-string.
       \param l Max number of characters.
       \param is_ending Tell if the dots are placed at the end or at the center of the ellipsized string.
    **/
    inline char *strellipsize(const char *const str, char *const res, const unsigned int l=64,
                              const bool is_ending=true) ;

//! Remove delimiters on the start and/or end of a C-string.
    /**
       \param[in,out] str C-string to work with (modified at output).
       \param delimiter Delimiter character code to remove.
       \param is_symmetric Tells if the removal is done only if delimiters are symmetric
       (both at the beginning and the end of \c s).
       \param is_iterative Tells if the removal is done if several iterations are possible.
       \return \c true if delimiters have been removed, \c false otherwise.
   **/
    inline bool strpare(char *const str, const char delimiter,
                        const bool is_symmetric, const bool is_iterative) ;

//! Remove white spaces on the start and/or end of a C-string.
    inline bool strpare(char *const str, const bool is_symmetric, const bool is_iterative) ;

//! Replace reserved characters (for Windows filename) by another character.
    /**
       \param[in,out] str C-string to work with (modified at output).
       \param[in] c Replacement character.
    **/
    inline void strwindows_reserved(char *const str, const char c='_') ;

//! Replace escape sequences in C-strings by character values.
    /**
       \param[in,out] str C-string to work with (modified at output).
    **/
    inline void strunescape(char *const str) ;

//! Return the basename of a filename.
    inline const char* basename(const char *const s, const char separator=cimg_file_separator)  ;

//! Open a file.
    /**
       \param path Path of the filename to open.
       \param mode C-string describing the opening mode.
       \return Opened file.
       \note Same as &lt;tt&gt;std::fopen()&lt;/tt&gt; but throw a \c CImgIOException when
       the specified file cannot be opened, instead of returning \c 0.
    **/
    inline std::FILE *fopen(const char *const path, const char *const mode) ;

//! Close a file.
    /**
       \param file File to close.
       \return \c 0 if file has been closed properly, something else otherwise.
       \note Same as &lt;tt&gt;std::fclose()&lt;/tt&gt; but display a warning message if
       the file has not been closed properly.
    **/
    inline int fclose(std::FILE *file) ;

//! Version of 'fseek()' that supports &gt;=64bits offsets everywhere (for Windows).
    inline int fseek(FILE *stream, cimg_long offset, int origin) ;

//! Version of 'ftell()' that supports &gt;=64bits offsets everywhere (for Windows).
    inline cimg_long ftell(FILE *stream) ;

//! Check if a path is a directory.
    /**
       \param path Specified path to test.
    **/
    inline bool is_directory(const char *const path) ;

//! Check if a path is a file.
    /**
       \param path Specified path to test.
    **/
    inline bool is_file(const char *const path) ;

//! Get file size.
    /**
       \param filename Specified filename to get size from.
       \return File size or '-1' if file does not exist.
    **/
    inline cimg_int64 fsize(const char *const filename) ;

//! Get last write time of a given file or directory (multiple-attributes version).
    /**
       \param path Specified path to get attributes from.
       \param[in,out] attr Type of requested time attributes.
                      Can be { 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute | 6=second }
                      Replaced by read attributes after return (or -1 if an error occurred).
       \param nb_attr Number of attributes to read/write.
       \return Latest read attribute.
    **/
    template&lt;typename T&gt;
    inline int fdate(const char *const path, T *attr, const unsigned int nb_attr) ;

//! Get last write time of a given file or directory (single-attribute version).
    /**
       \param path Specified path to get attributes from.
       \param attr Type of requested time attributes.
                   Can be { 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute | 6=second }
       \return Specified attribute or -1 if an error occurred.
    **/
    inline int fdate(const char *const path, unsigned int attr) ;

//! Get current local time (multiple-attributes version).
    /**
       \param[in,out] attr Type of requested time attributes.
                           Can be { 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute | 6=second |
                                    7=millisecond }
                           Replaced by read attributes after return (or -1 if an error occurred).
       \param nb_attr Number of attributes to read/write.
       \return Latest read attribute.
    **/
    template&lt;typename T&gt;
    inline int date(T *attr, const unsigned int nb_attr) ;

//! Get current local time (single-attribute version).
    /**
       \param attr Type of requested time attribute.
                   Can be { 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute | 6=second |
                            7=millisecond }
       \return Specified attribute or -1 if an error occurred.
    **/
    inline int date(unsigned int attr) ;

//! Split filename into two C-strings \c body and \c extension.
    /**
       filename and body must not overlap!
    **/
    inline const char *split_filename(const char *const filename, char *const body=0) ;

//! Read data from file.
    /**
       \param[out] ptr Pointer to memory buffer that will contain the binary data read from file.
       \param nmemb Number of elements to read.
       \param stream File to read data from.
       \return Number of read elements.
       \note Same as &lt;tt&gt;std::fread()&lt;/tt&gt; but may display warning message if all elements could not be read.
    **/
    template&lt;typename T&gt;
    inline size_t fread(T *const ptr, const size_t nmemb, std::FILE *stream) ;

//! Write data to file.
    /**
       \param ptr Pointer to memory buffer containing the binary data to write on file.
       \param nmemb Number of elements to write.
       \param[out] stream File to write data on.
       \return Number of written elements.
       \note Similar to &lt;tt&gt;std::fwrite&lt;/tt&gt; but may display warning messages if all elements could not be written.
    **/
    template&lt;typename T&gt;
    inline size_t fwrite(const T *ptr, const size_t nmemb, std::FILE *stream) ;

//! Create an empty file.
    /**
       \param file Input file (can be \c 0 if \c filename is set).
       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
    **/
    inline void fempty(std::FILE *const file, const char *const filename) ;

//! Return options specified on the command line.
    inline const char* option(const char *const name, const int argc, const char *const *const argv,
                              const char *const _default, const char *const usage, const bool reset_static) ;

//! Print information about \CImg environment variables.
    /**
       \note Output is done on the default output stream.
    **/
    inline void info() ;

//! Allow the creation of windows, display images on them and manage user events (keyboard, mouse and windows events).
  /**
     CImgDisplay methods rely on a low-level graphic library to perform: it can be either \b X-Window
     (X11, for Unix-based systems) or \b GDI32 (for Windows-based systems).
     If both libraries are missing, CImgDisplay will not be able to display images on screen, and will enter
     a minimal mode where warning messages will be outputted each time the program is trying to call one of the
     CImgDisplay method.

     The configuration variable \c cimg_display tells about the graphic library used.
     It is set automatically by \CImg when one of these graphic libraries has been detected.
     But, you can override its value if necessary. Valid choices are:
     - 0: Disable display capabilities.
     - 1: Use \b X-Window (X11) library.
     - 2: Use \b GDI32 library.

     Remember to link your program against \b X11 or \b GDI32 libraries if you use CImgDisplay.
  **/
  class CImgDisplay ;

//! \name Plugins
    //@;

//! \name Constructors / Destructor / Instance Management
    //@;

//! Destructor.
    /**
       \note If the associated window is visible on the screen, it is closed by the call to the destructor.
    **/
    ~CImgDisplay() ;

//! Construct an empty display.
    /**
       \note Constructing an empty CImgDisplay instance does not make a window appearing on the screen, until
       display of valid data is performed.
       \par Example
       \code
       CImgDisplay disp;  // Does actually nothing
       ...
       disp.display(img); // Construct new window and display image in it
       \endcode
    **/
    CImgDisplay():
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _keys(new unsigned int[128]),_released_keys(new unsigned int[128]),
      _window_x(cimg::type&lt;int&gt;::min()),_window_y(cimg::type&lt;int&gt;::min()),
      _mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) ;

//! Construct a display with specified dimensions.
    /** \param width Window width.
        \param height Window height.
        \param title Window title.
        \param normalization Normalization type
        (&lt;tt&gt;0&lt;/tt&gt;=none, &lt;tt&gt;1&lt;/tt&gt;=always, &lt;tt&gt;2&lt;/tt&gt;=once, &lt;tt&gt;3&lt;/tt&gt;=pixel type-dependent, see normalization()).
        \param is_fullscreen Tells if fullscreen mode is enabled.
        \param is_closed Tells if associated window is initially visible or not.
        \note A black background is initially displayed on the associated window.
    **/
    CImgDisplay(const unsigned int width, const unsigned int height,
                const char *const title=0, const unsigned int normalization=3,
                const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _keys(new unsigned int[128]),_released_keys(new unsigned int[128]),
      _window_x(cimg::type&lt;int&gt;::min()),_window_y(cimg::type&lt;int&gt;::min()),
      _mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) ;

//! Construct a display from an image.
    /** \param img Image used as a model to create the window.
        \param title Window title.
        \param normalization Normalization type
        (&lt;tt&gt;0&lt;/tt&gt;=none, &lt;tt&gt;1&lt;/tt&gt;=always, &lt;tt&gt;2&lt;/tt&gt;=once, &lt;tt&gt;3&lt;/tt&gt;=pixel type-dependent, see normalization()).
        \param is_fullscreen Tells if fullscreen mode is enabled.
        \param is_closed Tells if associated window is initially visible or not.
        \note The pixels of the input image are initially displayed on the associated window.
    **/
    template&lt;typename T&gt;
    explicit CImgDisplay(const CImg&lt;T&gt;&amp; img,
                         const char *const title=0, const unsigned int normalization=3,
                         const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _keys(new unsigned int[128]),_released_keys(new unsigned int[128]),
      _window_x(cimg::type&lt;int&gt;::min()),_window_y(cimg::type&lt;int&gt;::min()),
      _mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) ;

//! Construct a display from an image list.
    /** \param list The images list to display.
        \param title Window title.
        \param normalization Normalization type
        (&lt;tt&gt;0&lt;/tt&gt;=none, &lt;tt&gt;1&lt;/tt&gt;=always, &lt;tt&gt;2&lt;/tt&gt;=once, &lt;tt&gt;3&lt;/tt&gt;=pixel type-dependent, see normalization()).
        \param is_fullscreen Tells if fullscreen mode is enabled.
        \param is_closed Tells if associated window is initially visible or not.
        \note All images of the list, appended along the X-axis, are initially displayed on the associated window.
    **/
    template&lt;typename T&gt;
    explicit CImgDisplay(const CImgList&lt;T&gt;&amp; list,
                         const char *const title=0, const unsigned int normalization=3,
                         const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _keys(new unsigned int[128]),_released_keys(new unsigned int[128]),
      _window_x(cimg::type&lt;int&gt;::min()),_window_y(cimg::type&lt;int&gt;::min()),
      _mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) ;

//! Construct a display as a copy of an existing one.
    /**
        \param disp Display instance to copy.
        \note The pixel buffer of the input window is initially displayed on the associated window.
    **/
    CImgDisplay(const CImgDisplay&amp; disp):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _keys(new unsigned int[128]),_released_keys(new unsigned int[128]),
      _window_x(cimg::type&lt;int&gt;::min()),_window_y(cimg::type&lt;int&gt;::min()),
      _mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) ;

//! Take a screenshot.
    /**
       \param[out] img Output screenshot. Can be empty on input
    **/
    template&lt;typename T&gt;
    static void screenshot(CImg&lt;T&gt;&amp; img) ;

//! Destructor - Empty constructor \inplace.
    /**
       \note Replace the current instance by an empty display.
    **/
    CImgDisplay&amp; assign() ;

//! Construct a display with specified dimensions \inplace.
    /**
    **/
    CImgDisplay&amp; assign(const unsigned int width, const unsigned int height,
                        const char *const title=0, const unsigned int normalization=3,
                        const bool is_fullscreen=false, const bool is_closed=false) ;

//! Construct a display from an image \inplace.
    /**
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; assign(const CImg&lt;T&gt;&amp; img,
                        const char *const title=0, const unsigned int normalization=3,
                        const bool is_fullscreen=false, const bool is_closed=false) ;

//! Construct a display from an image list \inplace.
    /**
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; assign(const CImgList&lt;T&gt;&amp; list,
                        const char *const title=0, const unsigned int normalization=3,
                        const bool is_fullscreen=false, const bool is_closed=false) ;

//! Construct a display as a copy of another one \inplace.
    /**
    **/
    CImgDisplay&amp; assign(const CImgDisplay &amp;disp) ;

//! Return a reference to an empty display.
    /**
       \note Can be useful for writing function prototypes where one of the argument (of type CImgDisplay&amp;)
       must have a default value.
       \par Example
       \code
       void foo(CImgDisplay&amp; disp=CImgDisplay::empty());
       \endcode
    **/
    static CImgDisplay&amp; empty() ;

//! Return a reference to an empty display \const.
    static const CImgDisplay&amp; const_empty() ;

//! \name Overloaded Operators
    //@;

//! Display image on associated window.
    /**
       \note &lt;tt&gt;disp = img&lt;/tt&gt; is equivalent to &lt;tt&gt;disp.display(img)&lt;/tt&gt;.
    **/
    template&lt;typename t&gt;
    CImgDisplay&amp; operator=(const CImg&lt;t&gt;&amp; img) ;

//! Display list of images on associated window.
    /**
       \note &lt;tt&gt;disp = list&lt;/tt&gt; is equivalent to &lt;tt&gt;disp.display(list)&lt;/tt&gt;.
    **/
    template&lt;typename t&gt;
    CImgDisplay&amp; operator=(const CImgList&lt;t&gt;&amp; list) ;

//! Construct a display as a copy of another one \inplace.
    /**
       \note Equivalent to assign(const CImgDisplay&amp;).
     **/
    CImgDisplay&amp; operator=(const CImgDisplay&amp; disp) ;

//! Return \c false if display is empty, \c true otherwise.
    /**
       \note &lt;tt&gt;if (disp) { ... }&lt;/tt&gt; is equivalent to &lt;tt&gt;if (!disp.is_empty()) { ... }&lt;/tt&gt;.
    **/
    operator bool() const ;

//! \name Instance Checking
    //@;

//! Return \c true if display is empty, \c false otherwise.
    /**
    **/
    bool is_empty() const ;

//! Return \c true if display is closed (i.e. not visible on the screen), \c false otherwise.
    /**
       \note
       - When a user physically closes the associated window, the display is set to closed.
       - A closed display is not destroyed. Its associated window can be show again on the screen using show().
    **/
    bool is_closed() const ;

//! Return \c true if associated window has been resized on the screen, \c false otherwise.
    /**
    **/
    bool is_resized() const ;

//! Return \c true if associated window has been moved on the screen, \c false otherwise.
    /**
    **/
    bool is_moved() const ;

//! Return \c true if any event has occurred on the associated window, \c false otherwise.
    /**
    **/
    bool is_event() const ;

//! Return \c true if current display is in fullscreen mode, \c false otherwise.
    /**
    **/
    bool is_fullscreen() const ;

//! Return \c true if any key is being pressed on the associated window, \c false otherwise.
    /**
       \note The methods below do the same only for specific keys.
    **/
    bool is_key() const ;

//! Return \c true if key specified by given keycode is being pressed on the associated window, \c false otherwise.
    /**
       \param keycode Keycode to test.
       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
       \par Example
       \code
       CImgDisplay disp(400,400);
       while (!disp.is_closed()) {
         if (disp.key(cimg::keyTAB)) { ... }  // Equivalent to 'if (disp.is_keyTAB())'
         disp.wait();
       }
       \endcode
    **/
    bool is_key(const unsigned int keycode) const ;

//! Return \c true if key specified by given keycode is being pressed on the associated window, \c false otherwise.
    /**
       \param keycode C-string containing the keycode label of the key to test.
       \note Use it when the key you want to test can be dynamically set by the user.
       \par Example
       \code
       CImgDisplay disp(400,400);
       const char *const keycode = "TAB";
       while (!disp.is_closed()) {
         if (disp.is_key(keycode)) { ... }  // Equivalent to 'if (disp.is_keyTAB())'
         disp.wait();
       }
       \endcode
    **/
    bool&amp; is_key(const char *const keycode) ;

//! Return \c true if specified key sequence has been typed on the associated window, \c false otherwise.
    /**
       \param keycodes_sequence Buffer of keycodes to test.
       \param length Number of keys in the \c keycodes_sequence buffer.
       \param remove_sequence Tells if the key sequence must be removed from the key history, if found.
       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
       \par Example
       \code
       CImgDisplay disp(400,400);
       const unsigned int key_seq[] = { cimg::keyCTRLLEFT, cimg::keyD };
       while (!disp.is_closed()) {
         if (disp.is_key_sequence(key_seq,2)) { ... }  // Test for the 'CTRL+D' keyboard event
         disp.wait();
       }
       \endcode
    **/
    bool is_key_sequence(const unsigned int *const keycodes_sequence, const unsigned int length,
                         const bool remove_sequence=false) ;

//! Return \c true if the \c ESC key is being pressed on the associated window, \c false otherwise.
    /**
       \note Similar methods exist for all keys managed by \CImg (see cimg::keyESC).
    **/
    _cimg_iskey_def(ESC);

//! \name Instance Characteristics
    //@;

//! Return width of the screen (current resolution along the X-axis).
    /**
    **/
    static int screen_width() ;

//! Return height of the screen (current resolution along the Y-axis).
    /**
    **/
    static int screen_height() ;

//! Return display width.
    /**
       \note The width of the display (i.e. the width of the pixel data buffer associated to the CImgDisplay instance)
       may be different from the actual width of the associated window.
    **/
    int width() const ;

//! Return display height.
    /**
       \note The height of the display (i.e. the height of the pixel data buffer associated to the CImgDisplay instance)
       may be different from the actual height of the associated window.
    **/
    int height() const ;

//! Return normalization type of the display.
    /**
       The normalization type tells about how the values of an input image are normalized by the CImgDisplay to be
       correctly displayed. The range of values for pixels displayed on screen is &lt;tt&gt;[0,255]&lt;/tt&gt;.
       If the range of values of the data to display is different, a normalization may be required for displaying
       the data in a correct way. The normalization type can be one of:
       - \c 0: Value normalization is disabled. It is then assumed that all input data to be displayed by the
       CImgDisplay instance have values in range &lt;tt&gt;[0,255]&lt;/tt&gt;.
       - \c 1: Value normalization is always performed (this is the default behavior).
       Before displaying an input image, its values will be (virtually) stretched
       in range &lt;tt&gt;[0,255]&lt;/tt&gt;, so that the contrast of the displayed pixels will be maximum.
       Use this mode for images whose minimum and maximum values are not prescribed to known values
       (e.g. float-valued images).
       Note that when normalized versions of images are computed for display purposes, the actual values of these
       images are not modified.
       - \c 2: Value normalization is performed once (on the first image display), then the same normalization
       coefficients are kept for next displayed frames.
       - \c 3: Value normalization depends on the pixel type of the data to display. For integer pixel types,
       the normalization is done regarding the minimum/maximum values of the type (no normalization occurs then
       for &lt;tt&gt;unsigned char&lt;/tt&gt;).
       For float-valued pixel types, the normalization is done regarding the minimum/maximum value of the image
       data instead.
    **/
    unsigned int normalization() const ;

//! Return title of the associated window as a C-string.
    /**
       \note Window title may be not visible, depending on the used window manager or if the current display is
       in fullscreen mode.
    **/
    const char *title() const ;

//! Return width of the associated window.
    /**
       \note The width of the display (i.e. the width of the pixel data buffer associated to the CImgDisplay instance)
       may be different from the actual width of the associated window.
    **/
    int window_width() const ;

//! Return height of the associated window.
    /**
       \note The height of the display (i.e. the height of the pixel data buffer associated to the CImgDisplay instance)
       may be different from the actual height of the associated window.
    **/
    int window_height() const ;

//! Return X-coordinate of the associated window.
    /**
       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
    **/
    int window_x() const ;

//! Return Y-coordinate of the associated window.
    /**
       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
    **/
    int window_y() const ;

//! Return X-coordinate of the mouse pointer.
    /**
       \note
       - If the mouse pointer is outside window area, \c -1 is returned.
       - Otherwise, the returned value is in the range [0,width()-1].
    **/
    int mouse_x() const ;

//! Return Y-coordinate of the mouse pointer.
    /**
       \note
       - If the mouse pointer is outside window area, \c -1 is returned.
       - Otherwise, the returned value is in the range [0,height()-1].
    **/
    int mouse_y() const ;

//! Return current state of the mouse buttons.
    /**
       \note Three mouse buttons can be managed. If one button is pressed, its corresponding bit in the returned
       value is set:
       - bit \c 0 (value \c 0x1): State of the left mouse button.
       - bit \c 1 (value \c 0x2): State of the right mouse button.
       - bit \c 2 (value \c 0x4): State of the middle mouse button.

       Several bits can be activated if more than one button are pressed at the same time.
       \par Example
       \code
       CImgDisplay disp(400,400);
       while (!disp.is_closed()) {
         if (disp.button()&amp;1) { // Left button clicked
           ...
         }
         if (disp.button()&amp;2) { // Right button clicked
           ...
         }
         if (disp.button()&amp;4) { // Middle button clicked
           ...
         }
         disp.wait();
       }
       \endcode
    **/
    unsigned int button() const ;

//! Return current state of the mouse wheel.
    /**
       \note
       - The returned value can be positive or negative depending on whether the mouse wheel has been scrolled
       forward or backward.
       - Scrolling the wheel forward add \c 1 to the wheel value.
       - Scrolling the wheel backward subtract \c 1 to the wheel value.
       - The returned value cumulates the number of forward of backward scrolls since the creation of the display,
       or since the last reset of the wheel value (using set_wheel()). It is strongly recommended to quickly reset
       the wheel counter when an action has been performed regarding the current wheel value.
       Otherwise, the returned wheel value may be for instance \c 0 despite the fact that many scrolls have been done
       (as many in forward as in backward directions).
       \par Example
       \code
       CImgDisplay disp(400,400);
       while (!disp.is_closed()) {
         if (disp.wheel()) {
           int counter = disp.wheel();  // Read the state of the mouse wheel
           ...                          // Do what you want with 'counter'
           disp.set_wheel();            // Reset the wheel value to 0
         }
         disp.wait();
       }
       \endcode
    **/
    int wheel() const ;

//! Return one entry from the pressed keys history.
    /**
       \param pos Index to read from the pressed keys history (index \c 0 corresponds to latest entry).
       \return Keycode of a pressed key or \c 0 for a released key.
       \note
       - Each CImgDisplay stores a history of the pressed keys in a buffer of size \c 128. When a new key is pressed,
       its keycode is stored in the pressed keys history. When a key is released, \c 0 is put instead.
       This means that up to the 64 last pressed keys may be read from the pressed keys history.
       When a new value is stored, the pressed keys history is shifted so that the latest entry is always
       stored at position \c 0.
       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
    **/
    unsigned int&amp; key(const unsigned int pos=0) const ;

//! Return one entry from the released keys history.
    /**
       \param pos Index to read from the released keys history (index \c 0 corresponds to latest entry).
       \return Keycode of a released key or \c 0 for a pressed key.
       \note
       - Each CImgDisplay stores a history of the released keys in a buffer of size \c 128. When a new key is released,
       its keycode is stored in the pressed keys history. When a key is pressed, \c 0 is put instead.
       This means that up to the 64 last released keys may be read from the released keys history.
       When a new value is stored, the released keys history is shifted so that the latest entry is always
       stored at position \c 0.
       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
    **/
    unsigned int&amp; released_key(const unsigned int pos=0) const ;

//! Return keycode corresponding to the specified string.
    /**
       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
       \par Example
       \code
       const unsigned int keyTAB = CImgDisplay::keycode("TAB");  // Return cimg::keyTAB
       \endcode
    **/
    static unsigned int keycode(const char *const keycode) ;

//! Return the current refresh rate, in frames per second.
    /**
       \note Returns a significant value when the current instance is used to display successive frames.
       It measures the delay between successive calls to frames_per_second().
    **/
    float frames_per_second() ;

//! \name Window Manipulation
    //@;

//! Display image on associated window.
    /**
       \param img Input image to display.
       \note This method returns immediately.
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; display(const CImg&lt;T&gt;&amp; img) ;

//! Display list of images on associated window.
    /**
       \param list List of images to display.
       \param axis Axis used to append the images along, for the visualization (can be \c x, \c y, \c z or \c c).
       \param align Relative position of aligned images when displaying lists with images of different sizes
       (\c 0 for upper-left, \c 0.5 for centering and \c 1 for lower-right).
       \note This method returns immediately.
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; display(const CImgList&lt;T&gt;&amp; list, const char axis='x', const float align=0) ;

//! Show (closed) associated window on the screen.
    /**
       \note
       - Force the associated window of a display to be visible on the screen, even if it has been closed before.
       - Using show() on a visible display does nothing.
    **/
    CImgDisplay&amp; show() ;

//! Close (visible) associated window and make it disappear from the screen.
    /**
       \note
       - A closed display only means the associated window is not visible anymore. This does not mean the display has
       been destroyed.
       Use show() to make the associated window reappear.
       - Using close() on a closed display does nothing.
    **/
    CImgDisplay&amp; close() ;

//! Move associated window to a new location.
    /**
       \param pos_x X-coordinate of the new window location.
       \param pos_y Y-coordinate of the new window location.
       \note Depending on the window manager behavior, this method may not succeed (no exceptions are thrown
       nevertheless).
    **/
    CImgDisplay&amp; move(const int pos_x, const int pos_y) ;

//! Resize display to the size of the associated window.
    /**
       \param force_redraw Tells if the previous window content must be updated and refreshed as well.
       \note
       - Calling this method ensures that width() and window_width() become equal, as well as height() and
       window_height().
       - The associated window is also resized to specified dimensions.
    **/
    CImgDisplay&amp; resize(const bool force_redraw=true) ;

//! Resize display to the specified size.
    /**
       \param width Requested display width.
       \param height Requested display height.
       \param force_redraw Tells if the previous window content must be updated and refreshed as well.
       \note The associated window is also resized to specified dimensions.
    **/
    CImgDisplay&amp; resize(const int width, const int height, const bool force_redraw=true) ;

//! Resize display to the size of an input image.
    /**
       \param img Input image to take size from.
       \param force_redraw Tells if the previous window content must be resized and updated as well.
       \note
       - Calling this method ensures that width() and &lt;tt&gt;img.width()&lt;/tt&gt; become equal, as well as height() and
       &lt;tt&gt;img.height()&lt;/tt&gt;.
       - The associated window is also resized to specified dimensions.
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; resize(const CImg&lt;T&gt;&amp; img, const bool force_redraw=true) ;

//! Resize display to the size of another CImgDisplay instance.
    /**
       \param disp Input display to take size from.
       \param force_redraw Tells if the previous window content must be resized and updated as well.
       \note
       - Calling this method ensures that width() and &lt;tt&gt;disp.width()&lt;/tt&gt; become equal, as well as height() and
       &lt;tt&gt;disp.height()&lt;/tt&gt;.
       - The associated window is also resized to specified dimensions.
    **/
    CImgDisplay&amp; resize(const CImgDisplay&amp; disp, const bool force_redraw=true) ;

//! Set normalization type.
    /**
       \param normalization New normalization mode.
    **/
    CImgDisplay&amp; set_normalization(const unsigned int normalization) ;

//! Set title of the associated window.
    /**
       \param format C-string containing the format of the title, as with &lt;tt&gt;std::printf()&lt;/tt&gt;.
       \warning As the first argument is a format string, it is highly recommended to write
       \code
       disp.set_title("%s",window_title);
       \endcode
       instead of
       \code
       disp.set_title(window_title);
       \endcode
       if \c window_title can be arbitrary, to prevent nasty memory access.
    **/
    CImgDisplay&amp; set_title(const char *const format, ...) ;

//! Enable or disable fullscreen mode.
    /**
       \param is_fullscreen Tells is the fullscreen mode must be activated or not.
       \param force_redraw Tells if the previous window content must be displayed as well.
       \note
       - When the fullscreen mode is enabled, the associated window fills the entire screen but the size of the
       current display is not modified.
       - The screen resolution may be switched to fit the associated window size and ensure it appears the largest
       as possible.
       For X-Window (X11) users, the configuration flag \c cimg_use_xrandr has to be set to allow the screen
       resolution change (requires the X11 extensions to be enabled).
    **/
    CImgDisplay&amp; set_fullscreen(const bool is_fullscreen, const bool force_redraw=true) ;

//! Toggle fullscreen mode.
    /**
       \param force_redraw Tells if the previous window content must be displayed as well.
       \note Enable fullscreen mode if it was not enabled, and disable it otherwise.
    **/
    CImgDisplay&amp; toggle_fullscreen(const bool force_redraw=true) ;

//! Show mouse pointer.
    /**
       \note Depending on the window manager behavior, this method may not succeed
       (no exceptions are thrown nevertheless).
    **/
    CImgDisplay&amp; show_mouse() ;

//! Hide mouse pointer.
    /**
       \note Depending on the window manager behavior, this method may not succeed
       (no exceptions are thrown nevertheless).
    **/
    CImgDisplay&amp; hide_mouse() ;

//! Move mouse pointer to a specified location.
    /**
       \note Depending on the window manager behavior, this method may not succeed
       (no exceptions are thrown nevertheless).
    **/
    CImgDisplay&amp; set_mouse(const int pos_x, const int pos_y) ;

//! Simulate a mouse button release event.
    /**
       \note All mouse buttons are considered released at the same time.
    **/
    CImgDisplay&amp; set_button() ;

//! Simulate a mouse button press or release event.
    /**
       \param button Buttons event code, where each button is associated to a single bit.
       \param is_pressed Tells if the mouse button is considered as pressed or released.
    **/
    CImgDisplay&amp; set_button(const unsigned int button, const bool is_pressed=true) ;

//! Flush all mouse wheel events.
    /**
       \note Make wheel() to return \c 0, if called afterwards.
    **/
    CImgDisplay&amp; set_wheel() ;

//! Simulate a wheel event.
    /**
       \param amplitude Amplitude of the wheel scrolling to simulate.
       \note Make wheel() to return \c amplitude, if called afterwards.
    **/
    CImgDisplay&amp; set_wheel(const int amplitude) ;

//! Flush all key events.
    /**
       \note Make key() to return \c 0, if called afterwards.
    **/
    CImgDisplay&amp; set_key() ;

//! Simulate a keyboard press/release event.
    /**
       \param keycode Keycode of the associated key.
       \param is_pressed Tells if the key is considered as pressed or released.
       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
       your code stay portable (see cimg::keyESC).
    **/
    CImgDisplay&amp; set_key(const unsigned int keycode, const bool is_pressed=true) ;

//! Flush all display events.
    /**
       \note Remove all passed events from the current display.
    **/
    CImgDisplay&amp; flush() ;

//! Wait for any user event occurring on the current display.
    CImgDisplay&amp; wait() ;

//! Wait for a given number of milliseconds since the last call to wait().
    /**
       \param milliseconds Number of milliseconds to wait for.
       \note Similar to cimg::wait().
    **/
    CImgDisplay&amp; wait(const unsigned int milliseconds) ;

//! Wait for any event occurring on the display \c disp1.
    static void wait(CImgDisplay&amp; disp1) ;

//! Wait for any event occurring either on the display \c disp1 or \c disp2.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2 or \c disp3.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3 or \c disp4.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4 or \c disp5.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4,
                     CImgDisplay&amp; disp5) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4, ... \c disp6.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4, CImgDisplay&amp; disp5,
                     CImgDisplay&amp; disp6) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4, ... \c disp7.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4, CImgDisplay&amp; disp5,
                     CImgDisplay&amp; disp6, CImgDisplay&amp; disp7) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4, ... \c disp8.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4, CImgDisplay&amp; disp5,
                     CImgDisplay&amp; disp6, CImgDisplay&amp; disp7, CImgDisplay&amp; disp8) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4, ... \c disp9.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4, CImgDisplay&amp; disp5,
                     CImgDisplay&amp; disp6, CImgDisplay&amp; disp7, CImgDisplay&amp; disp8, CImgDisplay&amp; disp9) ;

//! Wait for any event occurring either on the display \c disp1, \c disp2, \c disp3, \c disp4, ... \c disp10.
    static void wait(CImgDisplay&amp; disp1, CImgDisplay&amp; disp2, CImgDisplay&amp; disp3, CImgDisplay&amp; disp4, CImgDisplay&amp; disp5,
                     CImgDisplay&amp; disp6, CImgDisplay&amp; disp7, CImgDisplay&amp; disp8, CImgDisplay&amp; disp9,
                     CImgDisplay&amp; disp10) ;

//! Wait for any window event occurring in any opened CImgDisplay.
    static void wait_all() ;

//! Render image into internal display buffer.
    /**
       \param img Input image data to render.
       \note
       - Convert image data representation into the internal display buffer (architecture-dependent structure).
       - The content of the associated window is not modified, until paint() is called.
       - Should not be used for common CImgDisplay uses, since display() is more useful.
    **/
    template&lt;typename T&gt;
    CImgDisplay&amp; render(const CImg&lt;T&gt;&amp; img) ;

//! Paint internal display buffer on associated window.
    /**
       \note
       - Update the content of the associated window with the internal display buffer, e.g. after a render() call.
       - Should not be used for common CImgDisplay uses, since display() is more useful.
    **/
    CImgDisplay&amp; paint() ;

//! Take a snapshot of the current screen content.
    /**
       \param x0 X-coordinate of the upper left corner.
       \param y0 Y-coordinate of the upper left corner.
       \param x1 X-coordinate of the lower right corner.
       \param y1 Y-coordinate of the lower right corner.
       \param[out] img Output screenshot. Can be empty on input
    **/
    template&lt;typename T&gt;
    static void screenshot(const int x0, const int y0, const int x1, const int y1, CImg&lt;T&gt;&amp; img) ;

//! Take a snapshot of the associated window content.
    /**
       \param[out] img Output snapshot. Can be empty on input.
    **/
    template&lt;typename T&gt;
    const CImgDisplay&amp; snapshot(CImg&lt;T&gt;&amp; img) const ;

//! Class representing an image (up to 4 dimensions wide), each pixel being of type \c T.
  /**
     This is the main class of the %CImg Library. It declares and constructs
     an image, allows access to its pixel values, and is able to perform various image operations.

     \par Image representation

     A %CImg image is defined as an instance of the container \c CImg&lt;T&gt;, which contains a regular grid of pixels,
     each pixel value being of type \c T. The image grid can have up to 4 dimensions: width, height, depth
     and number of channels.
     Usually, the three first dimensions are used to describe spatial coordinates &lt;tt&gt;(x,y,z)&lt;/tt&gt;,
     while the number of channels is rather used as a vector-valued dimension
     (it may describe the R,G,B color channels for instance).
     If you need a fifth dimension, you can use image lists \c CImgList&lt;T&gt; rather than simple images \c CImg&lt;T&gt;.

     Thus, the \c CImg&lt;T&gt; class is able to represent volumetric images of vector-valued pixels,
     as well as images with less dimensions (1D scalar signal, 2D color images, ...).
     Most member functions of the class CImg&lt;\c T&gt; are designed to handle this maximum case of (3+1) dimensions.

     Concerning the pixel value type \c T:
     fully supported template types are the basic C++ types: &lt;tt&gt;unsigned char, char, short, unsigned int, int,
     unsigned long, long, float, double, ... &lt;/tt&gt;.
     Typically, fast image display can be done using &lt;tt&gt;CImg&lt;unsigned char&gt;&lt;/tt&gt; images,
     while complex image processing algorithms may be rather coded using &lt;tt&gt;CImg&lt;float&gt;&lt;/tt&gt; or &lt;tt&gt;CImg&lt;double&gt;&lt;/tt&gt;
     images that have floating-point pixel values. The default value for the template T is \c float.
     Using your own template types may be possible. However, you will certainly have to define the complete set
     of arithmetic and logical operators for your class.

     \par Image structure

     The \c CImg&lt;T&gt; structure contains \e six fields:
     - \c _width defines the number of \a columns of the image (size along the X-axis).
     - \c _height defines the number of \a rows of the image (size along the Y-axis).
     - \c _depth defines the number of \a slices of the image (size along the Z-axis).
     - \c _spectrum defines the number of \a channels of the image (size along the C-axis).
     - \c _data defines a \a pointer to the \a pixel \a data (of type \c T).
     - \c _is_shared is a boolean that tells if the memory buffer \c data is shared with
       another image.

     You can access these fields publicly although it is recommended to use the dedicated functions
     width(), height(), depth(), spectrum() and ptr() to do so.
     Image dimensions are not limited to a specific range (as long as you got enough available memory).
     A value of \e 1 usually means that the corresponding dimension is \a flat.
     If one of the dimensions is \e 0, or if the data pointer is null, the image is considered as \e empty.
     Empty images should not contain any pixel data and thus, will not be processed by CImg member functions
     (a CImgInstanceException will be thrown instead).
     Pixel data are stored in memory, in a non interlaced mode (See \ref cimg_storage).

     \par Image declaration and construction

     Declaring an image can be done by using one of the several available constructors.
     Here is a list of the most used:

     - Construct images from arbitrary dimensions:
         - &lt;tt&gt;CImg&lt;char&gt; img;&lt;/tt&gt; declares an empty image.
         - &lt;tt&gt;CImg&lt;unsigned char&gt; img(128,128);&lt;/tt&gt; declares a 128x128 greyscale image with
         \c unsigned \c char pixel values.
         - &lt;tt&gt;CImg&lt;double&gt; img(3,3);&lt;/tt&gt; declares a 3x3 matrix with \c double coefficients.
         - &lt;tt&gt;CImg&lt;unsigned char&gt; img(256,256,1,3);&lt;/tt&gt; declares a 256x256x1x3 (color) image
         (colors are stored as an image with three channels).
         - &lt;tt&gt;CImg&lt;double&gt; img(128,128,128);&lt;/tt&gt; declares a 128x128x128 volumetric and greyscale image
         (with \c double pixel values).
         - &lt;tt&gt;CImg&lt;&gt; img(128,128,128,3);&lt;/tt&gt; declares a 128x128x128 volumetric color image
         (with \c float pixels, which is the default value of the template parameter \c T).
         - \b Note: images pixels are &lt;b&gt;not automatically initialized to 0&lt;/b&gt;. You may use the function \c fill() to
         do it, or use the specific constructor taking 5 parameters like this:
         &lt;tt&gt;CImg&lt;&gt; img(128,128,128,3,0);&lt;/tt&gt; declares a 128x128x128 volumetric color image with all pixel values to 0.

     - Construct images from filenames:
         - &lt;tt&gt;CImg&lt;unsigned char&gt; img("image.jpg");&lt;/tt&gt; reads a JPEG color image from the file "image.jpg".
         - &lt;tt&gt;CImg&lt;float&gt; img("analyze.hdr");&lt;/tt&gt; reads a volumetric image (ANALYZE7.5 format) from the
         file "analyze.hdr".
         - \b Note: You need to install &lt;a href="http://www.imagemagick.org"&gt;ImageMagick&lt;/a&gt;
         to be able to read common compressed image formats (JPG,PNG, ...) (See \ref cimg_files_io).

     - Construct images from C-style arrays:
         - &lt;tt&gt;CImg&lt;int&gt; img(data_buffer,256,256);&lt;/tt&gt; constructs a 256x256 greyscale image from a \c int* buffer
         \c data_buffer (of size 256x256=65536).
         - &lt;tt&gt;CImg&lt;unsigned char&gt; img(data_buffer,256,256,1,3);&lt;/tt&gt; constructs a 256x256 color image
         from a \c unsigned \c char* buffer \c data_buffer (where R,G,B channels follow each others).

         The complete list of constructors can be found &lt;a href="#constructors"&gt;here&lt;/a&gt;.

     \par Most useful functions

     The \c CImg&lt;T&gt; class contains a lot of functions that operates on images.
     Some of the most useful are:

     - operator()(): Read or write pixel values.
     - display(): displays the image in a new window.
  **/
  template&lt;typename T&gt;
  class CImg ;

//! Simple iterator type, to loop through each pixel value of an image instance.
    /**
       \note
       - The \c CImg&lt;T&gt;::iterator type is defined to be a &lt;tt&gt;T*&lt;/tt&gt;.
       - You will seldom have to use iterators in %CImg, most classical operations
         being achieved (often in a faster way) using methods of \c CImg&lt;T&gt;.
       \par Example
       \code
       CImg&lt;float&gt; img("reference.jpg");                                         // Load image from file
       // Set all pixels to '0', with a CImg iterator.
       for (CImg&lt;float&gt;::iterator it = img.begin(), it&lt;img.end(); ++it) *it = 0;
       img.fill(0);                                                              // Do the same with a built-in method
       \endcode
   **/
    typedef T* iterator;

//! Simple const iterator type, to loop through each pixel value of a \c const image instance.
    /**
       \note
       - The \c CImg&lt;T&gt;::const_iterator type is defined to be a \c const \c T*.
       - You will seldom have to use iterators in %CImg, most classical operations
         being achieved (often in a faster way) using methods of \c CImg&lt;T&gt;.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");                                    // Load image from file
       float sum = 0;
       // Compute sum of all pixel values, with a CImg iterator.
       for (CImg&lt;float&gt;::iterator it = img.begin(), it&lt;img.end(); ++it) sum+=*it;
       const float sum2 = img.sum();                                              // Do the same with a built-in method
       \endcode
    **/
    typedef const T* const_iterator;

//! Pixel value type.
    /**
       Refer to the type of the pixel values of an image instance.
       \note
       - The \c CImg&lt;T&gt;::value_type type of a \c CImg&lt;T&gt; is defined to be a \c T.
       - \c CImg&lt;T&gt;::value_type is actually not used in %CImg methods. It has been mainly defined for
         compatibility with STL naming conventions.
    **/
    typedef T value_type;

//! \name Plugins
    //@;

//! \name Constructors / Destructor / Instance Management
    //@;

//! Destroy image.
    /**
       \note
       - The pixel buffer data() is deallocated if necessary, e.g. for non-empty and non-shared image instances.
       - Destroying an empty or shared image does nothing actually.
       \warning
       - When destroying a non-shared image, make sure that you will \e not operate on a remaining shared image
         that shares its buffer with the destroyed instance, in order to avoid further invalid memory access
         (to a deallocated buffer).
    **/
    ~CImg() ;

//! Construct empty image.
    /**
       \note
       - An empty image has no pixel data and all of its dimensions width(), height(), depth(), spectrum()
         are set to \c 0, as well as its pixel buffer pointer data().
       - An empty image may be re-assigned afterwards, e.g. with the family of
         assign(unsigned int,unsigned int,unsigned int,unsigned int) methods,
         or by operator=(const CImg&lt;t&gt;&amp;). In all cases, the type of pixels stays \c T.
       - An empty image is never shared.
       \par Example
       \code
       CImg&lt;float&gt; img1, img2;      // Construct two empty images
       img1.assign(256,256,1,3);    // Re-assign 'img1' to be a 256x256x1x3 (color) image
       img2 = img1.get_rand(0,255); // Re-assign 'img2' to be a random-valued version of 'img1'
       img2.assign();               // Re-assign 'img2' to be an empty image again
       \endcode
    **/
    CImg():_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image with specified size.
    /**
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \note
       - It is able to create only \e non-shared images, and allocates thus a pixel buffer data()
         for each constructed image instance.
       - Setting one dimension \c size_x,\c size_y,\c size_z or \c size_c to \c 0 leads to the construction of
         an \e empty image.
       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
         (e.g. when requested size is too big for available memory).
       \warning
       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
         In order to initialize pixel values during construction (e.g. with \c 0), use constructor
         CImg(unsigned int,unsigned int,unsigned int,unsigned int,T) instead.
       \par Example
       \code
       CImg&lt;float&gt; img1(256,256,1,3);   // Construct a 256x256x1x3 (color) image, filled with garbage values
       CImg&lt;float&gt; img2(256,256,1,3,0); // Construct a 256x256x1x3 (color) image, filled with value '0'
       \endcode
    **/
    explicit CImg(const unsigned int size_x, const unsigned int size_y=1,
                  const unsigned int size_z=1, const unsigned int size_c=1):
      _is_shared(false) ;

//! Construct image with specified size and initialize pixel values.
    /**
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param value Initialization value.
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int),
         but it also fills the pixel buffer with the specified \c value.
       \warning
       - It cannot be used to construct a vector-valued image and initialize it with \e vector-valued pixels
         (e.g. RGB vector, for color images).
         For this task, you may use fillC() after construction.
    **/
    CImg(const unsigned int size_x, const unsigned int size_y,
         const unsigned int size_z, const unsigned int size_c, const T&amp; value):
      _is_shared(false) ;

//! Construct image with specified size and initialize pixel values from a sequence of integers.
    /**
       Construct a new image instance of size \c size_x x \c size_y x \c size_z x \c size_c,
       with pixels of type \c T, and initialize pixel
       values from the specified sequence of integers \c value0,\c value1,\c ...
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param value0 First value of the initialization sequence (must be an \e integer).
       \param value1 Second value of the initialization sequence (must be an \e integer).
       \param ...
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
         the pixel buffer with a sequence of specified integer values.
       \warning
       - You must specify \e exactly \c size_x*\c size_y*\c size_z*\c size_c integers in the initialization sequence.
         Otherwise, the constructor may crash or fill your image pixels with garbage.
       \par Example
       \code
       const CImg&lt;float&gt; img(2,2,1,3,      // Construct a 2x2 color (RGB) image
                             0,255,0,255,  // Set the 4 values for the red component
                             0,0,255,255,  // Set the 4 values for the green component
                             64,64,64,64); // Set the 4 values for the blue component
       img.resize(150,150).display();
       \endcode
       \image html ref_constructor1.jpg
     **/
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const int value0, const int value1, ...):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image with specified size and initialize pixel values from an initializer list of integers.
    /**
       Construct a new image instance of size \c size_x x \c size_y x \c size_z x \c size_c,
       with pixels of type \c T, and initialize pixel
       values from the specified initializer list of integers { \c value0,\c value1,\c ... }
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param { value0, value1, ... } Initialization list
       \param repeat_values Tells if the value filling process is repeated over the image.

       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
         the pixel buffer with a sequence of specified integer values.
       \par Example
       \code
       const CImg&lt;float&gt; img(2,2,1,3,      // Construct a 2x2 color (RGB) image
                             { 0,255,0,255,    // Set the 4 values for the red component
                               0,0,255,255,    // Set the 4 values for the green component
                               64,64,64,64 }); // Set the 4 values for the blue component
       img.resize(150,150).display();
       \endcode
       \image html ref_constructor1.jpg
    **/
    template&lt;typename t&gt;
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const std::initializer_list&lt;t&gt; values,
         const bool repeat_values=true):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct single channel 1D image with pixel values and width obtained from an initializer list of integers.
    /**
       Construct a new image instance of size \c width x \c 1 x \c 1 x \c 1,
       with pixels of type \c T, and initialize pixel
       values from the specified initializer list of integers { \c value0,\c value1,\c ... }. Image width is
       given by the size of the initializer list.
       \param { value0, value1, ... } Initialization list
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int) with height=1, depth=1, and spectrum=1,
         but it also fills the pixel buffer with a sequence of specified integer values.
       \par Example
       \code
       const CImg&lt;float&gt; img = {10,20,30,20,10 }; // Construct a 5x1 image with one channel, and set its pixel values
       img.resize(150,150).display();
       \endcode
       \image html ref_constructor1.jpg
     **/
    template&lt;typename t&gt;
    CImg(const std::initializer_list&lt;t&gt; values):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image with specified size and initialize pixel values from a sequence of doubles.
    /**
       Construct a new image instance of size \c size_x x \c size_y x \c size_z x \c size_c, with pixels of type \c T,
       and initialize pixel values from the specified sequence of doubles \c value0,\c value1,\c ...
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param value0 First value of the initialization sequence (must be a \e double).
       \param value1 Second value of the initialization sequence (must be a \e double).
       \param ...
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...), but
         takes a sequence of double values instead of integers.
       \warning
       - You must specify \e exactly \c dx*\c dy*\c dz*\c dc doubles in the initialization sequence.
         Otherwise, the constructor may crash or fill your image with garbage.
         For instance, the code below will probably crash on most platforms:
         \code
         const CImg&lt;float&gt; img(2,2,1,1, 0.5,0.5,255,255); // FAIL: The two last arguments are 'int', not 'double'!
         \endcode
     **/
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const double value0, const double value1, ...):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image with specified size and initialize pixel values from a value string.
    /**
       Construct a new image instance of size \c size_x x \c size_y x \c size_z x \c size_c, with pixels of type \c T,
       and initializes pixel values from the specified string \c values.
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param values Value string describing the way pixel values are set.
       \param repeat_values Tells if the value filling process is repeated over the image.
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
         the pixel buffer with values described in the value string \c values.
       - Value string \c values may describe two different filling processes:
         - Either \c values is a sequences of values assigned to the image pixels, as in &lt;tt&gt;"1,2,3,7,8,2"&lt;/tt&gt;.
           In this case, set \c repeat_values to \c true to periodically fill the image with the value sequence.
         - Either, \c values is a formula, as in &lt;tt&gt;"cos(x/10)*sin(y/20)"&lt;/tt&gt;.
           In this case, parameter \c repeat_values is pointless.
       - For both cases, specifying \c repeat_values is mandatory.
         It disambiguates the possible overloading of constructor
         CImg(unsigned int,unsigned int,unsigned int,unsigned int,T) with \c T being a &lt;tt&gt;const char*&lt;/tt&gt;.
       - A \c CImgArgumentException is thrown when an invalid value string \c values is specified.
       \par Example
       \code
       const CImg&lt;float&gt; img1(129,129,1,3,"0,64,128,192,255",true), // Construct image from a value sequence
                         img2(129,129,1,3,"if(c==0,255*abs(cos(x/10)),1.8*y)",false); // Construct image from a formula
       (img1,img2).display();
       \endcode
       \image html ref_constructor2.jpg
     **/
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const char *const values, const bool repeat_values):_is_shared(false) ;

//! Construct image with specified size and initialize pixel values from a memory buffer.
    /**
       Construct a new image instance of size \c size_x x \c size_y x \c size_z x \c size_c, with pixels of type \c T,
       and initializes pixel values from the specified \c t* memory buffer.
       \param values Pointer to the input memory buffer.
       \param size_x Image width().
       \param size_y Image height().
       \param size_z Image depth().
       \param size_c Image spectrum() (number of channels).
       \param is_shared Tells if input memory buffer must be shared by the current instance.
       \note
       - If \c is_shared is \c false, the image instance allocates its own pixel buffer,
         and values from the specified input buffer are copied to the instance buffer.
         If buffer types \c T and \c t are different, a regular static cast is performed during buffer copy.
       - Otherwise, the image instance does \e not allocate a new buffer, and uses the input memory buffer as its
         own pixel buffer. This case requires that types \c T and \c t are the same. Later, destroying such a shared
         image will not deallocate the pixel buffer, this task being obviously charged to the initial buffer allocator.
       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
         (e.g. when requested size is too big for available memory).
       \warning
       - You must take care when operating on a shared image, since it may have an invalid pixel buffer pointer data()
         (e.g. already deallocated).
       \par Example
       \code
       unsigned char tab[256*256] = { 0 };
       CImg&lt;unsigned char&gt; img1(tab,256,256,1,1,false), // Construct new non-shared image from buffer 'tab'
                           img2(tab,256,256,1,1,true);  // Construct new shared-image from buffer 'tab'
       tab[1024] = 255;                                 // Here, 'img2' is indirectly modified, but not 'img1'
       \endcode
    **/
    template&lt;typename t&gt;
    CImg(const t *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false):_is_shared(false) ;

//! Construct image with specified size and initialize pixel values from a memory buffer \specialization.
    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) ;

//! Construct image from memory buffer with specified size and pixel ordering scheme.
    template&lt;typename t&gt;
    CImg(const t *const values, const unsigned int size_x, const unsigned int size_y,
         const unsigned int size_z, const unsigned int size_c,
         const char *const axes_order):_data(0),_is_shared(false) ;

//! Construct image from reading an image file.
    /**
       Construct a new image instance with pixels of type \c T, and initialize pixel values with the data read from
       an image file.
       \param filename Filename, as a C-string.
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it reads the image
         dimensions and pixel values from the specified image file.
       - The recognition of the image file format by %CImg higlhy depends on the tools installed on your system
         and on the external libraries you used to link your code against.
       - Considered pixel type \c T should better fit the file format specification, or data loss may occur during
         file load (e.g. constructing a \c CImg&lt;unsigned char&gt; from a float-valued image file).
       - A \c CImgIOException is thrown when the specified \c filename cannot be read, or if the file format is not
         recognized.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");
       img.display();
       \endcode
       \image html ref_image.jpg
    **/
    explicit CImg(const char *const filename):_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image copy.
    /**
       Construct a new image instance with pixels of type \c T, as a copy of an existing \c CImg&lt;t&gt; instance.
       \param img Input image to copy.
       \note
       - Constructed copy has the same size width() x height() x depth() x spectrum() and pixel values as the
         input image \c img.
       - If input image \c img is \e shared and if types \c T and \c t are the same, the constructed copy is also
         \e shared, and shares its pixel buffer with \c img.
         Modifying a pixel value in the constructed copy will thus also modifies it in the input image \c img.
         This behavior is needful to allow functions to return shared images.
       - Otherwise, the constructed copy allocates its own pixel buffer, and copies pixel values from the input
         image \c img into its buffer. The copied pixel values may be eventually statically casted if types \c T and
         \c t are different.
       - Constructing a copy from an image \c img when types \c t and \c T are the same is significantly faster than
         with different types.
       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
         (e.g. not enough available memory).
    **/
    template&lt;typename t&gt;
    CImg(const CImg&lt;t&gt;&amp; img):_is_shared(false) ;

//! Construct image copy \specialization.
    CImg(const CImg&lt;T&gt;&amp; img) ;

//! Advanced copy constructor.
    /**
       Construct a new image instance with pixels of type \c T, as a copy of an existing \c CImg&lt;t&gt; instance,
       while forcing the shared state of the constructed copy.
       \param img Input image to copy.
       \param is_shared Tells about the shared state of the constructed copy.
       \note
       - Similar to CImg(const CImg&lt;t&gt;&amp;), except that it allows to decide the shared state of
         the constructed image, which does not depend anymore on the shared state of the input image \c img:
         - If \c is_shared is \c true, the constructed copy will share its pixel buffer with the input image \c img.
           For that case, the pixel types \c T and \c t \e must be the same.
         - If \c is_shared is \c false, the constructed copy will allocate its own pixel buffer, whether the input
           image \c img is shared or not.
       - A \c CImgArgumentException is thrown when a shared copy is requested with different pixel types \c T and \c t.
    **/
    template&lt;typename t&gt;
    CImg(const CImg&lt;t&gt;&amp; img, const bool is_shared):_is_shared(false) ;

//! Advanced copy constructor \specialization.
    CImg(const CImg&lt;T&gt;&amp; img, const bool is_shared) ;

//! Construct image with dimensions borrowed from another image.
    /**
       Construct a new image instance with pixels of type \c T, and size get from some dimensions of an existing
       \c CImg&lt;t&gt; instance.
       \param img Input image from which dimensions are borrowed.
       \param dimensions C-string describing the image size along the X,Y,Z and C-dimensions.
       \note
       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it takes the image dimensions
         (\e not its pixel values) from an existing \c CImg&lt;t&gt; instance.
       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
         In order to initialize pixel values (e.g. with \c 0), use constructor CImg(const CImg&lt;t&gt;&amp;,const char*,T)
         instead.
       \par Example
       \code
       const CImg&lt;float&gt; img1(256,128,1,3),      // 'img1' is a 256x128x1x3 image
                         img2(img1,"xyzc"),      // 'img2' is a 256x128x1x3 image
                         img3(img1,"y,x,z,c"),   // 'img3' is a 128x256x1x3 image
                         img4(img1,"c,x,y,3",0), // 'img4' is a 3x128x256x3 image (with pixels initialized to '0')
       \endcode
     **/
    template&lt;typename t&gt;
    CImg(const CImg&lt;t&gt;&amp; img, const char *const dimensions):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image with dimensions borrowed from another image and initialize pixel values.
    /**
       Construct a new image instance with pixels of type \c T, and size get from the dimensions of an existing
       \c CImg&lt;t&gt; instance, and set all pixel values to specified \c value.
       \param img Input image from which dimensions are borrowed.
       \param dimensions String describing the image size along the X,Y,Z and V-dimensions.
       \param value Value used for initialization.
       \note
       - Similar to CImg(const CImg&lt;t&gt;&amp;,const char*), but it also fills the pixel buffer with the specified \c value.
     **/
    template&lt;typename t&gt;
    CImg(const CImg&lt;t&gt;&amp; img, const char *const dimensions, const T&amp; value):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct image from a display window.
    /**
       Construct a new image instance with pixels of type \c T, as a snapshot of an existing \c CImgDisplay instance.
       \param disp Input display window.
       \note
       - The width() and height() of the constructed image instance are the same as the specified \c CImgDisplay.
       - The depth() and spectrum() of the constructed image instance are respectively set to \c 1 and \c 3
         (i.e. a 2D color image).
       - The image pixels are read as 8-bits RGB values.
     **/
    explicit CImg(const CImgDisplay &amp;disp):_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) ;

//! Construct empty image \inplace.
    /**
       In-place version of the default constructor CImg(). It simply resets the instance to an empty image.
    **/
    CImg&lt;T&gt;&amp; assign() ;

//! Construct image with specified size \inplace.
    /**
       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int).
    **/
    CImg&lt;T&gt;&amp; assign(const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) ;

//! Construct image with specified size and initialize pixel values \inplace.
    /**
       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,T).
    **/
    CImg&lt;T&gt;&amp; assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const T&amp; value) ;

//! Construct image with specified size and initialize pixel values from a sequence of integers \inplace.
    /**
       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...).
    **/
    CImg&lt;T&gt;&amp; assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const int value0, const int value1, ...) ;

//! Construct image with specified size and initialize pixel values from a sequence of doubles \inplace.
    /**
       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,double,double,...).
    **/
    CImg&lt;T&gt;&amp; assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const double value0, const double value1, ...) ;

//! Construct image with specified size and initialize pixel values from a value string \inplace.
    /**
       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,const char*,bool).
    **/
    CImg&lt;T&gt;&amp; assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const char *const values, const bool repeat_values) ;

//! Construct image with specified size and initialize pixel values from a memory buffer \inplace.
    /**
       In-place version of the constructor CImg(const t*,unsigned int,unsigned int,unsigned int,unsigned int).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const t *const values, const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) ;

//! Construct image with specified size and initialize pixel values from a memory buffer \specialization.
    CImg&lt;T&gt;&amp; assign(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) ;

//! Construct image with specified size and initialize pixel values from a memory buffer \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const t *const values, const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const bool is_shared) ;

//! Construct image with specified size and initialize pixel values from a memory buffer \overloading.
    CImg&lt;T&gt;&amp; assign(const T *const values, const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const bool is_shared) ;

//! Construct image from memory buffer with specified size and pixel ordering scheme.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const t *const values, const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const char *const axes_order) ;

//! Construct image from reading an image file \inplace.
    /**
       In-place version of the constructor CImg(const char*).
    **/
    CImg&lt;T&gt;&amp; assign(const char *const filename) ;

//! Construct image copy \inplace.
    /**
       In-place version of the constructor CImg(const CImg&lt;t&gt;&amp;).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const CImg&lt;t&gt;&amp; img) ;

//! In-place version of the advanced copy constructor.
    /**
       In-place version of the constructor CImg(const CImg&lt;t&gt;&amp;,bool).
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const CImg&lt;t&gt;&amp; img, const bool is_shared) ;

//! Construct image with dimensions borrowed from another image \inplace.
    /**
       In-place version of the constructor CImg(const CImg&lt;t&gt;&amp;,const char*).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const CImg&lt;t&gt;&amp; img, const char *const dimensions) ;

//! Construct image with dimensions borrowed from another image and initialize pixel values \inplace.
    /**
       In-place version of the constructor CImg(const CImg&lt;t&gt;&amp;,const char*,T).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; assign(const CImg&lt;t&gt;&amp; img, const char *const dimensions, const T&amp; value) ;

//! Construct image from a display window \inplace.
    /**
       In-place version of the constructor CImg(const CImgDisplay&amp;).
    **/
    CImg&lt;T&gt;&amp; assign(const CImgDisplay &amp;disp) ;

//! Construct empty image \inplace.
    /**
       Equivalent to assign().
       \note
       - It has been defined for compatibility with STL naming conventions.
    **/
    CImg&lt;T&gt;&amp; clear() ;

//! Transfer content of an image instance into another one.
    /**
       Transfer the dimensions and the pixel buffer content of an image instance into another one,
       and replace instance by an empty image. It avoids the copy of the pixel buffer
       when possible.
       \param img Destination image.
       \note
       - Pixel types \c T and \c t of source and destination images can be different, though the process is
         designed to be instantaneous when \c T and \c t are the same.
       \par Example
       \code
       CImg&lt;float&gt; src(256,256,1,3,0), // Construct a 256x256x1x3 (color) image filled with value '0'
                   dest(16,16);        // Construct a 16x16x1x1 (scalar) image
       src.move_to(dest);              // Now, 'src' is empty and 'dest' is the 256x256x1x3 image
       \endcode
    **/
    template&lt;typename t&gt;
    CImg&lt;t&gt;&amp; move_to(CImg&lt;t&gt;&amp; img) ;

//! Transfer content of an image instance into another one \specialization.
    CImg&lt;T&gt;&amp; move_to(CImg&lt;T&gt;&amp; img) ;

//! Transfer content of an image instance into a new image in an image list.
    /**
       Transfer the dimensions and the pixel buffer content of an image instance
       into a newly inserted image at position \c pos in specified \c CImgList&lt;t&gt; instance.
       \param list Destination list.
       \param pos Position of the newly inserted image in the list.
       \note
       - When optional parameter \c pos is omitted, the image instance is transferred as a new
         image at the end of the specified \c list.
       - It is convenient to sequentially insert new images into image lists, with no
         additional copies of memory buffer.
       \par Example
       \code
       CImgList&lt;float&gt; list;             // Construct an empty image list
       CImg&lt;float&gt; img("reference.jpg"); // Read image from filename
       img.move_to(list);                // Transfer image content as a new item in the list (no buffer copy)
       \endcode
    **/
    template&lt;typename t&gt;
    CImgList&lt;t&gt;&amp; move_to(CImgList&lt;t&gt;&amp; list, const unsigned int pos=~0U) ;

//! Swap fields of two image instances.
    /**
      \param img Image to swap fields with.
      \note
      - It can be used to interchange the content of two images in a very fast way. Can be convenient when dealing
        with algorithms requiring two swapping buffers.
      \par Example
      \code
      CImg&lt;float&gt; img1("lena.jpg"),
                  img2("milla.jpg");
      img1.swap(img2);    // Now, 'img1' is 'milla' and 'img2' is 'lena'
      \endcode
    **/
    CImg&lt;T&gt;&amp; swap(CImg&lt;T&gt;&amp; img) ;

//! Return a reference to an empty image.
    /**
       \note
       This function is useful mainly to declare optional parameters having type \c CImg&lt;T&gt; in functions prototypes,
       e.g.
       \code
       void f(const int x=0, const int y=0, const CImg&lt;float&gt;&amp; img=CImg&lt;float&gt;::empty());
       \endcode
     **/
    static CImg&lt;T&gt;&amp; empty() ;

//! Return a reference to an empty image \const.
    static const CImg&lt;T&gt;&amp; const_empty() ;

//! \name Overloaded Operators
    //@;

//! Access to a pixel value.
    /**
       Return a reference to a located pixel value of the image instance,
       being possibly \e const, whether the image instance is \e const or not.
       This is the standard method to get/set pixel values in \c CImg&lt;T&gt; images.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Range of pixel coordinates start from &lt;tt&gt;(0,0,0,0)&lt;/tt&gt; to
         &lt;tt&gt;(width() - 1,height() - 1,depth() - 1,spectrum() - 1)&lt;/tt&gt;.
       - Due to the particular arrangement of the pixel buffers defined in %CImg, you can omit one coordinate if the
         corresponding dimension is equal to \c 1.
         For instance, pixels of a 2D image (depth() equal to \c 1) can be accessed by &lt;tt&gt;img(x,y,c)&lt;/tt&gt; instead of
         &lt;tt&gt;img(x,y,0,c)&lt;/tt&gt;.
       \warning
       - There is \e no boundary checking done in this operator, to make it as fast as possible.
         You \e must take care of out-of-bounds access by yourself, if necessary.
         For debugging purposes, you may want to define macro \c 'cimg_verbosity'&gt;=3 to enable additional boundary
         checking operations in this operator. In that case, warning messages will be printed on the error output
         when accessing out-of-bounds pixels.
       \par Example
       \code
       CImg&lt;float&gt; img(100,100,1,3,0); // Construct a 100x100x1x3 (color) image with pixels set to '0'
       const float
          valR = img(10,10,0,0), // Read red value at coordinates (10,10)
          valG = img(10,10,0,1), // Read green value at coordinates (10,10)
          valB = img(10,10,2),   // Read blue value at coordinates (10,10) (Z-coordinate can be omitted)
          avg = (valR + valG + valB)/3; // Compute average pixel value
       img(10,10,0) = img(10,10,1) = img(10,10,2) = avg; // Replace the color pixel (10,10) by the average grey value
       \endcode
    **/
#if cimg_verbosity&gt;=3
    T&amp; operator()(const unsigned int x, const unsigned int y=0,
                  const unsigned int z=0, const unsigned int c=0) ;

//! Access to a pixel value \const.
    const T&amp; operator()(const unsigned int x, const unsigned int y=0,
                        const unsigned int z=0, const unsigned int c=0) const ;

//! Access to a pixel value.
    /**
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param wh Precomputed offset, must be equal to &lt;tt&gt;width()*\ref height()&lt;/tt&gt;.
       \param whd Precomputed offset, must be equal to &lt;tt&gt;width()*\ref height()*\ref depth()&lt;/tt&gt;.
       \note
       - Similar to (but faster than) operator()().
         It uses precomputed offsets to optimize memory access. You may use it to optimize
         the reading/writing of several pixel values in the same image (e.g. in a loop).
     **/
    T&amp; operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c,
                  const ulongT wh, const ulongT whd=0) ;

//! Access to a pixel value \const.
    const T&amp; operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c,
                        const ulongT wh, const ulongT whd=0) const ;

//! Implicitly cast an image into a \c T*.
    /**
       Implicitly cast a \c CImg&lt;T&gt; instance into a \c T* or \c const \c T* pointer, whether the image instance
       is \e const or not. The returned pointer points on the first value of the image pixel buffer.
       \note
       - It simply returns the pointer data() to the pixel buffer.
       - This implicit conversion is convenient to test the empty state of images (data() being \c 0 in this case), e.g.
       \code
       CImg&lt;float&gt; img1(100,100), img2; // 'img1' is a 100x100 image, 'img2' is an empty image
       if (img1) {                      // Test succeeds, 'img1' is not an empty image
         if (!img2) {                   // Test succeeds, 'img2' is an empty image
           std::printf("'img1' is not empty, 'img2' is empty.");
         }
       }
       \endcode
       - It also allows to use brackets to access pixel values, without need for a \c CImg&lt;T&gt;::operator[](), e.g.
       \code
       CImg&lt;float&gt; img(100,100);
       const float value = img[99]; // Access to value of the last pixel on the first row
       img[510] = 255;              // Set pixel value at (10,5)
       \endcode
    **/
    operator T*() ;

//! Implicitly cast an image into a \c T* \const.
    operator const T*() const ;

//! Assign a value to all image pixels.
    /**
       Assign specified \c value to each pixel value of the image instance.
       \param value Value that will be assigned to image pixels.
       \note
       - The image size is never modified.
       - The \c value may be casted to pixel type \c T if necessary.
       \par Example
       \code
       CImg&lt;char&gt; img(100,100); // Declare image (with garbage values)
       img = 0;                 // Set all pixel values to '0'
       img = 1.2;               // Set all pixel values to '1' (cast of '1.2' as a 'char')
       \endcode
    **/
    CImg&lt;T&gt;&amp; operator=(const T&amp; value) ;

//! Assign pixels values from a specified expression.
    /**
       Initialize all pixel values from the specified string \c expression.
       \param expression Value string describing the way pixel values are set.
       \note
       - String parameter \c expression may describe different things:
         - If \c expression is a list of values (as in \c "1,2,3,8,3,2"), or a formula (as in \c "(x*y)%255"),
           the pixel values are set from specified \c expression and the image size is not modified.
         - If \c expression is a filename (as in \c "reference.jpg"), the corresponding image file is loaded and
           replace the image instance. The image size is modified if necessary.
       \par Example
       \code
       CImg&lt;float&gt; img1(100,100), img2(img1), img3(img1); // Declare 3 scalar images 100x100 with uninitialized values
       img1 = "0,50,100,150,200,250,200,150,100,50"; // Set pixel values of 'img1' from a value sequence
       img2 = "10*((x*y)%25)";                       // Set pixel values of 'img2' from a formula
       img3 = "reference.jpg";                       // Set pixel values of 'img3' from a file (image size is modified)
       (img1,img2,img3).display();
       \endcode
       \image html ref_operator_eq.jpg
    **/
    CImg&lt;T&gt;&amp; operator=(const char *const expression) ;

//! Copy an image into the current image instance.
    /**
       Similar to the in-place copy constructor assign(const CImg&lt;t&gt;&amp;).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator=(const CImg&lt;t&gt;&amp; img) ;

//! Copy an image into the current image instance \specialization.
    CImg&lt;T&gt;&amp; operator=(const CImg&lt;T&gt;&amp; img) ;

//! Copy the content of a display window to the current image instance.
    /**
       Similar to assign(const CImgDisplay&amp;).
    **/
    CImg&lt;T&gt;&amp; operator=(const CImgDisplay&amp; disp) ;

//! In-place addition operator.
    /**
       Add specified \c value to all pixels of an image instance.
       \param value Value to add.
       \note
       - Resulting pixel values are casted to fit the pixel type \c T.
         For instance, adding \c 0.2 to a \c CImg&lt;char&gt; is possible but does nothing indeed.
       - Overflow values are treated as with standard C++ numeric types. For instance,
       \code
       CImg&lt;unsigned char&gt; img(100,100,1,1,255); // Construct a 100x100 image with pixel values '255'
       img+=1;                                   // Add '1' to each pixels -&gt; Overflow
       // here all pixels of image 'img' are equal to '0'.
       \endcode
       - To prevent value overflow, you may want to consider pixel type \c T as \c float or \c double,
         and use cut() after addition.
       \par Example
       \code
       CImg&lt;unsigned char&gt; img1("reference.jpg"); // Load a 8-bits RGB image (values in [0,255])
       CImg&lt;float&gt; img2(img1); // Construct a float-valued copy of 'img1'
       img2+=100; // Add '100' to pixel values -&gt; goes out of [0,255] but no problems with floats
       img2.cut(0,255); // Cut values in [0,255] to fit the 'unsigned char' constraint
       img1 = img2; // Rewrite safe result in 'unsigned char' version 'img1'
       const CImg&lt;unsigned char&gt; img3 = (img1 + 100).cut(0,255); // Do the same in a more simple and elegant way
       (img1,img2,img3).display();
       \endcode
       \image html ref_operator_plus.jpg
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator+=(const t value) ;

//! In-place addition operator.
    /**
       Add values to image pixels, according to the specified string \c expression.
       \param expression Value string describing the way pixel values are added.
       \note
       - Similar to operator=(const char*), except that it adds values to the pixels of the current image instance,
         instead of assigning them.
    **/
    CImg&lt;T&gt;&amp; operator+=(const char *const expression) ;

//! In-place addition operator.
    /**
       Add values to image pixels, according to the values of the input image \c img.
       \param img Input image to add.
       \note
       - The size of the image instance is never modified.
       - It is not mandatory that input image \c img has the same size as the image instance.
         If less values are available in \c img, then the values are added periodically. For instance, adding one
         WxH scalar image (spectrum() equal to \c 1) to one WxH color image (spectrum() equal to \c 3)
         means each color channel will be incremented with the same values at the same locations.
       \par Example
       \code
       CImg&lt;float&gt; img1("reference.jpg"); // Load a RGB color image (img1.spectrum()==3)
       // Construct a scalar shading (img2.spectrum()==1).
       const CImg&lt;float&gt; img2(img1.width(),img.height(),1,1,"255*(x/w)^2");
       img1+=img2; // Add shading to each channel of 'img1'
       img1.cut(0,255); // Prevent [0,255] overflow
       (img2,img1).display();
       \endcode
       \image html ref_operator_plus1.jpg
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator+=(const CImg&lt;t&gt;&amp; img) ;

//! In-place increment operator (prefix).
    /**
       Add \c 1 to all image pixels, and return a reference to the current incremented image instance.
       \note
       - Writing \c ++img is equivalent to \c img+=1.
     **/
    CImg&lt;T&gt;&amp; operator++() ;

//! In-place increment operator (postfix).
    /**
       Add \c 1 to all image pixels, and return a new copy of the initial (pre-incremented) image instance.
       \note
       - Use the prefixed version operator++() if you don't need a copy of the initial
         (pre-incremented) image instance, since a useless image copy may be expensive in terms of memory usage.
     **/
    CImg&lt;T&gt; operator++(int) ;

//! Return a non-shared copy of the image instance.
    /**
       \note
       - Use this operator to ensure you get a non-shared copy of an image instance with same pixel type \c T.
         Indeed, the usual copy constructor CImg&lt;T&gt;(const CImg&lt;T&gt;&amp;) returns a shared copy of a shared input image,
         and it may be not desirable to work on a regular copy (e.g. for a resize operation) if you have no
         information about the shared state of the input image.
       - Writing \c (+img) is equivalent to \c CImg&lt;T&gt;(img,false).
    **/
    CImg&lt;T&gt; operator+() const ;

//! Addition operator.
    /**
       Similar to operator+=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
     **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator+(const t value) const ;

//! Addition operator.
    /**
       Similar to operator+=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
     **/
    CImg&lt;Tfloat&gt; operator+(const char *const expression) const ;

//! Addition operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
     **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator+(const CImg&lt;t&gt;&amp; img) const ;

//! In-place subtraction operator.
    /**
       Similar to operator+=(const t), except that it performs a subtraction instead of an addition.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator-=(const t value) ;

//! In-place subtraction operator.
    /**
       Similar to operator+=(const char*), except that it performs a subtraction instead of an addition.
     **/
    CImg&lt;T&gt;&amp; operator-=(const char *const expression) ;

//! In-place subtraction operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a subtraction instead of an addition.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator-=(const CImg&lt;t&gt;&amp; img) ;

//! In-place decrement operator (prefix).
    /**
       Similar to operator++(), except that it performs a decrement instead of an increment.
    **/
    CImg&lt;T&gt;&amp; operator--() ;

//! In-place decrement operator (postfix).
    /**
       Similar to operator++(int), except that it performs a decrement instead of an increment.
    **/
    CImg&lt;T&gt; operator--(int) ;

//! Replace each pixel by its opposite value.
    /**
       \note
       - If the computed opposite values are out-of-range, they are treated as with standard C++ numeric types.
         For instance, the \c unsigned \c char opposite of \c 1 is \c 255.
       \par Example
       \code
       const CImg&lt;unsigned char&gt;
         img1("reference.jpg"),   // Load a RGB color image
         img2 = -img1;            // Compute its opposite (in 'unsigned char')
       (img1,img2).display();
       \endcode
       \image html ref_operator_minus.jpg
     **/
    CImg&lt;T&gt; operator-() const ;

//! Subtraction operator.
    /**
       Similar to operator-=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator-(const t value) const ;

//! Subtraction operator.
    /**
       Similar to operator-=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    CImg&lt;Tfloat&gt; operator-(const char *const expression) const ;

//! Subtraction operator.
    /**
       Similar to operator-=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator-(const CImg&lt;t&gt;&amp; img) const ;

//! In-place multiplication operator.
    /**
       Similar to operator+=(const t), except that it performs a multiplication instead of an addition.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator*=(const t value) ;

//! In-place multiplication operator.
    /**
       Similar to operator+=(const char*), except that it performs a multiplication instead of an addition.
     **/
    CImg&lt;T&gt;&amp; operator*=(const char *const expression) ;

//! In-place multiplication operator.
    /**
       Replace the image instance by the matrix multiplication between the image instance and the specified matrix
       \c img.
       \param img Second operand of the matrix multiplication.
       \note
       - It does \e not compute a pointwise multiplication between two images. For this purpose, use
         mul(const CImg&lt;t&gt;&amp;) instead.
       - The size of the image instance can be modified by this operator.
       \par Example
       \code
       CImg&lt;float&gt; A(2,2,1,1, 1,2,3,4);   // Construct 2x2 matrix A = [1,2;3,4]
       const CImg&lt;float&gt; X(1,2,1,1, 1,2); // Construct 1x2 vector X = [1;2]
       A*=X;                              // Assign matrix multiplication A*X to 'A'
       // 'A' is now a 1x2 vector whose values are [5;11].
       \endcode
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator*=(const CImg&lt;t&gt;&amp; img) ;

//! Multiplication operator.
    /**
       Similar to operator*=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator*(const t value) const ;

//! Multiplication operator.
    /**
       Similar to operator*=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    CImg&lt;Tfloat&gt; operator*(const char *const expression) const ;

//! Multiplication operator.
    /**
       Similar to operator*=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator*(const CImg&lt;t&gt;&amp; img) const ;

//! In-place division operator.
    /**
       Similar to operator+=(const t), except that it performs a division instead of an addition.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator/=(const t value) ;

//! In-place division operator.
    /**
       Similar to operator+=(const char*), except that it performs a division instead of an addition.
     **/
    CImg&lt;T&gt;&amp; operator/=(const char *const expression) ;

//! In-place division operator.
    /**
       Replace the image instance by the (right) matrix division between the image instance and the specified
       matrix \c img.
       \param img Second operand of the matrix division.
       \note
       - It does \e not compute a pointwise division between two images. For this purpose, use
         div(const CImg&lt;t&gt;&amp;) instead.
       - It returns the matrix operation \c A*inverse(img).
       - The size of the image instance can be modified by this operator.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator/=(const CImg&lt;t&gt;&amp; img) ;

//! Division operator.
    /**
       Similar to operator/=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator/(const t value) const ;

//! Division operator.
    /**
       Similar to operator/=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    CImg&lt;Tfloat&gt; operator/(const char *const expression) const ;

//! Division operator.
    /**
       Similar to operator/=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator/(const CImg&lt;t&gt;&amp; img) const ;

//! In-place modulo operator.
    /**
       Similar to operator+=(const t), except that it performs a modulo operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator%=(const t value) ;

//! In-place modulo operator.
    /**
       Similar to operator+=(const char*), except that it performs a modulo operation instead of an addition.
    **/
    CImg&lt;T&gt;&amp; operator%=(const char *const expression) ;

//! In-place modulo operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a modulo operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator%=(const CImg&lt;t&gt;&amp; img) ;

//! Modulo operator.
    /**
       Similar to operator%=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator%(const t value) const ;

//! Modulo operator.
    /**
       Similar to operator%=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    CImg&lt;Tfloat&gt; operator%(const char *const expression) const ;

//! Modulo operator.
    /**
       Similar to operator%=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image may be a superset of the initial pixel type \c T, if necessary.
    **/
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; operator%(const CImg&lt;t&gt;&amp; img) const ;

//! In-place bitwise AND operator.
    /**
       Similar to operator+=(const t), except that it performs a bitwise AND operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&amp;=(const t value) ;

//! In-place bitwise AND operator.
    /**
       Similar to operator+=(const char*), except that it performs a bitwise AND operation instead of an addition.
    **/
    CImg&lt;T&gt;&amp; operator&amp;=(const char *const expression) ;

//! In-place bitwise AND operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a bitwise AND operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&amp;=(const CImg&lt;t&gt;&amp; img) ;

//! Bitwise AND operator.
    /**
       Similar to operator&amp;=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&amp;(const t value) const ;

//! Bitwise AND operator.
    /**
       Similar to operator&amp;=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    CImg&lt;T&gt; operator&amp;(const char *const expression) const ;

//! Bitwise AND operator.
    /**
       Similar to operator&amp;=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&amp;(const CImg&lt;t&gt;&amp; img) const ;

//! In-place bitwise OR operator.
    /**
       Similar to operator+=(const t), except that it performs a bitwise OR operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator|=(const t value) ;

//! In-place bitwise OR operator.
    /**
       Similar to operator+=(const char*), except that it performs a bitwise OR operation instead of an addition.
    **/
    CImg&lt;T&gt;&amp; operator|=(const char *const expression) ;

//! In-place bitwise OR operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a bitwise OR operation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator|=(const CImg&lt;t&gt;&amp; img) ;

//! Bitwise OR operator.
    /**
       Similar to operator|=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator|(const t value) const ;

//! Bitwise OR operator.
    /**
       Similar to operator|=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    CImg&lt;T&gt; operator|(const char *const expression) const ;

//! Bitwise OR operator.
    /**
       Similar to operator|=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator|(const CImg&lt;t&gt;&amp; img) const ;

//! In-place bitwise XOR operator.
    /**
       Similar to operator+=(const t), except that it performs a bitwise XOR operation instead of an addition.
       \warning
       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const t) instead.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator^=(const t value) ;

//! In-place bitwise XOR operator.
    /**
       Similar to operator+=(const char*), except that it performs a bitwise XOR operation instead of an addition.
       \warning
       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const char*) instead.
    **/
    CImg&lt;T&gt;&amp; operator^=(const char *const expression) ;

//! In-place bitwise XOR operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a bitwise XOR operation instead of an addition.
       \warning
       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const CImg&lt;t&gt;&amp;) instead.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator^=(const CImg&lt;t&gt;&amp; img) ;

//! Bitwise XOR operator.
    /**
       Similar to operator^=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator^(const t value) const ;

//! Bitwise XOR operator.
    /**
       Similar to operator^=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    CImg&lt;T&gt; operator^(const char *const expression) const ;

//! Bitwise XOR operator.
    /**
       Similar to operator^=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator^(const CImg&lt;t&gt;&amp; img) const ;

//! In-place bitwise left shift operator.
    /**
       Similar to operator+=(const t), except that it performs a bitwise left shift instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&lt;&lt;=(const t value) ;

//! In-place bitwise left shift operator.
    /**
       Similar to operator+=(const char*), except that it performs a bitwise left shift instead of an addition.
    **/
    CImg&lt;T&gt;&amp; operator&lt;&lt;=(const char *const expression) ;

//! In-place bitwise left shift operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a bitwise left shift instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&lt;&lt;=(const CImg&lt;t&gt;&amp; img) ;

//! Bitwise left shift operator.
    /**
       Similar to operator&lt;&lt;=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&lt;&lt;(const t value) const ;

//! Bitwise left shift operator.
    /**
       Similar to operator&lt;&lt;=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    CImg&lt;T&gt; operator&lt;&lt;(const char *const expression) const ;

//! Bitwise left shift operator.
    /**
       Similar to operator&lt;&lt;=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of
       operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&lt;&lt;(const CImg&lt;t&gt;&amp; img) const ;

//! In-place bitwise right shift operator.
    /**
       Similar to operator+=(const t), except that it performs a bitwise right shift instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&gt;&gt;=(const t value) ;

//! In-place bitwise right shift operator.
    /**
       Similar to operator+=(const char*), except that it performs a bitwise right shift instead of an addition.
    **/
    CImg&lt;T&gt;&amp; operator&gt;&gt;=(const char *const expression) ;

//! In-place bitwise right shift operator.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a bitwise right shift instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; operator&gt;&gt;=(const CImg&lt;t&gt;&amp; img) ;

//! Bitwise right shift operator.
    /**
       Similar to operator&gt;&gt;=(const t), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&gt;&gt;(const t value) const ;

//! Bitwise right shift operator.
    /**
       Similar to operator&gt;&gt;=(const char*), except that it returns a new image instance instead of operating in-place.
       The pixel type of the returned image is \c T.
    **/
    CImg&lt;T&gt; operator&gt;&gt;(const char *const expression) const ;

//! Bitwise right shift operator.
    /**
       Similar to operator&gt;&gt;=(const CImg&lt;t&gt;&amp;), except that it returns a new image instance instead of
       operating in-place.
       The pixel type of the returned image is \c T.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt; operator&gt;&gt;(const CImg&lt;t&gt;&amp; img) const ;

//! Bitwise inversion operator.
    /**
       Similar to operator-(), except that it compute the bitwise inverse instead of the opposite value.
    **/
    CImg&lt;T&gt; operator~() const ;

//! Test if all pixels of an image have the same value.
    /**
       Return \c true is all pixels of the image instance are equal to the specified \c value.
       \param value Reference value to compare with.
    **/
    template&lt;typename t&gt;
    bool operator==(const t value) const ;

//! Test if all pixel values of an image follow a specified expression.
    /**
       Return \c true is all pixels of the image instance are equal to the specified \c expression.
       \param expression Value string describing the way pixel values are compared.
    **/
    bool operator==(const char *const expression) const ;

//! Test if two images have the same size and values.
    /**
       Return \c true if the image instance and the input image \c img have the same pixel values,
       even if the dimensions of the two images do not match. It returns \c false otherwise.
       \param img Input image to compare with.
       \note
       - The pixel buffer pointers data() of the two compared images do not have to be the same for operator==()
         to return \c true.
         Only the dimensions and the pixel values matter. Thus, the comparison can be \c true even for different
         pixel types \c T and \c t.
       \par Example
       \code
       const CImg&lt;float&gt; img1(1,3,1,1, 0,1,2); // Construct a 1x3 vector [0;1;2] (with 'float' pixel values)
       const CImg&lt;char&gt; img2(1,3,1,1, 0,1,2);  // Construct a 1x3 vector [0;1;2] (with 'char' pixel values)
       if (img1==img2) {                       // Test succeeds, image dimensions and values are the same
         std::printf("'img1' and 'img2' have same dimensions and values.");
       }
       \endcode
    **/
    template&lt;typename t&gt;
    bool operator==(const CImg&lt;t&gt;&amp; img) const ;

//! Test if pixels of an image are all different from a value.
    /**
       Return \c true is all pixels of the image instance are different than the specified \c value.
       \param value Reference value to compare with.
    **/
    template&lt;typename t&gt;
    bool operator!=(const t value) const ;

//! Test if all pixel values of an image are different from a specified expression.
    /**
       Return \c true is all pixels of the image instance are different to the specified \c expression.
       \param expression Value string describing the way pixel values are compared.
    **/
    bool operator!=(const char *const expression) const ;

//! Test if two images have different sizes or values.
    /**
       Return \c true if the image instance and the input image \c img have different dimensions or pixel values,
       and \c false otherwise.
       \param img Input image to compare with.
       \note
       - Writing \c img1!=img2 is equivalent to \c !(img1==img2).
    **/
    template&lt;typename t&gt;
    bool operator!=(const CImg&lt;t&gt;&amp; img) const ;

//! Construct an image list from two images.
    /**
       Return a new list of image (\c CImgList instance) containing exactly two elements:
         - A copy of the image instance, at position [\c 0].
         - A copy of the specified image \c img, at position [\c 1].

       \param img Input image that will be the second image of the resulting list.
       \note
       - The family of operator,() is convenient to easily create list of images, but it is also \e quite \e slow
         in practice (see warning below).
       - Constructed lists contain no shared images. If image instance or input image \c img are shared, they are
         inserted as new non-shared copies in the resulting list.
       - The pixel type of the returned list may be a superset of the initial pixel type \c T, if necessary.
       \warning
       - Pipelining operator,() \c N times will perform \c N copies of the entire content of a (growing) image list.
         This may become very expensive in terms of speed and used memory. You should avoid using this technique to
         build a new CImgList instance from several images, if you are seeking for performance.
         Fast insertions of images in an image list are possible with
         CImgList&lt;T&gt;::insert(const CImg&lt;t&gt;&amp;,unsigned int,bool) or move_to(CImgList&lt;t&gt;&amp;,unsigned int).
       \par Example
       \code
       const CImg&lt;float&gt;
          img1("reference.jpg"),
          img2 = img1.get_mirror('x'),
          img3 = img2.get_blur(5);
       const CImgList&lt;float&gt; list = (img1,img2); // Create list of two elements from 'img1' and 'img2'
       (list,img3).display();                    // Display image list containing copies of 'img1','img2' and 'img3'
       \endcode
       \image html ref_operator_comma.jpg
    **/
    template&lt;typename t&gt;
    CImgList&lt;_cimg_Tt&gt; operator,(const CImg&lt;t&gt;&amp; img) const ;

//! Construct an image list from image instance and an input image list.
    /**
       Return a new list of images (\c CImgList instance) containing exactly \c list.size() \c + \c 1 elements:
         - A copy of the image instance, at position [\c 0].
         - A copy of the specified image list \c list, from positions [\c 1] to [\c list.size()].

       \param list Input image list that will be appended to the image instance.
       \note
       - Similar to operator,(const CImg&lt;t&gt;&amp;) const, except that it takes an image list as an argument.
    **/
    template&lt;typename t&gt;
    CImgList&lt;_cimg_Tt&gt; operator,(const CImgList&lt;t&gt;&amp; list) const ;

//! Split image along specified axis.
    /**
       Return a new list of images (\c CImgList instance) containing the split components
       of the instance image along the specified axis.
       \param axis Splitting axis (can be '\c x','\c y','\c z' or '\c c')
       \note
       - Similar to get_split(char,int) const, with default second argument.
       \par Example
       \code
       const CImg&lt;unsigned char&gt; img("reference.jpg"); // Load a RGB color image
       const CImgList&lt;unsigned char&gt; list = (img&lt;'c'); // Get a list of its three R,G,B channels
       (img,list).display();
       \endcode
       \image html ref_operator_less.jpg
    **/
    CImgList&lt;T&gt; operator&lt;(const char axis) const ;

//! \name Instance Characteristics
    //@;

//! Return the type of image pixel values as a C string.
    /**
       Return a \c char* string containing the usual type name of the image pixel values
       (i.e. a stringified version of the template parameter \c T).
       \note
       - The returned string may contain spaces (as in \c "unsigned char").
       - If the pixel type \c T does not correspond to a registered type, the string &lt;tt&gt;"unknown"&lt;/tt&gt; is returned.
    **/
    static const char* pixel_type() ;

//! Return the number of image columns.
    /**
       Return the image width, i.e. the image dimension along the X-axis.
       \note
       - The width() of an empty image is equal to \c 0.
       - width() is typically equal to \c 1 when considering images as \e vectors for matrix calculations.
       - width() returns an \c int, although the image width is internally stored as an \c unsigned \c int.
         Using an \c int is safer and prevents arithmetic traps possibly encountered when doing calculations involving
         \c unsigned \c int variables.
         Access to the initial \c unsigned \c int variable is possible (though not recommended) by
         &lt;tt&gt;(*this)._width&lt;/tt&gt;.
    **/
    int width() const ;

//! Return the number of image rows.
    /**
       Return the image height, i.e. the image dimension along the Y-axis.
       \note
       - The height() of an empty image is equal to \c 0.
       - height() returns an \c int, although the image height is internally stored as an \c unsigned \c int.
         Using an \c int is safer and prevents arithmetic traps possibly encountered when doing calculations involving
         \c unsigned \c int variables.
         Access to the initial \c unsigned \c int variable is possible (though not recommended) by
         &lt;tt&gt;(*this)._height&lt;/tt&gt;.
    **/
    int height() const ;

//! Return the number of image slices.
    /**
       Return the image depth, i.e. the image dimension along the Z-axis.
       \note
       - The depth() of an empty image is equal to \c 0.
       - depth() is typically equal to \c 1 when considering usual 2D images. When depth()\c &gt; \c 1, the image
         is said to be \e volumetric.
       - depth() returns an \c int, although the image depth is internally stored as an \c unsigned \c int.
         Using an \c int is safer and prevents arithmetic traps possibly encountered when doing calculations involving
         \c unsigned \c int variables.
         Access to the initial \c unsigned \c int variable is possible (though not recommended) by
         &lt;tt&gt;(*this)._depth&lt;/tt&gt;.
    **/
    int depth() const ;

//! Return the number of image channels.
    /**
       Return the number of image channels, i.e. the image dimension along the C-axis.
       \note
       - The spectrum() of an empty image is equal to \c 0.
       - spectrum() is typically equal to \c 1 when considering scalar-valued images, to \c 3
         for RGB-coded color images, and to \c 4 for RGBA-coded color images (with alpha-channel).
         The number of channels of an image instance is not limited. The meaning of the pixel values is not linked
         up to the number of channels (e.g. a 4-channel image may indifferently stands for a RGBA or CMYK color image).
       - spectrum() returns an \c int, although the image spectrum is internally stored as an \c unsigned \c int.
         Using an \c int is safer and prevents arithmetic traps possibly encountered when doing calculations involving
         \c unsigned \c int variables.
         Access to the initial \c unsigned \c int variable is possible (though not recommended) by
         &lt;tt&gt;(*this)._spectrum&lt;/tt&gt;.
    **/
    int spectrum() const ;

//! Return the total number of pixel values.
    /**
       Return &lt;tt&gt;width()*\ref height()*\ref depth()*\ref spectrum()&lt;/tt&gt;,
       i.e. the total number of values of type \c T in the pixel buffer of the image instance.
       \note
       - The size() of an empty image is equal to \c 0.
       - The allocated memory size for a pixel buffer of a non-shared \c CImg&lt;T&gt; instance is equal to
         &lt;tt&gt;size()*sizeof(T)&lt;/tt&gt;.
       \par Example
       \code
       const CImg&lt;float&gt; img(100,100,1,3);               // Construct new 100x100 color image
       if (img.size()==30000)                            // Test succeeds
         std::printf("Pixel buffer uses %lu bytes",
                     img.size()*sizeof(float));
       \endcode
    **/
    ulongT size() const ;

//! Return a pointer to the first pixel value.
    /**
       Return a \c T*, or a \c const \c T* pointer to the first value in the pixel buffer of the image instance,
       whether the instance is \c const or not.
       \note
       - The data() of an empty image is equal to \c 0 (null pointer).
       - The allocated pixel buffer for the image instance starts from \c data()
         and goes to &lt;tt&gt;data()+\ref size() - 1&lt;/tt&gt; (included).
       - To get the pointer to one particular location of the pixel buffer, use
         data(unsigned int,unsigned int,unsigned int,unsigned int) instead.
    **/
    T* data() ;

//! Return a pointer to the first pixel value \const.
    const T* data() const ;

//! Return a pointer to a located pixel value.
    /**
       Return a \c T*, or a \c const \c T* pointer to the value located at (\c x,\c y,\c z,\c c) in the pixel buffer
       of the image instance,
       whether the instance is \c const or not.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Writing \c img.data(x,y,z,c) is equivalent to &lt;tt&gt;&amp;(img(x,y,z,c))&lt;/tt&gt;. Thus, this method has the same
         properties as operator()(unsigned int,unsigned int,unsigned int,unsigned int).
     **/
#if cimg_verbosity&gt;=3
    T *data(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int c=0) ;

//! Return a pointer to a located pixel value \const.
    const T* data(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int c=0) const ;

//! Return the offset to a located pixel value, with respect to the beginning of the pixel buffer.
    /**
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Writing \c img.data(x,y,z,c) is equivalent to &lt;tt&gt;&amp;(img(x,y,z,c)) - img.data()&lt;/tt&gt;.
         Thus, this method has the same properties as operator()(unsigned int,unsigned int,unsigned int,unsigned int).
       \par Example
       \code
       const CImg&lt;float&gt; img(100,100,1,3);      // Define a 100x100 RGB-color image
       const long off = img.offset(10,10,0,2);  // Get the offset of the blue value of the pixel located at (10,10)
       const float val = img[off];              // Get the blue value of this pixel
       \endcode
    **/
    longT offset(const int x, const int y=0, const int z=0, const int c=0) const ;

//! Return a CImg&lt;T&gt;::iterator pointing to the first pixel value.
    /**
       \note
       - Equivalent to data().
       - It has been mainly defined for compatibility with STL naming conventions.
     **/
    iterator begin() ;

//! Return a CImg&lt;T&gt;::iterator pointing to the first value of the pixel buffer \const.
    const_iterator begin() const ;

//! Return a CImg&lt;T&gt;::iterator pointing next to the last pixel value.
    /**
       \note
       - Writing \c img.end() is equivalent to &lt;tt&gt;img.data() + img.size()&lt;/tt&gt;.
       - It has been mainly defined for compatibility with STL naming conventions.
       \warning
       - The returned iterator actually points to a value located \e outside the acceptable bounds of the pixel buffer.
         Trying to read or write the content of the returned iterator will probably result in a crash.
         Use it mainly as a strict upper bound for a CImg&lt;T&gt;::iterator.
       \par Example
       \code
       CImg&lt;float&gt; img(100,100,1,3); // Define a 100x100 RGB color image
       // 'img.end()' used below as an upper bound for the iterator.
       for (CImg&lt;float&gt;::iterator it = img.begin(); it&lt;img.end(); ++it)
         *it = 0;
       \endcode
    **/
    iterator end() ;

//! Return a CImg&lt;T&gt;::iterator pointing next to the last pixel value \const.
    const_iterator end() const ;

//! Return a reference to the first pixel value.
    /**
       \note
       - Writing \c img.front() is equivalent to &lt;tt&gt;img[0]&lt;/tt&gt;, or &lt;tt&gt;img(0,0,0,0)&lt;/tt&gt;.
       - It has been mainly defined for compatibility with STL naming conventions.
    **/
    T&amp; front() ;

//! Return a reference to the first pixel value \const.
    const T&amp; front() const ;

//! Return a reference to the last pixel value.
    /**
       \note
       - Writing \c img.back() is equivalent to &lt;tt&gt;img[img.size() - 1]&lt;/tt&gt;, or
         &lt;tt&gt;img(img.width() - 1,img.height() - 1,img.depth() - 1,img.spectrum() - 1)&lt;/tt&gt;.
       - It has been mainly defined for compatibility with STL naming conventions.
    **/
    T&amp; back() ;

//! Return a reference to the last pixel value \const.
    const T&amp; back() const ;

//! Access to a pixel value at a specified offset, using Dirichlet boundary conditions.
    /**
       Return a reference to the pixel value of the image instance located at a specified \c offset,
       or to a specified default value in case of out-of-bounds access.
       \param offset Offset to the desired pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note
       - Writing \c img.at(offset,out_value) is similar to &lt;tt&gt;img[offset]&lt;/tt&gt;, except that if \c offset
         is outside bounds (e.g. \c offset&lt;0 or \c offset&gt;=img.size()), a reference to a value \c out_value
         is safely returned instead.
       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
         you are \e not sure about the validity of the specified pixel offset.
    **/
    T&amp; at(const int offset, const T&amp; out_value) ;

//! Access to a pixel value at a specified offset, using Dirichlet boundary conditions \const.
    T at(const int offset, const T&amp; out_value) const ;

//! Access to a pixel value at a specified offset, using Neumann boundary conditions.
    /**
       Return a reference to the pixel value of the image instance located at a specified \c offset,
       or to the nearest pixel location in the image instance in case of out-of-bounds access.
       \param offset Offset to the desired pixel value.
       \note
       - Similar to at(int,const T), except that an out-of-bounds access returns the value of the
         nearest pixel in the image instance, regarding the specified offset, i.e.
         - If \c offset&lt;0, then \c img[0] is returned.
         - If \c offset&gt;=img.size(), then \c img[img.size() - 1] is returned.
       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
         you are \e not sure about the validity of the specified pixel offset.
       - If you know your image instance is \e not empty, you may rather use the slightly faster method \c _at(int).
     **/
    T&amp; at(const int offset) ;

//! Access to a pixel value at a specified offset, using Neumann boundary conditions \const.
    const T&amp; at(const int offset) const ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate.
    /**
       Return a reference to the pixel value of the image instance located at (\c x,\c y,\c z,\c c),
       or to a specified default value in case of out-of-bounds access along the X-axis.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c (\c x,\c y,\c z,\c c) is outside image bounds.
       \note
       - Similar to operator()(), except that an out-of-bounds access along the X-axis returns the specified value
         \c out_value.
       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
         you are \e not sure about the validity of the specified pixel coordinates.
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
    **/
    T&amp; atX(const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate \const.
    T atX(const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to a pixel value, using Neumann boundary conditions for the X-coordinate.
    /**
       Return a reference to the pixel value of the image instance located at (\c x,\c y,\c z,\c c),
       or to the nearest pixel location in the image instance in case of out-of-bounds access along the X-axis.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Similar to at(int,int,int,int,const T), except that an out-of-bounds access returns the value of the
         nearest pixel in the image instance, regarding the specified X-coordinate.
       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
         you are \e not sure about the validity of the specified pixel coordinates.
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _at(int,int,int,int).
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
     **/
    T&amp; atX(const int x, const int y=0, const int z=0, const int c=0) ;

//! Access to a pixel value, using Neumann boundary conditions for the X-coordinate \const.
    const T&amp; atX(const int x, const int y=0, const int z=0, const int c=0) const ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X and Y-coordinates.
    /**
       Similar to atX(int,int,int,int,const T), except that boundary checking is performed both on X and Y-coordinates.
    **/
    T&amp; atXY(const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X and Y coordinates \const.
    T atXY(const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates.
    /**
       Similar to atX(int,int,int,int), except that boundary checking is performed both on X and Y-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _atXY(int,int,int,int).
     **/
    T&amp; atXY(const int x, const int y, const int z=0, const int c=0) ;

//! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates \const.
    const T&amp; atXY(const int x, const int y, const int z=0, const int c=0) const ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to atX(int,int,int,int,const T), except that boundary checking is performed both on
       X,Y and Z-coordinates.
    **/
    T&amp; atXYZ(const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates \const.
    T atXYZ(const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to atX(int,int,int,int), except that boundary checking is performed both on X,Y and Z-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _atXYZ(int,int,int,int).
    **/
    T&amp; atXYZ(const int x, const int y, const int z, const int c=0) ;

//! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates \const.
    const T&amp; atXYZ(const int x, const int y, const int z, const int c=0) const ;

//! Access to a pixel value, using Dirichlet boundary conditions.
    /**
       Similar to atX(int,int,int,int,const T), except that boundary checking is performed on all
       X,Y,Z and C-coordinates.
    **/
    T&amp; atXYZC(const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to a pixel value, using Dirichlet boundary conditions \const.
    T atXYZC(const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to a pixel value, using Neumann boundary conditions.
    /**
       Similar to atX(int,int,int,int), except that boundary checking is performed on all X,Y,Z and C-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _atXYZC(int,int,int,int).
    **/
    T&amp; atXYZC(const int x, const int y, const int z, const int c) ;

//! Access to a pixel value, using Neumann boundary conditions \const.
    const T&amp; atXYZC(const int x, const int y, const int z, const int c) const ;

//! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X-coordinate.
    /**
       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
       or a specified default value in case of out-of-bounds access along the X-axis.
       \param fx X-coordinate of the pixel value (float-valued).
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c (\c fx,\c y,\c z,\c c) is outside image bounds.
       \note
       - Similar to atX(int,int,int,int,const T), except that the returned pixel value is approximated by
         a linear interpolation along the X-axis, if corresponding coordinates are not integers.
       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
    **/
    Tfloat linear_atX(const float fx, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Return pixel value, using linear interpolation and Neumann boundary conditions for the X-coordinate.
    /**
       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
       or the value of the nearest pixel location in the image instance in case of out-of-bounds access along
       the X-axis.
       \param fx X-coordinate of the pixel value (float-valued).
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Similar to linear_atX(float,int,int,int,const T) const, except that an out-of-bounds access returns
         the value of the nearest pixel in the image instance, regarding the specified X-coordinate.
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _linear_atX(float,int,int,int).
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
    **/
    Tfloat linear_atX(const float fx, const int y=0, const int z=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and periodic boundary conditions for the X-coordinate.
    Tfloat linear_atX_p(const float fx, const int y=0, const int z=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
    /**
       Similar to linear_atX(float,int,int,int,const T) const, except that the linear interpolation and the
       boundary checking are achieved both for X and Y-coordinates.
    **/
    Tfloat linear_atXY(const float fx, const float fy, const int z, const int c, const T&amp; out_value) const ;

//! Return pixel value, using linear interpolation and Neumann boundary conditions for the X and Y-coordinates.
    /**
       Similar to linear_atX(float,int,int,int) const, except that the linear interpolation and the boundary checking
       are achieved both for X and Y-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _linear_atXY(float,float,int,int).
    **/
    Tfloat linear_atXY(const float fx, const float fy, const int z=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and periodic boundary conditions for the X and Y-coordinates.
    Tfloat linear_atXY_p(const float fx, const float fy, const int z=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to linear_atX(float,int,int,int,const T) const, except that the linear interpolation and the
       boundary checking are achieved both for X,Y and Z-coordinates.
    **/
    Tfloat linear_atXYZ(const float fx, const float fy, const float fz, const int c, const T&amp; out_value) const ;

//! Return pixel value, using linear interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to linear_atX(float,int,int,int) const, except that the linear interpolation and the boundary checking
       are achieved both for X,Y and Z-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _linear_atXYZ(float,float,float,int).
    **/
    Tfloat linear_atXYZ(const float fx, const float fy=0, const float fz=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and periodic boundary conditions for the X,Y and Z-coordinates.
    Tfloat linear_atXYZ_p(const float fx, const float fy=0, const float fz=0, const int c=0) const ;

//! Return pixel value, using linear interpolation and Dirichlet boundary conditions for all X,Y,Z,C-coordinates.
    /**
       Similar to linear_atX(float,int,int,int,const T) const, except that the linear interpolation and the
       boundary checking are achieved for all X,Y,Z and C-coordinates.
    **/
    Tfloat linear_atXYZC(const float fx, const float fy, const float fz, const float fc, const T&amp; out_value) const ;

//! Return pixel value, using linear interpolation and Neumann boundary conditions for all X,Y,Z and C-coordinates.
    /**
       Similar to linear_atX(float,int,int,int) const, except that the linear interpolation and the boundary checking
       are achieved for all X,Y,Z and C-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _linear_atXYZC(float,float,float,float).
    **/
    Tfloat linear_atXYZC(const float fx, const float fy=0, const float fz=0, const float fc=0) const ;

//! Return pixel value, using linear interpolation and periodic boundary conditions for all X,Y,Z and C-coordinates.
    Tfloat linear_atXYZC_p(const float fx, const float fy=0, const float fz=0, const float fc=0) const ;

//! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
    /**
       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
       or a specified default value in case of out-of-bounds access along the X-axis.
       The cubic interpolation uses Hermite splines.
       \param fx d X-coordinate of the pixel value (float-valued).
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c (\c fx,\c y,\c z,\c c) is outside image bounds.
       \note
       - Similar to linear_atX(float,int,int,int,const T) const, except that the returned pixel value is
         approximated by a \e cubic interpolation along the X-axis.
       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
    **/
    Tfloat cubic_atX(const float fx, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
    /**
       Similar to cubic_atX(float,int,int,int,const T) const, except that the return value is clamped to stay in the
       min/max range of the datatype \c T.
    **/
    T cubic_atX_c(const float fx, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
    /**
       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
       or the value of the nearest pixel location in the image instance in case of out-of-bounds access
       along the X-axis. The cubic interpolation uses Hermite splines.
       \param fx X-coordinate of the pixel value (float-valued).
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Similar to cubic_atX(float,int,int,int,const T) const, except that the returned pixel value is
         approximated by a cubic interpolation along the X-axis.
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _cubic_atX(float,int,int,int).
       \warning
       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
    **/
    Tfloat cubic_atX(const float fx, const int y=0, const int z=0, const int c=0) const ;

//! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
    /**
       Similar to cubic_atX(float,int,int,int) const, except that the return value is clamped to stay in the
       min/max range of the datatype \c T.
    **/
    T cubic_atX_c(const float fx, const int y, const int z, const int c) const ;

//! Return pixel value, using cubic interpolation and periodic boundary conditions for the X-coordinate.
    Tfloat cubic_atX_p(const float fx, const int y=0, const int z=0, const int c=0) const ;

//! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
    /**
       Similar to cubic_atX(float,int,int,int,const T) const, except that the cubic interpolation and boundary checking
       are achieved both for X and Y-coordinates.
    **/
    Tfloat cubic_atXY(const float fx, const float fy, const int z, const int c, const T&amp; out_value) const ;

//! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y-coordinates.
    /**
       Similar to cubic_atXY(float,float,int,int,const T) const, except that the return value is clamped to stay in the
       min/max range of the datatype \c T.
    **/
    T cubic_atXY_c(const float fx, const float fy, const int z, const int c, const T&amp; out_value) const ;

//! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X and Y-coordinates.
    /**
       Similar to cubic_atX(float,int,int,int) const, except that the cubic interpolation and boundary checking
       are achieved for both X and Y-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
       \c _cubic_atXY(float,float,int,int).
    **/
    Tfloat cubic_atXY(const float fx, const float fy, const int z=0, const int c=0) const ;

//! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y-coordinates.
    /**
       Similar to cubic_atXY(float,float,int,int) const, except that the return value is clamped to stay in the
       min/max range of the datatype \c T.
    **/
    T cubic_atXY_c(const float fx, const float fy, const int z, const int c) const ;

//! Return pixel value, using cubic interpolation and periodic boundary conditions for the X and Y-coordinates.
    Tfloat cubic_atXY_p(const float fx, const float fy, const int z=0, const int c=0) const ;

//! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to cubic_atX(float,int,int,int,const T) const, except that the cubic interpolation and boundary checking
       are achieved both for X,Y and Z-coordinates.
    **/
    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c, const T&amp; out_value) const ;

//! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the XYZ-coordinates.
    /**
       Similar to cubic_atXYZ(float,float,float,int,const T) const, except that the return value is clamped to stay
       in the min/max range of the datatype \c T.
    **/
    T cubic_atXYZ_c(const float fx, const float fy, const float fz, const int c, const T&amp; out_value) const ;

//! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to cubic_atX(float,int,int,int) const, except that the cubic interpolation and boundary checking
       are achieved both for X,Y and Z-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _cubic_atXYZ(float,float,float,int).
    **/
    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c=0) const ;

//! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the XYZ-coordinates.
    /**
       Similar to cubic_atXYZ(float,float,float,int) const, except that the return value is clamped to stay in the
       min/max range of the datatype \c T.
    **/
    T cubic_atXYZ_c(const float fx, const float fy, const float fz, const int c) const ;

//! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
    /**
       Similar to cubic_atX(float,int,int,int) const, except that the cubic interpolation and boundary checking
       are achieved both for X,Y and Z-coordinates.
       \note
       - If you know your image instance is \e not empty, you may rather use the slightly faster method
         \c _cubic_atXYZ(float,float,float,int).
    **/
    Tfloat cubic_atXYZ_p(const float fx, const float fy, const float fz, const int c=0) const ;

//! Set pixel value, using linear interpolation for the X-coordinates.
    /**
       Set pixel value at specified coordinates (\c fx,\c y,\c z,\c c) in the image instance, in a way that
       the value is spread amongst several neighbors if the pixel coordinates are float-valued.
       \param value Pixel value to set.
       \param fx X-coordinate of the pixel value (float-valued).
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param is_added Tells if the pixel value is added to (\c true), or simply replace (\c false) the current image
         pixel(s).
       \return A reference to the current image instance.
       \note
       - Calling this method with out-of-bounds coordinates does nothing.
    **/
    CImg&lt;T&gt;&amp; set_linear_atX(const T&amp; value, const float fx, const int y=0, const int z=0, const int c=0,
                            const bool is_added=false) ;

//! Set pixel value, using linear interpolation for the X and Y-coordinates.
    /**
       Similar to set_linear_atX(const T&amp;,float,int,int,int,bool), except that the linear interpolation
       is achieved both for X and Y-coordinates.
    **/
    CImg&lt;T&gt;&amp; set_linear_atXY(const T&amp; value, const float fx, const float fy=0, const int z=0, const int c=0,
                             const bool is_added=false) ;

//! Set pixel value, using linear interpolation for the X,Y and Z-coordinates.
    /**
       Similar to set_linear_atXY(const T&amp;,float,float,int,int,bool), except that the linear interpolation
       is achieved both for X,Y and Z-coordinates.
    **/
    CImg&lt;T&gt;&amp; set_linear_atXYZ(const T&amp; value, const float fx, const float fy=0, const float fz=0, const int c=0,
                              const bool is_added=false) ;

//! Return a C-string containing a list of all values of the image instance.
    /**
       Return a new \c CImg&lt;char&gt; image whose buffer data() is a \c char* string describing the list of all pixel values
       of the image instance (written in base 10), separated by specified \c separator character.
       \param separator A \c char character which specifies the separator between values in the returned C-string.
       \param max_size Maximum size of the returned image (or \c 0 if no limits are set).
       \param format For float/double-values, tell the printf format used to generate the text representation
         of the numbers (or \c 0 for default representation).
       \note
       - The returned image is never empty.
       - For an empty image instance, the returned string is &lt;tt&gt;""&lt;/tt&gt;.
       - If \c max_size is equal to \c 0, there are no limits on the size of the returned string.
       - Otherwise, if the maximum number of string characters is exceeded, the value string is cut off
         and terminated by character \c '\0'. In that case, the returned image size is &lt;tt&gt;max_size + 1&lt;/tt&gt;.
    **/
    CImg&lt;charT&gt; value_string(const char separator=',', const unsigned int max_size=0,
                             const char *const format=0) const ;

//! \name Instance Checking
    //@;

//! Test shared state of the pixel buffer.
    /**
       Return \c true if image instance has a shared memory buffer, and \c false otherwise.
       \note
       - A shared image do not own his pixel buffer data() and will not deallocate it on destruction.
       - Most of the time, a \c CImg&lt;T&gt; image instance will \e not be shared.
       - A shared image can only be obtained by a limited set of constructors and methods (see list below).
    **/
    bool is_shared() const ;

//! Test if image instance is empty.
    /**
       Return \c true, if image instance is empty, i.e. does \e not contain any pixel values, has dimensions
       \c 0 x \c 0 x \c 0 x \c 0 and a pixel buffer pointer set to \c 0 (null pointer), and \c false otherwise.
    **/
    bool is_empty() const ;

//! Test if image instance contains a 'inf' value.
    /**
       Return \c true, if image instance contains a 'inf' value, and \c false otherwise.
    **/
    bool is_inf() const ;

//! Test if image instance contains a NaN value.
    /**
       Return \c true, if image instance contains a NaN value, and \c false otherwise.
    **/
    bool is_nan() const ;

//! Test if image width is equal to specified value.
    bool is_sameX(const unsigned int size_x) const ;

//! Test if image width is equal to specified value.
    template&lt;typename t&gt;
    bool is_sameX(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width is equal to specified value.
    bool is_sameX(const CImgDisplay&amp; disp) const ;

//! Test if image height is equal to specified value.
    bool is_sameY(const unsigned int size_y) const ;

//! Test if image height is equal to specified value.
    template&lt;typename t&gt;
    bool is_sameY(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image height is equal to specified value.
    bool is_sameY(const CImgDisplay&amp; disp) const ;

//! Test if image depth is equal to specified value.
    bool is_sameZ(const unsigned int size_z) const ;

//! Test if image depth is equal to specified value.
    template&lt;typename t&gt;
    bool is_sameZ(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image spectrum is equal to specified value.
    bool is_sameC(const unsigned int size_c) const ;

//! Test if image spectrum is equal to specified value.
    template&lt;typename t&gt;
    bool is_sameC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width and height are equal to specified values.
    /**
       Test if is_sameX(unsigned int) const and is_sameY(unsigned int) const are both verified.
    **/
    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const ;

//! Test if image width and height are the same as that of another image.
    /**
       Test if is_sameX(const CImg&lt;t&gt;&amp;) const and is_sameY(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXY(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width and height are the same as that of an existing display window.
    /**
       Test if is_sameX(const CImgDisplay&amp;) const and is_sameY(const CImgDisplay&amp;) const are both verified.
    **/
    bool is_sameXY(const CImgDisplay&amp; disp) const ;

//! Test if image width and depth are equal to specified values.
    /**
       Test if is_sameX(unsigned int) const and is_sameZ(unsigned int) const are both verified.
    **/
    bool is_sameXZ(const unsigned int size_x, const unsigned int size_z) const ;

//! Test if image width and depth are the same as that of another image.
    /**
       Test if is_sameX(const CImg&lt;t&gt;&amp;) const and is_sameZ(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXZ(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width and spectrum are equal to specified values.
    /**
       Test if is_sameX(unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameXC(const unsigned int size_x, const unsigned int size_c) const ;

//! Test if image width and spectrum are the same as that of another image.
    /**
       Test if is_sameX(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image height and depth are equal to specified values.
    /**
       Test if is_sameY(unsigned int) const and is_sameZ(unsigned int) const are both verified.
    **/
    bool is_sameYZ(const unsigned int size_y, const unsigned int size_z) const ;

//! Test if image height and depth are the same as that of another image.
    /**
       Test if is_sameY(const CImg&lt;t&gt;&amp;) const and is_sameZ(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameYZ(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image height and spectrum are equal to specified values.
    /**
       Test if is_sameY(unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameYC(const unsigned int size_y, const unsigned int size_c) const ;

//! Test if image height and spectrum are the same as that of another image.
    /**
       Test if is_sameY(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameYC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image depth and spectrum are equal to specified values.
    /**
       Test if is_sameZ(unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameZC(const unsigned int size_z, const unsigned int size_c) const ;

//! Test if image depth and spectrum are the same as that of another image.
    /**
       Test if is_sameZ(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameZC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width, height and depth are equal to specified values.
    /**
       Test if is_sameXY(unsigned int,unsigned int) const and is_sameZ(unsigned int) const are both verified.
    **/
    bool is_sameXYZ(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z) const ;

//! Test if image width, height and depth are the same as that of another image.
    /**
       Test if is_sameXY(const CImg&lt;t&gt;&amp;) const and is_sameZ(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXYZ(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width, height and spectrum are equal to specified values.
    /**
       Test if is_sameXY(unsigned int,unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameXYC(const unsigned int size_x, const unsigned int size_y, const unsigned int size_c) const ;

//! Test if image width, height and spectrum are the same as that of another image.
    /**
       Test if is_sameXY(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXYC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width, depth and spectrum are equal to specified values.
    /**
       Test if is_sameXZ(unsigned int,unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameXZC(const unsigned int size_x, const unsigned int size_z, const unsigned int size_c) const ;

//! Test if image width, depth and spectrum are the same as that of another image.
    /**
       Test if is_sameXZ(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXZC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image height, depth and spectrum are equal to specified values.
    /**
       Test if is_sameYZ(unsigned int,unsigned int) const and is_sameC(unsigned int) const are both verified.
    **/
    bool is_sameYZC(const unsigned int size_y, const unsigned int size_z, const unsigned int size_c) const ;

//! Test if image height, depth and spectrum are the same as that of another image.
    /**
       Test if is_sameYZ(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameYZC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if image width, height, depth and spectrum are equal to specified values.
    /**
       Test if is_sameXYZ(unsigned int,unsigned int,unsigned int) const and is_sameC(unsigned int) const are both
       verified.
    **/
    bool is_sameXYZC(const unsigned int size_x, const unsigned int size_y,
                     const unsigned int size_z, const unsigned int size_c) const ;

//! Test if image width, height, depth and spectrum are the same as that of another image.
    /**
       Test if is_sameXYZ(const CImg&lt;t&gt;&amp;) const and is_sameC(const CImg&lt;t&gt;&amp;) const are both verified.
    **/
    template&lt;typename t&gt;
    bool is_sameXYZC(const CImg&lt;t&gt;&amp; img) const ;

//! Test if specified coordinates are inside image bounds.
    /**
       Return \c true if pixel located at (\c x,\c y,\c z,\c c) is inside bounds of the image instance,
       and \c false otherwise.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note
       - Return \c true only if all these conditions are verified:
         - The image instance is \e not empty.
         - &lt;tt&gt;0&lt;=x&lt;=\ref width() - 1&lt;/tt&gt;.
         - &lt;tt&gt;0&lt;=y&lt;=\ref height() - 1&lt;/tt&gt;.
         - &lt;tt&gt;0&lt;=z&lt;=\ref depth() - 1&lt;/tt&gt;.
         - &lt;tt&gt;0&lt;=c&lt;=\ref spectrum() - 1&lt;/tt&gt;.
    **/
    bool containsXYZC(const int x, const int y=0, const int z=0, const int c=0) const ;

//! Test if pixel value is inside image bounds and get its X,Y,Z and C-coordinates.
    /**
       Return \c true, if specified reference refers to a pixel value inside bounds of the image instance,
       and \c false otherwise.
       \param pixel Reference to pixel value to test.
       \param[out] x X-coordinate of the pixel value, if test succeeds.
       \param[out] y Y-coordinate of the pixel value, if test succeeds.
       \param[out] z Z-coordinate of the pixel value, if test succeeds.
       \param[out] c C-coordinate of the pixel value, if test succeeds.
       \note
       - Useful to convert an offset to a buffer value into pixel value coordinates:
       \code
       const CImg&lt;float&gt; img(100,100,1,3);      // Construct a 100x100 RGB color image
       const unsigned long offset = 1249;       // Offset to the pixel (49,12,0,0)
       unsigned int x,y,z,c;
       if (img.contains(img[offset],x,y,z,c)) { // Convert offset to (x,y,z,c) coordinates
         std::printf("Offset %u refers to pixel located at (%u,%u,%u,%u).\n",
                     offset,x,y,z,c);
       }
       \endcode
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; x, t&amp; y, t&amp; z, t&amp; c) const ;

//! Test if pixel value is inside image bounds and get its X,Y and Z-coordinates.
    /**
       Similar to contains(const T&amp;,t&amp;,t&amp;,t&amp;,t&amp;) const, except that only the X,Y and Z-coordinates are set.
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; x, t&amp; y, t&amp; z) const ;

//! Test if pixel value is inside image bounds and get its X and Y-coordinates.
    /**
       Similar to contains(const T&amp;,t&amp;,t&amp;,t&amp;,t&amp;) const, except that only the X and Y-coordinates are set.
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; x, t&amp; y) const ;

//! Test if pixel value is inside image bounds and get its X-coordinate.
    /**
       Similar to contains(const T&amp;,t&amp;,t&amp;,t&amp;,t&amp;) const, except that only the X-coordinate is set.
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; x) const ;

//! Test if pixel value is inside image bounds.
    /**
       Similar to contains(const T&amp;,t&amp;,t&amp;,t&amp;,t&amp;) const, except that no pixel coordinates are set.
    **/
    bool contains(const T&amp; pixel) const ;

//! Test if pixel buffers of instance and input images overlap.
    /**
       Return \c true, if pixel buffers attached to image instance and input image \c img overlap,
       and \c false otherwise.
       \param img Input image to compare with.
       \note
       - Buffer overlapping may happen when manipulating \e shared images.
       - If two image buffers overlap, operating on one of the image will probably modify the other one.
       - Most of the time, \c CImg&lt;T&gt; instances are \e non-shared and do not overlap between each others.
       \par Example
       \code
       const CImg&lt;float&gt;
         img1("reference.jpg"),             // Load RGB-color image
         img2 = img1.get_shared_channel(1); // Get shared version of the green channel
       if (img1.is_overlapped(img2)) {      // Test succeeds, 'img1' and 'img2' overlaps
         std::printf("Buffers overlap!\n");
       }
       \endcode
    **/
    template&lt;typename t&gt;
    bool is_overlapped(const CImg&lt;t&gt;&amp; img) const ;

//! Test if the set ;

//! Test if image instance represents a valid serialization of a 3D object.
    /**
       Return \c true if the image instance represents a valid serialization of a 3D object, and \c false otherwise.
       \param full_check Tells if full checking of the instance must be performed.
       \param[out] error_message C-string to contain the error message, if the test does not succeed.
       \note
       - Set \c full_check to \c false to speed-up the 3D object checking. In this case, only the size of
         each 3D object component is checked.
       - Size of the string \c error_message should be at least 128-bytes long, to be able to contain the error message.
    **/
    bool is_CImg3d(const bool full_check=true, char *const error_message=0) const ;

//! \name Mathematical Functions
    //@;

//! Compute the square value of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its square value \f$I_{(x,y,z,c)}^2\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");
       (img,img.get_sqr().normalize(0,255)).display();
       \endcode
       \image html ref_sqr.jpg
    **/
    _cimg_create_pointwise_functions(sqr,cimg::sqr,524288)

    //! Compute the square root of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its square root \f$\sqrt{I_{(x,y,z,c)}}\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");
       (img,img.get_sqrt().normalize(0,255)).display();
       \endcode
       \image html ref_sqrt.jpg
    **/
    _cimg_create_pointwise_functions(sqrt,std::sqrt,8192)

    //! Compute the exponential of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its exponential \f$e^{I_{(x,y,z,c)}}\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(exp,std::exp,4096)

    //! Compute the error function of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its error function.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(erf,std::erf,4096)

    //! Compute the logarithm of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its logarithm
       \f$\mathrm{log}_{e}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(log,std::log,262144)

    //! Compute the base-2 logarithm of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-2 logarithm
       \f$\mathrm{log}_{2}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(log2,cimg::log2,4096)

    //! Compute the base-10 logarithm of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-10 logarithm
       \f$\mathrm{log}_{10}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(log10,std::log10,4096)

    //! Compute the absolute value of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its absolute value \f$|I_{(x,y,z,c)}|\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(abs,cimg::abs,524288)

    //! Compute the sign of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its sign
       \f$\mathrm{sign}(I_{(x,y,z,c)})\f$.
       \note
       - The sign is set to:
         - \c 1 if pixel value is strictly positive.
         - \c -1 if pixel value is strictly negative.
         - \c 0 if pixel value is equal to \c 0.
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(sign,cimg::sign,32768)

    //! Compute the cosine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its cosine \f$\cos(I_{(x,y,z,c)})\f$.
       \note
       - Pixel values are regarded as being in \e radian.
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(cos,std::cos,8192)

    //! Compute the sine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its sine \f$\sin(I_{(x,y,z,c)})\f$.
       \note
       - Pixel values are regarded as being in \e radian.
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(sin,std::sin,8192)

    //! Compute the sinc of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its sinc
       \f$\mathrm{sinc}(I_{(x,y,z,c)})\f$.
       \note
       - Pixel values are regarded as being exin \e radian.
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(sinc,cimg::sinc,2048)

    //! Compute the tangent of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its tangent \f$\tan(I_{(x,y,z,c)})\f$.
       \note
       - Pixel values are regarded as being exin \e radian.
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(tan,std::tan,2048)

    //! Compute the hyperbolic cosine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its hyperbolic cosine
       \f$\mathrm{cosh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(cosh,std::cosh,2048)

    //! Compute the hyperbolic sine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its hyperbolic sine
       \f$\mathrm{sinh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(sinh,std::sinh,2048)

    //! Compute the hyperbolic tangent of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its hyperbolic tangent
       \f$\mathrm{tanh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(tanh,std::tanh,2048)

    //! Compute the arccosine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its arccosine
       \f$\mathrm{acos}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(acos,std::acos,8192)

    //! Compute the arcsine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its arcsine
       \f$\mathrm{asin}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(asin,std::asin,8192)

    //! Compute the arctangent of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its arctangent
       \f$\mathrm{atan}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(atan,std::atan,8192)

    //! Compute the arctangent2 of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its arctangent2
       \f$\mathrm{atan2}(I_{(x,y,z,c)})\f$.
       \param img Image whose pixel values specify the second argument of the \c atan2() function.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
       \par Example
       \code
       const CImg&lt;float&gt;
          img_x(100,100,1,1,"x-w/2",false),   // Define an horizontal centered gradient, from '-width/2' to 'width/2'
          img_y(100,100,1,1,"y-h/2",false),   // Define a vertical centered gradient, from '-height/2' to 'height/2'
          img_atan2 = img_y.get_atan2(img_x); // Compute atan2(y,x) for each pixel value
       (img_x,img_y,img_atan2).display();
       \endcode
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; atan2(const CImg&lt;t&gt;&amp; img) ;

//! Compute the arctangent2 of each pixel value \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_atan2(const CImg&lt;t&gt;&amp; img) const ;

//! Compute the hyperbolic arccosine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its arccosineh
       \f$\mathrm{acosh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(acosh,cimg::acosh,8192)

    //! Compute the hyperbolic arcsine of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its hyperbolic arcsine
       \f$\mathrm{asinh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(asinh,cimg::asinh,8192)

    //! Compute the hyperbolic arctangent of each pixel value.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its hyperbolic arctangent
       \f$\mathrm{atanh}(I_{(x,y,z,c)})\f$.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
    **/
    _cimg_create_pointwise_functions(atanh,cimg::atanh,8192)

    //! In-place pointwise multiplication.
    /**
       Compute the pointwise multiplication between the image instance and the specified input image \c img.
       \param img Input image, as the second operand of the multiplication.
       \note
       - Similar to operator+=(const CImg&lt;t&gt;&amp;), except that it performs a pointwise multiplication
         instead of an addition.
       - It does \e not perform a \e matrix multiplication. For this purpose, use operator*=(const CImg&lt;t&gt;&amp;) instead.
       \par Example
       \code
       CImg&lt;float&gt;
         img("reference.jpg"),
         shade(img.width,img.height(),1,1,"-(x-w/2)^2-(y-h/2)^2",false);
       shade.normalize(0,1);
       (img,shade,img.get_mul(shade)).display();
       \endcode
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; mul(const CImg&lt;t&gt;&amp; img) ;

//! In-place pointwise multiplication \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_mul(const CImg&lt;t&gt;&amp; img) const ;

//! In-place pointwise division.
    /**
       Similar to mul(const CImg&lt;t&gt;&amp;), except that it performs a pointwise division instead of a multiplication.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; div(const CImg&lt;t&gt;&amp; img) ;

//! In-place pointwise division \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_div(const CImg&lt;t&gt;&amp; img) const ;

//! Raise each pixel value to a specified power.
    /**
       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its power \f$I_{(x,y,z,c)}^p\f$.
       \param p Exponent value.
       \note
       - The \inplace of this method statically casts the computed values to the pixel type \c T.
       - The \newinstance returns a \c CImg&lt;float&gt; image, if the pixel type \c T is \e not float-valued.
       \par Example
       \code
       const CImg&lt;float&gt;
         img0("reference.jpg"),           // Load reference color image
         img1 = (img0/255).pow(1.8)*=255, // Compute gamma correction, with gamma = 1.8
         img2 = (img0/255).pow(0.5)*=255; // Compute gamma correction, with gamma = 0.5
       (img0,img1,img2).display();
       \endcode
    **/
    CImg&lt;T&gt;&amp; pow(const double p) ;

//! Raise each pixel value to a specified power \newinstance.
    CImg&lt;Tfloat&gt; get_pow(const double p) const ;

//! Raise each pixel value to a power, specified from an expression.
    /**
       Similar to operator+=(const char*), except it performs a pointwise exponentiation instead of an addition.
    **/
    CImg&lt;T&gt;&amp; pow(const char *const expression) ;

//! Raise each pixel value to a power, specified from an expression \newinstance.
    CImg&lt;Tfloat&gt; get_pow(const char *const expression) const ;

//! Raise each pixel value to a power, pointwisely specified from another image.
    /**
       Similar to operator+=(const CImg&lt;t&gt;&amp; img), except that it performs an exponentiation instead of an addition.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; pow(const CImg&lt;t&gt;&amp; img) ;

//! Raise each pixel value to a power, pointwisely specified from another image \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_pow(const CImg&lt;t&gt;&amp; img) const ;

//! Compute the bitwise left rotation of each pixel value.
    /**
       Similar to operator&lt;&lt;=(unsigned int), except that it performs a left rotation instead of a left shift.
    **/
    CImg&lt;T&gt;&amp; rol(const unsigned int n=1) ;

//! Compute the bitwise left rotation of each pixel value \newinstance.
    CImg&lt;T&gt; get_rol(const unsigned int n=1) const ;

//! Compute the bitwise left rotation of each pixel value.
    /**
       Similar to operator&lt;&lt;=(const char*), except that it performs a left rotation instead of a left shift.
    **/
    CImg&lt;T&gt;&amp; rol(const char *const expression) ;

//! Compute the bitwise left rotation of each pixel value \newinstance.
    CImg&lt;T&gt; get_rol(const char *const expression) const ;

//! Compute the bitwise left rotation of each pixel value.
    /**
       Similar to operator&lt;&lt;=(const CImg&lt;t&gt;&amp;), except that it performs a left rotation instead of a left shift.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; rol(const CImg&lt;t&gt;&amp; img) ;

//! Compute the bitwise left rotation of each pixel value \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_rol(const CImg&lt;t&gt;&amp; img) const ;

//! Compute the bitwise right rotation of each pixel value.
    /**
       Similar to operator&gt;&gt;=(unsigned int), except that it performs a right rotation instead of a right shift.
    **/
    CImg&lt;T&gt;&amp; ror(const unsigned int n=1) ;

//! Compute the bitwise right rotation of each pixel value \newinstance.
    CImg&lt;T&gt; get_ror(const unsigned int n=1) const ;

//! Compute the bitwise right rotation of each pixel value.
    /**
       Similar to operator&gt;&gt;=(const char*), except that it performs a right rotation instead of a right shift.
    **/
    CImg&lt;T&gt;&amp; ror(const char *const expression) ;

//! Compute the bitwise right rotation of each pixel value \newinstance.
    CImg&lt;T&gt; get_ror(const char *const expression) const ;

//! Compute the bitwise right rotation of each pixel value.
    /**
       Similar to operator&gt;&gt;=(const CImg&lt;t&gt;&amp;), except that it performs a right rotation instead of a right shift.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; ror(const CImg&lt;t&gt;&amp; img) ;

//! Compute the bitwise right rotation of each pixel value \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_ror(const CImg&lt;t&gt;&amp; img) const ;

//! Pointwise min operator between instance image and a value.
    /**
       \param val Value used as the reference argument of the min operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{min}(I_{(x,y,z,c)},\mathrm{val})\f$.
     **/
    CImg&lt;T&gt;&amp; min(const T&amp; value) ;

//! Pointwise min operator between instance image and a value \newinstance.
    CImg&lt;T&gt; get_min(const T&amp; value) const ;

//! Pointwise min operator between two images.
    /**
       \param img Image used as the reference argument of the min operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{min}(I_{(x,y,z,c)},\mathrm{img}_{(x,y,z,c)})\f$.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; min(const CImg&lt;t&gt;&amp; img) ;

//! Pointwise min operator between two images \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_min(const CImg&lt;t&gt;&amp; img) const ;

//! Pointwise min operator between an image and an expression.
    /**
       \param expression Math formula as a C-string.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{min}(I_{(x,y,z,c)},\mathrm{expr}_{(x,y,z,c)})\f$.
    **/
    CImg&lt;T&gt;&amp; min(const char *const expression) ;

//! Pointwise min operator between an image and an expression \newinstance.
    CImg&lt;Tfloat&gt; get_min(const char *const expression) const ;

//! Pointwise max operator between instance image and a value.
    /**
       \param val Value used as the reference argument of the max operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{max}(I_{(x,y,z,c)},\mathrm{val})\f$.
     **/
    CImg&lt;T&gt;&amp; max(const T&amp; value) ;

//! Pointwise max operator between instance image and a value \newinstance.
    CImg&lt;T&gt; get_max(const T&amp; value) const ;

//! Pointwise max operator between two images.
    /**
       \param img Image used as the reference argument of the max operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{max}(I_{(x,y,z,c)},\mathrm{img}_{(x,y,z,c)})\f$.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; max(const CImg&lt;t&gt;&amp; img) ;

//! Pointwise max operator between two images \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_max(const CImg&lt;t&gt;&amp; img) const ;

//! Pointwise max operator between an image and an expression.
    /**
       \param expression Math formula as a C-string.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{max}(I_{(x,y,z,c)},\mathrm{expr}_{(x,y,z,c)})\f$.
    **/
    CImg&lt;T&gt;&amp; max(const char *const expression) ;

//! Pointwise max operator between an image and an expression \newinstance.
    CImg&lt;Tfloat&gt; get_max(const char *const expression) const ;

//! Pointwise minabs operator between instance image and a value.
    /**
       \param val Value used as the reference argument of the minabs operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{minabs}(I_{(x,y,z,c)},\mathrm{val})\f$.
     **/
    CImg&lt;T&gt;&amp; minabs(const T&amp; value) ;

//! Pointwise minabs operator between instance image and a value \newinstance.
    CImg&lt;T&gt; get_minabs(const T&amp; value) const ;

//! Pointwise minabs operator between two images.
    /**
       \param img Image used as the reference argument of the minabs operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{minabs}(I_{(x,y,z,c)},\mathrm{img}_{(x,y,z,c)})\f$.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; minabs(const CImg&lt;t&gt;&amp; img) ;

//! Pointwise minabs operator between two images \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_minabs(const CImg&lt;t&gt;&amp; img) const ;

//! Pointwise minabs operator between an image and an expression.
    /**
       \param expression Math formula as a C-string.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{minabs}(I_{(x,y,z,c)},\mathrm{expr}_{(x,y,z,c)})\f$.
    **/
    CImg&lt;T&gt;&amp; minabs(const char *const expression) ;

//! Pointwise minabs operator between an image and an expression \newinstance.
    CImg&lt;Tfloat&gt; get_minabs(const char *const expression) const ;

//! Pointwise maxabs operator between instance image and a value.
    /**
       \param val Value used as the reference argument of the maxabs operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{maxabs}(I_{(x,y,z,c)},\mathrm{val})\f$.
     **/
    CImg&lt;T&gt;&amp; maxabs(const T&amp; value) ;

//! Pointwise maxabs operator between instance image and a value \newinstance.
    CImg&lt;T&gt; get_maxabs(const T&amp; value) const ;

//! Pointwise maxabs operator between two images.
    /**
       \param img Image used as the reference argument of the maxabs operator.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{maxabs}(I_{(x,y,z,c)},\mathrm{img}_{(x,y,z,c)})\f$.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; maxabs(const CImg&lt;t&gt;&amp; img) ;

//! Pointwise maxabs operator between two images \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_maxabs(const CImg&lt;t&gt;&amp; img) const ;

//! Pointwise maxabs operator between an image and an expression.
    /**
       \param expression Math formula as a C-string.
       \note Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by
       \f$\mathrm{maxabs}(I_{(x,y,z,c)},\mathrm{expr}_{(x,y,z,c)})\f$.
    **/
    CImg&lt;T&gt;&amp; maxabs(const char *const expression) ;

//! Pointwise maxabs operator between an image and an expression \newinstance.
    CImg&lt;Tfloat&gt; get_maxabs(const char *const expression) const ;

//! Return a reference to the minimum pixel value.
    /**
     **/
    T&amp; min() ;

//! Return a reference to the minimum pixel value \const.
    const T&amp; min() const ;

//! Return a reference to the minimum pixel value in absolute value.
    /**
     **/
    T&amp; minabs() ;

//! Return a reference to the minimum pixel value in absolute value \const.
    const T&amp; minabs() const ;

//! Return a reference to the maximum pixel value.
    /**
     **/
    T&amp; max() ;

//! Return a reference to the maximum pixel value \const.
    const T&amp; max() const ;

//! Return a reference to the maximum pixel value in absolute value.
    /**
     **/
    T&amp; maxabs() ;

//! Return a reference to the maximum pixel value in absolute value \const.
    const T&amp; maxabs() const ;

//! Return a reference to the minimum pixel value as well as the maximum pixel value.
    /**
       \param[out] max_val Maximum pixel value.
    **/
    template&lt;typename t&gt;
    T&amp; min_max(t&amp; max_val) ;

//! Return a reference to the minimum pixel value as well as the maximum pixel value \const.
    template&lt;typename t&gt;
    const T&amp; min_max(t&amp; max_val) const ;

//! Return a reference to the maximum pixel value as well as the minimum pixel value.
    /**
       \param[out] min_val Minimum pixel value.
    **/
    template&lt;typename t&gt;
    T&amp; max_min(t&amp; min_val) ;

//! Return a reference to the maximum pixel value as well as the minimum pixel value \const.
    template&lt;typename t&gt;
    const T&amp; max_min(t&amp; min_val) const ;

//! Return the kth smallest pixel value.
    /**
       \param k Rank of the smallest element searched.
    **/
    T kth_smallest(const ulongT k) const ;

//! Return the median pixel value.
    /**
     **/
    T median() const ;

//! Return the product of all the pixel values.
    /**
     **/
    double product() const ;

//! Return the sum of all the pixel values.
    /**
     **/
    double sum() const ;

//! Return the average pixel value.
    /**
     **/
    double mean() const ;

//! Return the variance of the pixel values.
    /**
       \param variance_method Method used to estimate the variance. Can be:
       - \c 0: Second moment, computed as
       \f$1/N \sum\limits_{k=1}^{N} (x_k - \bar x)^2 =
       1/N \left( \sum\limits_{k=1}^N x_k^2 - \left( \sum\limits_{k=1}^N x_k \right)^2 / N \right)\f$
       with \f$ \bar x = 1/N \sum\limits_{k=1}^N x_k \f$.
       - \c 1: Best unbiased estimator, computed as \f$\frac{1}{N - 1} \sum\limits_{k=1}^{N} (x_k - \bar x)^2 \f$.
       - \c 2: Least median of squares.
       - \c 3: Least trimmed of squares.
    **/
    double variance(const unsigned int variance_method=1) const ;

//! Return the variance as well as the average of the pixel values.
    /**
       \param variance_method Method used to estimate the variance (see variance(const unsigned int) const).
       \param[out] mean Average pixel value.
    **/
    template&lt;typename t&gt;
    double variance_mean(const unsigned int variance_method, t&amp; mean) const ;

//! Return estimated variance of the noise.
    /**
       \param variance_method Method used to compute the variance (see variance(const unsigned int) const).
       \note Because of structures such as edges in images it is
       recommended to use a robust variance estimation. The variance of the
       noise is estimated by computing the variance of the Laplacian \f$(\Delta
       I)^2 \f$ scaled by a factor \f$c\f$ insuring \f$ c E[(\Delta I)^2]=
       \sigma^2\f$ where \f$\sigma\f$ is the noise variance.
    **/
    double variance_noise(const unsigned int variance_method=2) const ;

//! Compute the MSE (Mean-Squared Error) between two images.
    /**
       \param img Image used as the second argument of the MSE operator.
    **/
    template&lt;typename t&gt;
    double MSE(const CImg&lt;t&gt;&amp; img) const ;

//! Compute the PSNR (Peak Signal-to-Noise Ratio) between two images.
    /**
       \param img Image used as the second argument of the PSNR operator.
       \param max_value Maximum theoretical value of the signal.
     **/
    template&lt;typename t&gt;
    double PSNR(const CImg&lt;t&gt;&amp; img, const double max_value=255) const ;

//! Evaluate math formula.
    /**
       \param expression Math formula, as a C-string.
       \param x Value of the pre-defined variable \c x.
       \param y Value of the pre-defined variable \c y.
       \param z Value of the pre-defined variable \c z.
       \param c Value of the pre-defined variable \c c.
       \param list_inputs A list of input images attached to the specified math formula.
       \param[out] list_outputs A pointer to a list of output images attached to the specified math formula.
    **/
    double eval(const char *const expression,
                const double x=0, const double y=0, const double z=0, const double c=0,
                const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) ;

//! Evaluate math formula \const.
    double eval(const char *const expression,
                const double x=0, const double y=0, const double z=0, const double c=0,
                const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) const ;

//! Evaluate math formula.
    /**
       \param[out] output Contains values of output vector returned by the evaluated expression
         (or is empty if the returned type is scalar).
       \param expression Math formula, as a C-string.
       \param x Value of the pre-defined variable \c x.
       \param y Value of the pre-defined variable \c y.
       \param z Value of the pre-defined variable \c z.
       \param c Value of the pre-defined variable \c c.
       \param list_inputs A list of input images attached to the specified math formula.
       \param[out] list_outputs A pointer to a list of output images attached to the specified math formula.
    **/
    template&lt;typename t&gt;
    void eval(CImg&lt;t&gt; &amp;output, const char *const expression,
              const double x=0, const double y=0, const double z=0, const double c=0,
              const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) ;

//! Evaluate math formula \const.
    template&lt;typename t&gt;
    void eval(CImg&lt;t&gt;&amp; output, const char *const expression,
              const double x=0, const double y=0, const double z=0, const double c=0,
              const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) const ;

//! Evaluate math formula on a set of variables.
    /**
       \param expression Math formula, as a C-string.
       \param xyzc Set of values (x,y,z,c) used for the evaluation.
       \param list_inputs A list of input images attached to the specified math formula.
       \param[out] list_outputs A pointer to a list of output images attached to the specified math formula.
    **/
    template&lt;typename t&gt;
    CImg&lt;doubleT&gt; eval(const char *const expression, const CImg&lt;t&gt;&amp; xyzc,
                       const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) ;

//! Evaluate math formula on a set of variables \const.
    template&lt;typename t&gt;
    CImg&lt;doubleT&gt; eval(const char *const expression, const CImg&lt;t&gt;&amp; xyzc,
                       const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) const ;

//! Compute statistics vector from the pixel values.
    /**
       \param variance_method Method used to compute the variance (see variance(const unsigned int) const).
       \return Statistics vector as
         &lt;tt&gt;[min, max, mean, variance, xmin, ymin, zmin, cmin, xmax, ymax, zmax, cmax, sum, product]&lt;/tt&gt;.
    **/
    CImg&lt;Tdouble&gt; get_stats(const unsigned int variance_method=1) const ;

//! Compute statistics vector from the pixel values \inplace.
    CImg&lt;T&gt;&amp; stats(const unsigned int variance_method=1) ;

//! \name Vector / Matrix Operations
    //@;

//! Compute norm of the image, viewed as a matrix.
    /**
       \param magnitude_type Norm type. Can be:
       - \c -1: Linf-norm
       - \c 0: L0-norm
       - \c 1: L1-norm
       - \c 2: L2-norm
    **/
    double magnitude(const int magnitude_type=2) const ;

//! Compute the trace of the image, viewed as a matrix.
    /**
     **/
    double trace() const ;

//! Compute the determinant of the image, viewed as a matrix.
    /**
     **/
    double det() const ;

//! Compute the dot product between instance and argument, viewed as matrices.
    /**
       \param img Image used as a second argument of the dot product.
    **/
    template&lt;typename t&gt;
    double dot(const CImg&lt;t&gt;&amp; img) const ;

//! Get vector-valued pixel located at specified position.
    /**
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
    **/
    CImg&lt;T&gt; get_vector_at(const unsigned int x, const unsigned int y=0, const unsigned int z=0) const ;

//! Get (square) matrix-valued pixel located at specified position.
    /**
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \note - The spectrum() of the image must be a square.
     **/
    CImg&lt;T&gt; get_matrix_at(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) const ;

//! Get tensor-valued pixel located at specified position.
    /**
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
    **/
    CImg&lt;T&gt; get_tensor_at(const unsigned int x, const unsigned int y=0, const unsigned int z=0) const ;

//! Set vector-valued pixel at specified position.
    /**
       \param vec Vector to put on the instance image.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; set_vector_at(const CImg&lt;t&gt;&amp; vec, const unsigned int x, const unsigned int y=0, const unsigned int z=0) ;

//! Set (square) matrix-valued pixel at specified position.
    /**
       \param mat Matrix to put on the instance image.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; set_matrix_at(const CImg&lt;t&gt;&amp; mat, const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) ;

//! Set tensor-valued pixel at specified position.
    /**
       \param ten Tensor to put on the instance image.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; set_tensor_at(const CImg&lt;t&gt;&amp; ten, const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) ;

//! Resize image to become a diagonal matrix.
    /**
       \note Transform the image as a diagonal matrix so that each of its initial value becomes a diagonal coefficient.
    **/
    CImg&lt;T&gt;&amp; diagonal() ;

//! Resize image to become a diagonal matrix \newinstance.
    CImg&lt;T&gt; get_diagonal() const ;

//! Replace the image by an identity matrix.
    /**
       \note If the instance image is not square, it is resized to a square matrix using its maximum
       dimension as a reference.
    **/
    CImg&lt;T&gt;&amp; identity_matrix() ;

//! Replace the image by an identity matrix \newinstance.
    CImg&lt;T&gt; get_identity_matrix() const ;

//! Fill image with a linear sequence of values.
    /**
       \param a0 Starting value of the sequence.
       \param a1 Ending value of the sequence.
    **/
    CImg&lt;T&gt;&amp; sequence(const T&amp; a0, const T&amp; a1) ;

//! Fill image with a linear sequence of values \newinstance.
    CImg&lt;T&gt; get_sequence(const T&amp; a0, const T&amp; a1) const ;

//! Transpose the image, viewed as a matrix.
    /**
       \note Equivalent to \code permute_axes("yxzc"); \endcode.
    **/
    CImg&lt;T&gt;&amp; transpose() ;

//! Transpose the image, viewed as a matrix \newinstance.
    CImg&lt;T&gt; get_transpose() const ;

//! Compute the cross product between two \c 1x3 images, viewed as 3D vectors.
    /**
       \param img Image used as the second argument of the cross product.
       \note The first argument of the cross product is \c *this.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; cross(const CImg&lt;t&gt;&amp; img) ;

//! Compute the cross product between two \c 1x3 images, viewed as 3D vectors \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_cross(const CImg&lt;t&gt;&amp; img) const ;

//! Invert the instance image, viewed as a matrix.
    /**
       \param use_LU Choose the inverting algorithm. Can be:
       - \c true: LU-based matrix inversion.
       - \c false: SVD-based matrix inversion.
    **/
    CImg&lt;T&gt;&amp; invert(const bool use_LU=true) ;

//! Invert the instance image, viewed as a matrix \newinstance.
    CImg&lt;Tfloat&gt; get_invert(const bool use_LU=true) const ;

//! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix.
    /**
    **/
    CImg&lt;T&gt;&amp; pseudoinvert(const bool use_LU=false) ;

//! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix \newinstance.
    CImg&lt;Tfloat&gt; get_pseudoinvert(const bool use_LU=false) const ;

//! Solve a system of linear equations.
    /**
       \param A Matrix of the linear system.
       \param use_LU In case of non square system (least-square solution),
                     choose between SVD-based (\c false) or LU-based (\c true) method.
                     LU method is faster for large matrices, but numerically less stable.
       \note Solve \c AX = B where \c B=*this.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; solve(const CImg&lt;t&gt;&amp; A, const bool use_LU=false) ;

//! Solve a system of linear equations \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Ttfloat&gt; get_solve(const CImg&lt;t&gt;&amp; A, const bool use_LU=false) const ;

//! Solve a tridiagonal system of linear equations.
    /**
       \param A Coefficients of the tridiagonal system.
       A is a tridiagonal matrix A = [ b0,c0,0,...; a1,b1,c1,0,... ; ... ; ...,0,aN,bN ],
       stored as a 3 columns matrix
       \note Solve AX=B where \c B=*this, using the Thomas algorithm.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; solve_tridiagonal(const CImg&lt;t&gt;&amp; A) ;

//! Solve a tridiagonal system of linear equations \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Ttfloat&gt; get_solve_tridiagonal(const CImg&lt;t&gt;&amp; A) const ;

//! Compute eigenvalues and eigenvectors of the instance image, viewed as a matrix.
    /**
       \param[out] val Vector of the estimated eigenvalues, in decreasing order.
       \param[out] vec Matrix of the estimated eigenvectors, sorted by columns.
    **/
    template&lt;typename t&gt;
    const CImg&lt;T&gt;&amp; eigen(CImg&lt;t&gt;&amp; val, CImg&lt;t&gt; &amp;vec) const ;

//! Compute eigenvalues and eigenvectors of the instance image, viewed as a matrix.
    /**
       \return A list of two images &lt;tt&gt;[val; vec]&lt;/tt&gt;, whose meaning is similar as in eigen(CImg&lt;t&gt;&amp;,CImg&lt;t&gt;&amp;) const.
    **/
    CImgList&lt;Tfloat&gt; get_eigen() const ;

//! Compute eigenvalues and eigenvectors of the instance image, viewed as a symmetric matrix.
    /**
       \param[out] val Vector of the estimated eigenvalues, in decreasing order.
       \param[out] vec Matrix of the estimated eigenvectors, sorted by columns.
    **/
    template&lt;typename t&gt;
    const CImg&lt;T&gt;&amp; symmetric_eigen(CImg&lt;t&gt;&amp; val, CImg&lt;t&gt;&amp; vec) const ;

//! Compute eigenvalues and eigenvectors of the instance image, viewed as a symmetric matrix.
    /**
       \return A list of two images &lt;tt&gt;[val; vec]&lt;/tt&gt;, whose meaning are similar as in
         symmetric_eigen(CImg&lt;t&gt;&amp;,CImg&lt;t&gt;&amp;) const.
    **/
    CImgList&lt;Tfloat&gt; get_symmetric_eigen() const ;

//! Sort pixel values and get sorting permutations.
    /**
       \param[out] permutations Permutation map used for the sorting.
       \param is_increasing Tells if pixel values are sorted in an increasing (\c true) or decreasing (\c false) way.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; sort(CImg&lt;t&gt;&amp; permutations, const bool is_increasing=true) ;

//! Sort pixel values and get sorting permutations \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_sort(CImg&lt;t&gt;&amp; permutations, const bool is_increasing=true) const ;

//! Sort pixel values.
    /**
       \param is_increasing Tells if pixel values are sorted in an increasing (\c true) or decreasing (\c false) way.
       \param axis Tells if the value sorting must be done along a specific axis. Can be:
       - \c 0: All pixel values are sorted, independently on their initial position.
       - \c 'x': Image columns are sorted, according to the first value in each column.
       - \c 'y': Image rows are sorted, according to the first value in each row.
       - \c 'z': Image slices are sorted, according to the first value in each slice.
       - \c 'c': Image channels are sorted, according to the first value in each channel.
    **/
    CImg&lt;T&gt;&amp; sort(const bool is_increasing=true, const char axis=0) ;

//! Sort pixel values \newinstance.
    CImg&lt;T&gt; get_sort(const bool is_increasing=true, const char axis=0) const ;

//! Compute the SVD of the instance image, viewed as a general matrix.
    /**
       Compute the SVD decomposition \c *this=U*S*V' where \c U and \c V are orthogonal matrices
       and \c S is a diagonal matrix. \c V' denotes the matrix transpose of \c V.
       \param[out] U First matrix of the SVD product.
       \param[out] S Coefficients of the second (diagonal) matrix of the SVD product.
         These coefficients are stored as a vector.
       \param[out] V Third matrix of the SVD product.
       \param sorting Tells if the diagonal coefficients are sorted (in decreasing order).
       \param max_iteration Maximum number of iterations considered for the algorithm convergence.
       \param lambda Epsilon used for the algorithm convergence.
       \note The instance matrix can be computed from \c U,\c S and \c V by
       \code
       const CImg&lt;&gt; A;  // Input matrix (assumed to contain some values)
       CImg&lt;&gt; U,S,V;
       A.SVD(U,S,V)
       \endcode
    **/
    template&lt;typename t&gt;
    const CImg&lt;T&gt;&amp; SVD(CImg&lt;t&gt;&amp; U, CImg&lt;t&gt;&amp; S, CImg&lt;t&gt;&amp; V, const bool sorting=true,
                       const unsigned int max_iteration=40, const float lambda=0) const ;

//! Compute the SVD of the instance image, viewed as a general matrix.
    /**
       \return A list of three images &lt;tt&gt;[U; S; V]&lt;/tt&gt;, whose meaning is similar as in
         SVD(CImg&lt;t&gt;&amp;,CImg&lt;t&gt;&amp;,CImg&lt;t&gt;&amp;,bool,unsigned int,float) const.
    **/
    CImgList&lt;Tfloat&gt; get_SVD(const bool sorting=true,
                             const unsigned int max_iteration=40, const float lambda=0) const ;

//! Compute the projection of the instance matrix onto the specified dictionary.
    /**
       Find the best matching projection of selected matrix onto the span of an over-complete dictionary D,
       using the orthogonal projection or (opt. Orthogonal) Matching Pursuit algorithm.
       Instance image must a 2D-matrix in which each column represent a signal to project.
       \param dictionary A matrix in which each column is an element of the dictionary D.
       \param method Tell what projection method is applied. It can be:
         - 0 = orthogonal projection (default).
         - 1 = matching pursuit.
         - 2 = matching pursuit, with a single orthogonal projection step at the end.
         - &gt;=3 = orthogonal matching pursuit where an orthogonal projection step is performed
                 every 'method-2' iterations.
       \param max_iter Sets the max number of iterations processed for each signal.
                       If set to '0' (default), 'max_iter' is set to the number of dictionary columns.
                       (only meaningful for matching pursuit and its variants).
       \param max_residual Gives a stopping criterion on signal reconstruction accuracy.
                           (only meaningful for matching pursuit and its variants).
       \return A matrix W whose columns correspond to the sparse weights of associated to each input matrix column.
               Thus, the matrix product D*W is an approximation of the input matrix.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; project_matrix(const CImg&lt;t&gt;&amp; dictionary, const unsigned int method=0,
                            const unsigned int max_iter=0, const double max_residual=1e-6) ;

//! Compute minimal path in a graph, using the Dijkstra algorithm.
    /**
       \param distance An object having operator()(unsigned int i, unsigned int j) which returns distance
         between two nodes (i,j).
       \param nb_nodes Number of graph nodes.
       \param starting_node Index of the starting node.
       \param ending_node Index of the ending node (set to ~0U to ignore ending node).
       \param previous_node Array that gives the previous node index in the path to the starting node
         (optional parameter).
       \return Array of distances of each node to the starting node.
    **/
    template&lt;typename tf, typename t&gt;
    static CImg&lt;T&gt; dijkstra(const tf&amp; distance, const unsigned int nb_nodes,
                            const unsigned int starting_node, const unsigned int ending_node,
                            CImg&lt;t&gt;&amp; previous_node) ;

//! Return minimal path in a graph, using the Dijkstra algorithm.
    template&lt;typename tf, typename t&gt;
    static CImg&lt;T&gt; dijkstra(const tf&amp; distance, const unsigned int nb_nodes,
                            const unsigned int starting_node, const unsigned int ending_node=~0U) ;

//! Return minimal path in a graph, using the Dijkstra algorithm.
    /**
       \param starting_node Index of the starting node.
       \param ending_node Index of the ending node.
       \param previous_node Array that gives the previous node index in the path to the starting node
         (optional parameter).
       \return Array of distances of each node to the starting node.
       \note image instance corresponds to the adjacency matrix of the graph.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; dijkstra(const unsigned int starting_node, const unsigned int ending_node,
                      CImg&lt;t&gt;&amp; previous_node) ;

//! Return minimal path in a graph, using the Dijkstra algorithm \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_dijkstra(const unsigned int starting_node, const unsigned int ending_node,
                         CImg&lt;t&gt;&amp; previous_node) const ;

//! Return minimal path in a graph, using the Dijkstra algorithm.
    CImg&lt;T&gt;&amp; dijkstra(const unsigned int starting_node, const unsigned int ending_node=~0U) ;

//! Return minimal path in a graph, using the Dijkstra algorithm \newinstance.
    CImg&lt;Tfloat&gt; get_dijkstra(const unsigned int starting_node, const unsigned int ending_node=~0U) const ;

//! Return an image containing the character codes of specified string.
    /**
       \param str input C-string to encode as an image.
       \param is_last_zero Tells if the ending \c '0' character appear in the resulting image.
       \param is_shared Return result that shares its buffer with \p str.
    **/
    static CImg&lt;T&gt; string(const char *const str, const bool is_last_zero=true, const bool is_shared=false) ;

//! Return a \c 1x1 image containing specified value.
    /**
       \param a0 First vector value.
    **/
    static CImg&lt;T&gt; row_vector(const T&amp; a0) ;

//! Return a \c 2x1 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
    **/
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1) ;

//! Return a \c 3x1 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
       \param a2 Third vector value.
    **/
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2) ;

//! Return a \c 4x1 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
       \param a2 Third vector value.
       \param a3 Fourth vector value.
    **/
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3) ;

//! Return a \c 5x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4) ;

//! Return a \c 6x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4, const T&amp; a5) ;

//! Return a \c 7x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6) ;

//! Return a \c 8x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7) ;

//! Return a \c 9x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8) ;

//! Return a \c 10x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9) ;

//! Return a \c 11x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10) ;

//! Return a \c 12x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11) ;

//! Return a \c 13x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                              const T&amp; a12) ;

//! Return a \c 14x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                              const T&amp; a12, const T&amp; a13) ;

//! Return a \c 15x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                              const T&amp; a12, const T&amp; a13, const T&amp; a14) ;

//! Return a \c 16x1 image containing specified values.
    static CImg&lt;T&gt; row_vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                              const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                              const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                              const T&amp; a12, const T&amp; a13, const T&amp; a14, const T&amp; a15) ;

//! Return a \c 1x1 image containing specified value.
    /**
       \param a0 First vector value.
    **/
    static CImg&lt;T&gt; vector(const T&amp; a0) ;

//! Return a \c 1x2 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
    **/
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1) ;

//! Return a \c 1x3 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
       \param a2 Third vector value.
    **/
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2) ;

//! Return a \c 1x4 image containing specified values.
    /**
       \param a0 First vector value.
       \param a1 Second vector value.
       \param a2 Third vector value.
       \param a3 Fourth vector value.
    **/
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3) ;

//! Return a \c 1x5 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4) ;

//! Return a \c 1x6 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4, const T&amp; a5) ;

//! Return a \c 1x7 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6) ;

//! Return a \c 1x8 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7) ;

//! Return a \c 1x9 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8) ;

//! Return a \c 1x10 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9) ;

//! Return a \c 1x11 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10) ;

//! Return a \c 1x12 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11) ;

//! Return a \c 1x13 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                          const T&amp; a12) ;

//! Return a \c 1x14 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                          const T&amp; a12, const T&amp; a13) ;

//! Return a \c 1x15 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                          const T&amp; a12, const T&amp; a13, const T&amp; a14) ;

//! Return a \c 1x16 image containing specified values.
    static CImg&lt;T&gt; vector(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                          const T&amp; a12, const T&amp; a13, const T&amp; a14, const T&amp; a15) ;

//! Return a 1x1 matrix containing specified coefficients.
    /**
       \param a0 First matrix value.
       \note Equivalent to vector(const T&amp;).
    **/
    static CImg&lt;T&gt; matrix(const T&amp; a0) ;

//! Return a 2x2 matrix containing specified coefficients.
    /**
       \param a0 First matrix value.
       \param a1 Second matrix value.
       \param a2 Third matrix value.
       \param a3 Fourth matrix value.
    **/
    static CImg&lt;T&gt; matrix(const T&amp; a0, const T&amp; a1,
                          const T&amp; a2, const T&amp; a3) ;

//! Return a 3x3 matrix containing specified coefficients.
    /**
       \param a0 First matrix value.
       \param a1 Second matrix value.
       \param a2 Third matrix value.
       \param a3 Fourth matrix value.
       \param a4 Fifth matrix value.
       \param a5 Sixth matrix value.
       \param a6 Seventh matrix value.
       \param a7 Eighth matrix value.
       \param a8 Ninth matrix value.
    **/
    static CImg&lt;T&gt; matrix(const T&amp; a0, const T&amp; a1, const T&amp; a2,
                          const T&amp; a3, const T&amp; a4, const T&amp; a5,
                          const T&amp; a6, const T&amp; a7, const T&amp; a8) ;

//! Return a 4x4 matrix containing specified coefficients.
    static CImg&lt;T&gt; matrix(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3,
                          const T&amp; a4, const T&amp; a5, const T&amp; a6, const T&amp; a7,
                          const T&amp; a8, const T&amp; a9, const T&amp; a10, const T&amp; a11,
                          const T&amp; a12, const T&amp; a13, const T&amp; a14, const T&amp; a15) ;

//! Return a 5x5 matrix containing specified coefficients.
    static CImg&lt;T&gt; matrix(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4,
                          const T&amp; a5, const T&amp; a6, const T&amp; a7, const T&amp; a8, const T&amp; a9,
                          const T&amp; a10, const T&amp; a11, const T&amp; a12, const T&amp; a13, const T&amp; a14,
                          const T&amp; a15, const T&amp; a16, const T&amp; a17, const T&amp; a18, const T&amp; a19,
                          const T&amp; a20, const T&amp; a21, const T&amp; a22, const T&amp; a23, const T&amp; a24) ;

//! Return a 1x1 symmetric matrix containing specified coefficients.
    /**
       \param a0 First matrix value.
       \note Equivalent to vector(const T&amp;).
    **/
    static CImg&lt;T&gt; tensor(const T&amp; a0) ;

//! Return a 2x2 symmetric matrix tensor containing specified coefficients.
    static CImg&lt;T&gt; tensor(const T&amp; a0, const T&amp; a1, const T&amp; a2) ;

//! Return a 3x3 symmetric matrix containing specified coefficients.
    static CImg&lt;T&gt; tensor(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4, const T&amp; a5) ;

//! Return a 1x1 diagonal matrix containing specified coefficients.
    static CImg&lt;T&gt; diagonal(const T&amp; a0) ;

//! Return a 2x2 diagonal matrix containing specified coefficients.
    static CImg&lt;T&gt; diagonal(const T&amp; a0, const T&amp; a1) ;

//! Return a 3x3 diagonal matrix containing specified coefficients.
    static CImg&lt;T&gt; diagonal(const T&amp; a0, const T&amp; a1, const T&amp; a2) ;

//! Return a 4x4 diagonal matrix containing specified coefficients.
    static CImg&lt;T&gt; diagonal(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3) ;

//! Return a 5x5 diagonal matrix containing specified coefficients.
    static CImg&lt;T&gt; diagonal(const T&amp; a0, const T&amp; a1, const T&amp; a2, const T&amp; a3, const T&amp; a4) ;

//! Return a NxN identity matrix.
    /**
       \param N Dimension of the matrix.
    **/
    static CImg&lt;T&gt; identity_matrix(const unsigned int N) ;

//! Return a N-numbered sequence vector from \p a0 to \p a1.
    /**
       \param N Size of the resulting vector.
       \param a0 Starting value of the sequence.
       \param a1 Ending value of the sequence.
     **/
    static CImg&lt;T&gt; sequence(const unsigned int N, const T&amp; a0, const T&amp; a1) ;

//! Return a 3x3 rotation matrix from an ;

//! \name Value Manipulation
    //@;

//! Fill all pixel values with specified value.
    /**
       \param val Fill value.
    **/
    CImg&lt;T&gt;&amp; fill(const T&amp; val) ;

//! Fill all pixel values with specified value \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val) const ;

//! Fill sequentially all pixel values with specified values.
    /**
       \param val0 First fill value.
       \param val1 Second fill value.
    **/
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                  const T&amp; val12) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                     const T&amp; val12) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                  const T&amp; val12, const T&amp; val13) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                     const T&amp; val12, const T&amp; val13) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                  const T&amp; val12, const T&amp; val13, const T&amp; val14) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                     const T&amp; val12, const T&amp; val13, const T&amp; val14) const ;

//! Fill sequentially all pixel values with specified values \overloading.
    CImg&lt;T&gt;&amp; fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                  const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                  const T&amp; val12, const T&amp; val13, const T&amp; val14, const T&amp; val15) ;

//! Fill sequentially all pixel values with specified values \newinstance.
    CImg&lt;T&gt; get_fill(const T&amp; val0, const T&amp; val1, const T&amp; val2, const T&amp; val3, const T&amp; val4, const T&amp; val5,
                     const T&amp; val6, const T&amp; val7, const T&amp; val8, const T&amp; val9, const T&amp; val10, const T&amp; val11,
                     const T&amp; val12, const T&amp; val13, const T&amp; val14, const T&amp; val15) const ;

//! Fill sequentially pixel values according to a given expression.
    /**
       \param expression C-string describing a math formula, or a sequence of values.
       \param repeat_values In case a list of values is provided, tells if this list must be repeated for the filling.
       \param allow_formula Tells that mathematical formulas are authorized for the filling.
       \param list_inputs In case of a mathematical expression, attach a list of images to the specified expression.
       \param[out] list_outputs In case of a math expression, list of images atatched to the specified expression.
    **/
    CImg&lt;T&gt;&amp; fill(const char *const expression, const bool repeat_values, const bool allow_formula=true,
                  const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) ;

//! Fill sequentially pixel values according to a given expression \newinstance.
    CImg&lt;T&gt; get_fill(const char *const expression, const bool repeat_values, const bool allow_formula=true,
                     const CImgList&lt;T&gt; *const list_inputs=0, CImgList&lt;T&gt; *const list_outputs=0) const ;

//! Fill sequentially pixel values according to the values found in another image.
    /**
       \param values Image containing the values used for the filling.
       \param repeat_values In case there are less values than necessary in \c values, tells if these values must be
         repeated for the filling.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; fill(const CImg&lt;t&gt;&amp; values, const bool repeat_values=true) ;

//! Fill sequentially pixel values according to the values found in another image \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_fill(const CImg&lt;t&gt;&amp; values, const bool repeat_values=true) const ;

//! Fill pixel values along the X-axis at a specified pixel position.
    /**
       \param y Y-coordinate of the filled column.
       \param z Z-coordinate of the filled column.
       \param c C-coordinate of the filled column.
       \param a0 First fill value.
    **/
    CImg&lt;T&gt;&amp; fillX(const unsigned int y, const unsigned int z, const unsigned int c, const int a0, ...) ;

//! Fill pixel values along the X-axis at a specified pixel position \overloading.
    CImg&lt;T&gt;&amp; fillX(const unsigned int y, const unsigned int z, const unsigned int c, const double a0, ...) ;

//! Fill pixel values along the Y-axis at a specified pixel position.
    /**
       \param x X-coordinate of the filled row.
       \param z Z-coordinate of the filled row.
       \param c C-coordinate of the filled row.
       \param a0 First fill value.
    **/
    CImg&lt;T&gt;&amp; fillY(const unsigned int x, const unsigned int z, const unsigned int c, const int a0, ...) ;

//! Fill pixel values along the Y-axis at a specified pixel position \overloading.
    CImg&lt;T&gt;&amp; fillY(const unsigned int x, const unsigned int z, const unsigned int c, const double a0, ...) ;

//! Fill pixel values along the Z-axis at a specified pixel position.
    /**
       \param x X-coordinate of the filled slice.
       \param y Y-coordinate of the filled slice.
       \param c C-coordinate of the filled slice.
       \param a0 First fill value.
    **/
    CImg&lt;T&gt;&amp; fillZ(const unsigned int x, const unsigned int y, const unsigned int c, const int a0, ...) ;

//! Fill pixel values along the Z-axis at a specified pixel position \overloading.
    CImg&lt;T&gt;&amp; fillZ(const unsigned int x, const unsigned int y, const unsigned int c, const double a0, ...) ;

//! Fill pixel values along the C-axis at a specified pixel position.
    /**
       \param x X-coordinate of the filled channel.
       \param y Y-coordinate of the filled channel.
       \param z Z-coordinate of the filled channel.
       \param a0 First filling value.
    **/
    CImg&lt;T&gt;&amp; fillC(const unsigned int x, const unsigned int y, const unsigned int z, const int a0, ...) ;

//! Fill pixel values along the C-axis at a specified pixel position \overloading.
    CImg&lt;T&gt;&amp; fillC(const unsigned int x, const unsigned int y, const unsigned int z, const double a0, ...) ;

//! Discard specified sequence of values in the image buffer, along a specific axis.
    /**
       \param values Sequence of values to discard.
       \param axis Axis along which the values are discarded. If set to \c 0 (default value)
         the method does it for all the buffer values and returns a one-column vector.
       \note Discarded values will change the image geometry, so the resulting image
         is returned as a one-column vector.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; discard(const CImg&lt;t&gt;&amp; values, const char axis=0) ;

//! Discard neighboring duplicates in the image buffer, along the specified axis.
    CImg&lt;T&gt;&amp; discard(const char axis=0) ;

//! Discard neighboring duplicates in the image buffer, along the specified axis \newinstance.
    CImg&lt;T&gt; get_discard(const char axis=0) const ;

//! Invert endianness of all pixel values.
    /**
     **/
    CImg&lt;T&gt;&amp; invert_endianness() ;

//! Invert endianness of all pixel values \newinstance.
    CImg&lt;T&gt; get_invert_endianness() const ;

//! Fill image with random values in specified range.
    /**
       \param val_min Minimal authorized random value.
       \param val_max Maximal authorized random value.
       \note Random variables are uniformly distributed in [val_min,val_max].
     **/
    CImg&lt;T&gt;&amp; rand(const T&amp; val_min, const T&amp; val_max) ;

//! Fill image with random values in specified range \newinstance.
    CImg&lt;T&gt; get_rand(const T&amp; val_min, const T&amp; val_max) const ;

//! Round pixel values.
    /**
       \param y Rounding precision.
       \param rounding_type Rounding type. Can be:
       - \c -1: Backward.
       - \c 0: Nearest.
       - \c 1: Forward.
    **/
    CImg&lt;T&gt;&amp; round(const double y=1, const int rounding_type=0) ;

//! Round pixel values \newinstance.
    CImg&lt;T&gt; get_round(const double y=1, const unsigned int rounding_type=0) const ;

//! Add random noise to pixel values.
    /**
       \param sigma Amplitude of the random additive noise. If \p sigma&lt;0, it stands for a percentage of the
         global value range.
       \param noise_type Type of additive noise (can be \p 0=gaussian, \p 1=uniform, \p 2=Salt and Pepper,
         \p 3=Poisson or \p 4=Rician).
       \return A reference to the modified image instance.
       \note
       - For Poisson noise (\p noise_type=3), parameter \p sigma is ignored, as Poisson noise only depends on
         the image value itself.
       - Function \p CImg&lt;T&gt;::get_noise() is also defined. It returns a non-shared modified copy of the image instance.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_noise(40);
       (img,res.normalize(0,255)).display();
       \endcode
       \image html ref_noise.jpg
    **/
    CImg&lt;T&gt;&amp; noise(const double sigma, const unsigned int noise_type=0) ;

//! Add random noise to pixel values \newinstance.
    CImg&lt;T&gt; get_noise(const double sigma, const unsigned int noise_type=0) const ;

//! Linearly normalize pixel values.
    /**
       \param min_value Minimum desired value of the resulting image.
       \param max_value Maximum desired value of the resulting image.
       \param constant_case_ratio In case of instance image having a constant value, tell what ratio
              of [min_value,max_value] is used to fill the normalized image
              (=0 for min_value, =1 for max_value, =0.5 for (min_value + max_value)/2).
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_normalize(160,220);
       (img,res).display();
       \endcode
       \image html ref_normalize2.jpg
    **/
    CImg&lt;T&gt;&amp; normalize(const T&amp; min_value, const T&amp; max_value,
                       const float constant_case_ratio=0) ;

//! Linearly normalize pixel values \newinstance.
    CImg&lt;Tfloat&gt; get_normalize(const T&amp; min_value, const T&amp; max_value,
                               const float ratio_if_constant_image=0) const ;

//! Normalize multi-valued pixels of the image instance, with respect to their L2-norm.
    /**
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_normalize();
       (img,res.normalize(0,255)).display();
       \endcode
       \image html ref_normalize.jpg
    **/
    CImg&lt;T&gt;&amp; normalize() ;

//! Normalize multi-valued pixels of the image instance, with respect to their L2-norm \newinstance.
    CImg&lt;Tfloat&gt; get_normalize() const ;

//! Compute Lp-norm of each multi-valued pixel of the image instance.
    /**
       \param norm_type Type of computed vector norm (can be \p -1=Linf, or \p greater or equal than 0).
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_norm();
       (img,res.normalize(0,255)).display();
       \endcode
       \image html ref_norm.jpg
    **/
    CImg&lt;T&gt;&amp; norm(const int norm_type=2) ;

//! Compute L2-norm of each multi-valued pixel of the image instance \newinstance.
    CImg&lt;Tfloat&gt; get_norm(const int norm_type=2) const ;

//! Cut pixel values in specified range.
    /**
       \param min_value Minimum desired value of the resulting image.
       \param max_value Maximum desired value of the resulting image.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_cut(160,220);
       (img,res).display();
       \endcode
       \image html ref_cut.jpg
    **/
    CImg&lt;T&gt;&amp; cut(const T&amp; min_value, const T&amp; max_value) ;

//! Cut pixel values in specified range \newinstance.
    CImg&lt;T&gt; get_cut(const T&amp; min_value, const T&amp; max_value) const ;

//! Uniformly quantize pixel values.
    /**
       \param nb_levels Number of quantization levels.
       \param keep_range Tells if resulting values keep the same range as the original ones.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_quantize(4);
       (img,res).display();
       \endcode
       \image html ref_quantize.jpg
    **/
    CImg&lt;T&gt;&amp; quantize(const unsigned int nb_levels, const bool keep_range=true) ;

//! Uniformly quantize pixel values \newinstance.
    CImg&lt;T&gt; get_quantize(const unsigned int n, const bool keep_range=true) const ;

//! Threshold pixel values.
    /**
       \param value Threshold value
       \param soft_threshold Tells if soft thresholding must be applied (instead of hard one).
       \param strict_threshold Tells if threshold value is strict.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_threshold(128);
       (img,res.normalize(0,255)).display();
       \endcode
       \image html ref_threshold.jpg
    **/
    CImg&lt;T&gt;&amp; threshold(const T&amp; value, const bool soft_threshold=false, const bool strict_threshold=false) ;

//! Threshold pixel values \newinstance.
    CImg&lt;T&gt; get_threshold(const T&amp; value, const bool soft_threshold=false, const bool strict_threshold=false) const ;

//! Compute the histogram of pixel values.
    /**
       \param nb_levels Number of desired histogram levels.
       \param min_value Minimum pixel value considered for the histogram computation.
         All pixel values lower than \p min_value will not be counted.
       \param max_value Maximum pixel value considered for the histogram computation.
         All pixel values higher than \p max_value will not be counted.
       \note
       - The histogram H of an image I is the 1D function where H(x) counts the number of occurrences of the value x
         in the image I.
       - The resulting histogram is always defined in 1D. Histograms of multi-valued images are not multi-dimensional.
       \par Example
       \code
       const CImg&lt;float&gt; img = CImg&lt;float&gt;("reference.jpg").histogram(256);
       img.display_graph(0,3);
       \endcode
       \image html ref_histogram.jpg
    **/
    CImg&lt;T&gt;&amp; histogram(const unsigned int nb_levels, const T&amp; min_value, const T&amp; max_value) ;

//! Compute the histogram of pixel values \overloading.
    CImg&lt;T&gt;&amp; histogram(const unsigned int nb_levels) ;

//! Compute the histogram of pixel values \newinstance.
    CImg&lt;ulongT&gt; get_histogram(const unsigned int nb_levels, const T&amp; min_value, const T&amp; max_value) const ;

//! Compute the histogram of pixel values \newinstance.
    CImg&lt;ulongT&gt; get_histogram(const unsigned int nb_levels) const ;

//! Equalize histogram of pixel values.
    /**
       \param nb_levels Number of histogram levels used for the equalization.
       \param min_value Minimum pixel value considered for the histogram computation.
         All pixel values lower than \p min_value will not be counted.
       \param max_value Maximum pixel value considered for the histogram computation.
         All pixel values higher than \p max_value will not be counted.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), res = img.get_equalize(256);
       (img,res).display();
       \endcode
       \image html ref_equalize.jpg
    **/
    CImg&lt;T&gt;&amp; equalize(const unsigned int nb_levels, const T&amp; min_value, const T&amp; max_value) ;

//! Equalize histogram of pixel values \overloading.
    CImg&lt;T&gt;&amp; equalize(const unsigned int nb_levels) ;

//! Equalize histogram of pixel values \newinstance.
    CImg&lt;T&gt; get_equalize(const unsigned int nblevels, const T&amp; val_min, const T&amp; val_max) const ;

//! Equalize histogram of pixel values \newinstance.
    CImg&lt;T&gt; get_equalize(const unsigned int nblevels) const ;

//! Index multi-valued pixels regarding to a specified colormap.
    /**
       \param colormap Multi-valued colormap used as the basis for multi-valued pixel indexing.
       \param dithering Level of dithering (0=disable, 1=standard level).
       \param map_indexes Tell if the values of the resulting image are the colormap indices or the colormap vectors.
       \note
       - \p img.index(colormap,dithering,1) is equivalent to &lt;tt&gt;img.index(colormap,dithering,0).map(colormap)&lt;/tt&gt;.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"), colormap(3,1,1,3, 0,128,255, 0,128,255, 0,128,255);
       const CImg&lt;float&gt; res = img.get_index(colormap,1,true);
       (img,res).display();
       \endcode
       \image html ref_index.jpg
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; index(const CImg&lt;t&gt;&amp; colormap, const float dithering=1, const bool map_indexes=false) ;

//! Index multi-valued pixels regarding to a specified colormap \newinstance.
    template&lt;typename t&gt;
    CImg&lt;typename CImg&lt;t&gt;::Tuint&gt;
    get_index(const CImg&lt;t&gt;&amp; colormap, const float dithering=1, const bool map_indexes=true) const ;

//! Map predefined colormap on the scalar (indexed) image instance.
    /**
       \param colormap Multi-valued colormap used for mapping the indexes.
       \param boundary_conditions Boundary conditions. Can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg"),
                         colormap1(3,1,1,3, 0,128,255, 0,128,255, 0,128,255),
                         colormap2(3,1,1,3, 255,0,0, 0,255,0, 0,0,255),
                         res = img.get_index(colormap1,0).map(colormap2);
       (img,res).display();
       \endcode
       \image html ref_map.jpg
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; map(const CImg&lt;t&gt;&amp; colormap, const unsigned int boundary_conditions=0) ;

//! Map predefined colormap on the scalar (indexed) image instance \newinstance.
    template&lt;typename t&gt;
    CImg&lt;t&gt; get_map(const CImg&lt;t&gt;&amp; colormap, const unsigned int boundary_conditions=0) const ;

//! Label connected components.
    /**
       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
       \param tolerance Tolerance used to determine if two neighboring pixels belong to the same region.
       \param is_L2_norm If true, tolerance is compared against L2 difference, otherwise L1 is used.
       \note The algorithm of connected components computation has been primarily done
       by A. Meijster, according to the publication:
       'W.H. Hesselink, A. Meijster, C. Bron, "Concurrent Determination of Connected Components.",
       In: Science of Computer Programming 41 (2001), pp. 173--194'.
       The submitted code has then been modified to fit CImg coding style and constraints.
    **/
    CImg&lt;T&gt;&amp; label(const bool is_high_connectivity=false, const Tfloat tolerance=0,
                   const bool is_L2_norm=true) ;

//! Label connected components \newinstance.
    CImg&lt;ulongT&gt; get_label(const bool is_high_connectivity=false, const Tfloat tolerance=0,
                           const bool is_L2_norm=true) const ;

//! Label connected components \overloading.
    /**
       \param connectivity_mask Mask of the neighboring pixels.
       \param tolerance Tolerance used to determine if two neighboring pixels belong to the same region.
       \param is_L2_norm If true, tolerance is compared against L2 difference, otherwise L1 is used.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; label(const CImg&lt;t&gt;&amp; connectivity_mask, const Tfloat tolerance=0,
                   const bool is_L2_norm=true) ;

//! Label connected components \newinstance.
    template&lt;typename t&gt;
    CImg&lt;ulongT&gt; get_label(const CImg&lt;t&gt;&amp; connectivity_mask, const Tfloat tolerance=0,
                           const bool is_L2_norm=true) const ;

//! \name Color Base Management
    //@;

//! Return colormap \e "default", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_default.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; default_LUT256() ;

//! Return colormap \e "HSV", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_hsv.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; HSV_LUT256() ;

//! Return colormap \e "lines", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_lines.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; lines_LUT256() ;

//! Return colormap \e "hot", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_hot.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; hot_LUT256() ;

//! Return colormap \e "cool", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_cool.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; cool_LUT256() ;

//! Return colormap \e "jet", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_jet.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; jet_LUT256() ;

//! Return colormap \e "flag", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_flag.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; flag_LUT256() ;

//! Return colormap \e "cube", containing 256 colors entries in RGB.
    /**
       \return The following \c 256x1x1x3 colormap is returned:
       \image html ref_colormap_cube.jpg
    **/
    static const CImg&lt;Tuchar&gt;&amp; cube_LUT256() ;

//! Convert pixel values from sRGB to RGB color spaces.
    CImg&lt;T&gt;&amp; sRGBtoRGB() ;

//! Convert pixel values from sRGB to RGB color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_sRGBtoRGB() const ;

//! Convert pixel values from RGB to sRGB color spaces.
    CImg&lt;T&gt;&amp; RGBtosRGB() ;

//! Convert pixel values from RGB to sRGB color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtosRGB() const ;

//! Convert pixel values from RGB to HSI color spaces.
    CImg&lt;T&gt;&amp; RGBtoHSI() ;

//! Convert pixel values from RGB to HSI color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoHSI() const ;

//! Convert pixel values from HSI to RGB color spaces.
    CImg&lt;T&gt;&amp; HSItoRGB() ;

//! Convert pixel values from HSI to RGB color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_HSItoRGB() const ;

//! Convert pixel values from RGB to HSL color spaces.
    CImg&lt;T&gt;&amp; RGBtoHSL() ;

//! Convert pixel values from RGB to HSL color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoHSL() const ;

//! Convert pixel values from HSL to RGB color spaces.
    CImg&lt;T&gt;&amp; HSLtoRGB() ;

//! Convert pixel values from HSL to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_HSLtoRGB() const ;

//! Convert pixel values from RGB to HSV color spaces.
    CImg&lt;T&gt;&amp; RGBtoHSV() ;

//! Convert pixel values from RGB to HSV color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoHSV() const ;

//! Convert pixel values from HSV to RGB color spaces.
    CImg&lt;T&gt;&amp; HSVtoRGB() ;

//! Convert pixel values from HSV to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_HSVtoRGB() const ;

//! Convert pixel values from RGB to YCbCr color spaces.
    CImg&lt;T&gt;&amp; RGBtoYCbCr() ;

//! Convert pixel values from RGB to YCbCr color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_RGBtoYCbCr() const ;

//! Convert pixel values from RGB to YCbCr color spaces.
    CImg&lt;T&gt;&amp; YCbCrtoRGB() ;

//! Convert pixel values from RGB to YCbCr color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_YCbCrtoRGB() const ;

//! Convert pixel values from RGB to YUV color spaces.
    CImg&lt;T&gt;&amp; RGBtoYUV() ;

//! Convert pixel values from RGB to YUV color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoYUV() const ;

//! Convert pixel values from YUV to RGB color spaces.
    CImg&lt;T&gt;&amp; YUVtoRGB() ;

//! Convert pixel values from YUV to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_YUVtoRGB() const ;

//! Convert pixel values from RGB to CMY color spaces.
    CImg&lt;T&gt;&amp; RGBtoCMY() ;

//! Convert pixel values from RGB to CMY color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_RGBtoCMY() const ;

//! Convert pixel values from CMY to RGB color spaces.
    CImg&lt;T&gt;&amp; CMYtoRGB() ;

//! Convert pixel values from CMY to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_CMYtoRGB() const ;

//! Convert pixel values from CMY to CMYK color spaces.
    CImg&lt;T&gt;&amp; CMYtoCMYK() ;

//! Convert pixel values from CMY to CMYK color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_CMYtoCMYK() const ;

//! Convert pixel values from CMYK to CMY color spaces.
    CImg&lt;T&gt;&amp; CMYKtoCMY() ;

//! Convert pixel values from CMYK to CMY color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_CMYKtoCMY() const ;

//! Convert pixel values from RGB to XYZ color spaces.
    /**
       \param use_D65 Tell to use the D65 illuminant (D50 otherwise).
    **/
    CImg&lt;T&gt;&amp; RGBtoXYZ(const bool use_D65=true) ;

//! Convert pixel values from RGB to XYZ color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoXYZ(const bool use_D65=true) const ;

//! Convert pixel values from XYZ to RGB color spaces.
    /**
       \param use_D65 Tell to use the D65 illuminant (D50 otherwise).
    **/
    CImg&lt;T&gt;&amp; XYZtoRGB(const bool use_D65=true) ;

//! Convert pixel values from XYZ to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_XYZtoRGB(const bool use_D65=true) const ;

//! Convert pixel values from XYZ to Lab color spaces.
    CImg&lt;T&gt;&amp; XYZtoLab(const bool use_D65=true) ;

//! Convert pixel values from XYZ to Lab color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_XYZtoLab(const bool use_D65=true) const ;

//! Convert pixel values from Lab to XYZ color spaces.
    CImg&lt;T&gt;&amp; LabtoXYZ(const bool use_D65=true) ;

//! Convert pixel values from Lab to XYZ color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_LabtoXYZ(const bool use_D65=true) const ;

//! Convert pixel values from XYZ to xyY color spaces.
    CImg&lt;T&gt;&amp; XYZtoxyY() ;

//! Convert pixel values from XYZ to xyY color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_XYZtoxyY() const ;

//! Convert pixel values from xyY pixels to XYZ color spaces.
    CImg&lt;T&gt;&amp; xyYtoXYZ() ;

//! Convert pixel values from xyY pixels to XYZ color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_xyYtoXYZ() const ;

//! Convert pixel values from RGB to Lab color spaces.
    CImg&lt;T&gt;&amp; RGBtoLab(const bool use_D65=true) ;

//! Convert pixel values from RGB to Lab color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoLab(const bool use_D65=true) const ;

//! Convert pixel values from Lab to RGB color spaces.
    CImg&lt;T&gt;&amp; LabtoRGB(const bool use_D65=true) ;

//! Convert pixel values from Lab to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_LabtoRGB(const bool use_D65=true) const ;

//! Convert pixel values from RGB to xyY color spaces.
    CImg&lt;T&gt;&amp; RGBtoxyY(const bool use_D65=true) ;

//! Convert pixel values from RGB to xyY color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoxyY(const bool use_D65=true) const ;

//! Convert pixel values from xyY to RGB color spaces.
    CImg&lt;T&gt;&amp; xyYtoRGB(const bool use_D65=true) ;

//! Convert pixel values from xyY to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_xyYtoRGB(const bool use_D65=true) const ;

//! Convert pixel values from RGB to CMYK color spaces.
    CImg&lt;T&gt;&amp; RGBtoCMYK() ;

//! Convert pixel values from RGB to CMYK color spaces \newinstance.
    CImg&lt;Tfloat&gt; get_RGBtoCMYK() const ;

//! Convert pixel values from CMYK to RGB color spaces.
    CImg&lt;T&gt;&amp; CMYKtoRGB() ;

//! Convert pixel values from CMYK to RGB color spaces \newinstance.
    CImg&lt;Tuchar&gt; get_CMYKtoRGB() const ;

//! \name Geometric / Spatial Manipulation
    //@;

//! Resize image to new dimensions.
    /**
       \param size_x Number of columns (new size along the X-axis).
       \param size_y Number of rows (new size along the Y-axis).
       \param size_z Number of slices (new size along the Z-axis).
       \param size_c Number of vector-channels (new size along the C-axis).
       \param interpolation_type Method of interpolation:
       - -1 = no interpolation: raw memory resizing.
       - 0 = no interpolation: additional space is filled according to \p boundary_conditions.
       - 1 = nearest-neighbor interpolation.
       - 2 = moving average interpolation.
       - 3 = linear interpolation.
       - 4 = grid interpolation.
       - 5 = cubic interpolation.
       - 6 = lanczos interpolation.
       \param boundary_conditions Type of boundary conditions used if necessary.
       \param centering_x Set centering type (only if \p interpolation_type=0).
       \param centering_y Set centering type (only if \p interpolation_type=0).
       \param centering_z Set centering type (only if \p interpolation_type=0).
       \param centering_c Set centering type (only if \p interpolation_type=0).
       \note If pd[x,y,z,v]&lt;0, it corresponds to a percentage of the original size (the default value is -100).
    **/
    CImg&lt;T&gt;&amp; resize(const int size_x, const int size_y=-100,
                    const int size_z=-100, const int size_c=-100,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) ;

//! Resize image to new dimensions \newinstance.
    CImg&lt;T&gt; get_resize(const int size_x, const int size_y = -100,
                       const int size_z = -100, const int size_c = -100,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const ;

//! Resize image to dimensions of another image.
    /**
       \param src Reference image used for dimensions.
       \param interpolation_type Interpolation method.
       \param boundary_conditions Boundary conditions.
       \param centering_x Set centering type (only if \p interpolation_type=0).
       \param centering_y Set centering type (only if \p interpolation_type=0).
       \param centering_z Set centering type (only if \p interpolation_type=0).
       \param centering_c Set centering type (only if \p interpolation_type=0).
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; resize(const CImg&lt;t&gt;&amp; src,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) ;

//! Resize image to dimensions of another image \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_resize(const CImg&lt;t&gt;&amp; src,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const ;

//! Resize image to dimensions of a display window.
    /**
       \param disp Reference display window used for dimensions.
       \param interpolation_type Interpolation method.
       \param boundary_conditions Boundary conditions.
       \param centering_x Set centering type (only if \p interpolation_type=0).
       \param centering_y Set centering type (only if \p interpolation_type=0).
       \param centering_z Set centering type (only if \p interpolation_type=0).
       \param centering_c Set centering type (only if \p interpolation_type=0).
     **/
    CImg&lt;T&gt;&amp; resize(const CImgDisplay&amp; disp,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) ;

//! Resize image to dimensions of a display window \newinstance.
    CImg&lt;T&gt; get_resize(const CImgDisplay&amp; disp,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const ;

//! Resize image to half-size along XY axes, using an optimized filter.
    CImg&lt;T&gt;&amp; resize_halfXY() ;

//! Resize image to half-size along XY axes, using an optimized filter \newinstance.
    CImg&lt;T&gt; get_resize_halfXY() const ;

//! Resize image to double-size, using the Scale2X algorithm.
    /**
       \note Use anisotropic upscaling algorithm
       &lt;a href="http://scale2x.sourceforge.net/algorithm.html"&gt;described here&lt;/a&gt;.
    **/
    CImg&lt;T&gt;&amp; resize_doubleXY() ;

//! Resize image to double-size, using the Scale2X algorithm \newinstance.
    CImg&lt;T&gt; get_resize_doubleXY() const ;

//! Resize image to triple-size, using the Scale3X algorithm.
    /**
       \note Use anisotropic upscaling algorithm
       &lt;a href="http://scale2x.sourceforge.net/algorithm.html"&gt;described here&lt;/a&gt;.
    **/
    CImg&lt;T&gt;&amp; resize_tripleXY() ;

//! Resize image to triple-size, using the Scale3X algorithm \newinstance.
    CImg&lt;T&gt; get_resize_tripleXY() const ;

//! Mirror image content along specified axis.
    /**
       \param axis Mirror axis
    **/
    CImg&lt;T&gt;&amp; mirror(const char axis) ;

//! Mirror image content along specified axis \newinstance.
    CImg&lt;T&gt; get_mirror(const char axis) const ;

//! Mirror image content along specified axes.
    /**
       \param axes Mirror axes, as a C-string.
       \note \c axes may contains multiple characters, e.g. \c "xyz"
    **/
    CImg&lt;T&gt;&amp; mirror(const char *const axes) ;

//! Mirror image content along specified axes \newinstance.
    CImg&lt;T&gt; get_mirror(const char *const axes) const ;

//! Shift image content.
    /**
       \param delta_x Amount of displacement along the X-axis.
       \param delta_y Amount of displacement along the Y-axis.
       \param delta_z Amount of displacement along the Z-axis.
       \param delta_c Amount of displacement along the C-axis.
       \param boundary_conditions Boundary conditions. Can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
    **/
    CImg&lt;T&gt;&amp; shift(const int delta_x, const int delta_y=0, const int delta_z=0, const int delta_c=0,
                   const unsigned int boundary_conditions=0) ;

//! Shift image content \newinstance.
    CImg&lt;T&gt; get_shift(const int delta_x, const int delta_y=0, const int delta_z=0, const int delta_c=0,
                      const unsigned int boundary_conditions=0) const ;

//! Permute axes order.
    /**
       \param axes_order Axes permutations, as a C-string of 4 characters.
       This function permutes image content regarding the specified axes permutation.
    **/
    CImg&lt;T&gt;&amp; permute_axes(const char *const axes_order) ;

//! Permute axes order \newinstance.
    CImg&lt;T&gt; get_permute_axes(const char *const axes_order) const ;

//! Unroll pixel values along specified axis.
    /**
       \param axis Unroll axis (can be \c 'x', \c 'y', \c 'z' or c 'c').
    **/
    CImg&lt;T&gt;&amp; unroll(const char axis) ;

//! Unroll pixel values along specified axis \newinstance.
    CImg&lt;T&gt; get_unroll(const char axis) const ;

//! Rotate image with arbitrary angle.
    /**
       \param angle Rotation angle, in degrees.
       \param interpolation Type of interpolation. Can be &lt;tt&gt;{ 0=nearest | 1=linear | 2=cubic }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions.
              Can be &lt;tt&gt;{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }&lt;/tt&gt;.
       \note The size of the image is modified.
    **/
    CImg&lt;T&gt;&amp; rotate(const float angle, const unsigned int interpolation=1,
                    const unsigned int boundary_conditions=0) ;

//! Rotate image with arbitrary angle \newinstance.
    CImg&lt;T&gt; get_rotate(const float angle, const unsigned int interpolation=1,
                       const unsigned int boundary_conditions=0) const ;

//! Rotate image with arbitrary angle, around a center point.
    /**
       \param angle Rotation angle, in degrees.
       \param cx X-coordinate of the rotation center.
       \param cy Y-coordinate of the rotation center.
       \param interpolation Type of interpolation, &lt;tt&gt;{ 0=nearest | 1=linear | 2=cubic | 3=mirror }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions, &lt;tt&gt;{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }&lt;/tt&gt;.
    **/
    CImg&lt;T&gt;&amp; rotate(const float angle, const float cx, const float cy,
                    const unsigned int interpolation, const unsigned int boundary_conditions=0) ;

//! Rotate image with arbitrary angle, around a center point \newinstance.
    CImg&lt;T&gt; get_rotate(const float angle, const float cx, const float cy,
                       const unsigned int interpolation, const unsigned int boundary_conditions=0) const ;

//! Rotate volumetric image with arbitrary angle and axis.
    /**
       \param u X-coordinate of the 3D rotation axis.
       \param v Y-coordinate of the 3D rotation axis.
       \param w Z-coordinate of the 3D rotation axis.
       \param angle Rotation angle, in degrees.
       \param interpolation Type of interpolation. Can be &lt;tt&gt;{ 0=nearest | 1=linear | 2=cubic }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions.
              Can be &lt;tt&gt;{  0=dirichlet | 1=neumann | 2=periodic | 3=mirror }&lt;/tt&gt;.
       \note Most of the time, size of the image is modified.
    **/
    CImg&lt;T&gt; rotate(const float u, const float v, const float w, const float angle,
                   const unsigned int interpolation, const unsigned int boundary_conditions) ;

//! Rotate volumetric image with arbitrary angle and axis \newinstance.
    CImg&lt;T&gt; get_rotate(const float u, const float v, const float w, const float angle,
                       const unsigned int interpolation, const unsigned int boundary_conditions) const ;

//! Rotate volumetric image with arbitrary angle and axis, around a center point.
    /**
       \param u X-coordinate of the 3D rotation axis.
       \param v Y-coordinate of the 3D rotation axis.
       \param w Z-coordinate of the 3D rotation axis.
       \param angle Rotation angle, in degrees.
       \param cx X-coordinate of the rotation center.
       \param cy Y-coordinate of the rotation center.
       \param cz Z-coordinate of the rotation center.
       \param interpolation Type of interpolation. Can be &lt;tt&gt;{ 0=nearest | 1=linear | 2=cubic | 3=mirror }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{  0=dirichlet | 1=neumann | 2=periodic }&lt;/tt&gt;.
       \note Most of the time, size of the image is modified.
    **/
    CImg&lt;T&gt; rotate(const float u, const float v, const float w, const float angle,
                   const float cx, const float cy, const float cz,
                   const unsigned int interpolation=1, const unsigned int boundary_conditions=0) ;

//! Rotate volumetric image with arbitrary angle and axis, around a center point \newinstance.
    CImg&lt;T&gt; get_rotate(const float u, const float v, const float w, const float angle,
                       const float cx, const float cy, const float cz,
                       const unsigned int interpolation=1, const unsigned int boundary_conditions=0) const ;

//! Warp image content by a warping field.
    /**
       \param warp Warping field.
       \param mode Can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=foward-relative }
       \param interpolation Can be &lt;tt&gt;{ 0=nearest | 1=linear | 2=cubic }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions &lt;tt&gt;{ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }&lt;/tt&gt;.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; warp(const CImg&lt;t&gt;&amp; p_warp, const unsigned int mode=0,
                  const unsigned int interpolation=1, const unsigned int boundary_conditions=0) ;

//! Warp image content by a warping field \newinstance
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_warp(const CImg&lt;t&gt;&amp; p_warp, const unsigned int mode=0,
                     const unsigned int interpolation=1, const unsigned int boundary_conditions=0) const ;

//! Generate a 2D representation of a 3D image, with XY,XZ and YZ views.
    /**
       \param x0 X-coordinate of the projection point.
       \param y0 Y-coordinate of the projection point.
       \param z0 Z-coordinate of the projection point.
    **/
    CImg&lt;T&gt; get_projections2d(const unsigned int x0, const unsigned int y0, const unsigned int z0) const ;

//! Construct a 2D representation of a 3D image, with XY,XZ and YZ views \inplace.
    CImg&lt;T&gt;&amp; projections2d(const unsigned int x0, const unsigned int y0, const unsigned int z0) ;

//! Crop image region.
    /**
       \param x0 = X-coordinate of the upper-left crop rectangle corner.
       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
       \param c0 = C-coordinate of the upper-left crop rectangle corner.
       \param x1 = X-coordinate of the lower-right crop rectangle corner.
       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
       \param c1 = C-coordinate of the lower-right crop rectangle corner.
       \param boundary_conditions = Can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
    **/
    CImg&lt;T&gt;&amp; crop(const int x0, const int y0, const int z0, const int c0,
                  const int x1, const int y1, const int z1, const int c1,
                  const unsigned int boundary_conditions=0) ;

//! Crop image region \newinstance.
    CImg&lt;T&gt; get_crop(const int x0, const int y0, const int z0, const int c0,
                     const int x1, const int y1, const int z1, const int c1,
                     const unsigned int boundary_conditions=0) const ;

//! Crop image region \overloading.
    CImg&lt;T&gt;&amp; crop(const int x0, const int y0, const int z0,
                  const int x1, const int y1, const int z1,
                  const unsigned int boundary_conditions=0) ;

//! Crop image region \newinstance.
    CImg&lt;T&gt; get_crop(const int x0, const int y0, const int z0,
                     const int x1, const int y1, const int z1,
                     const unsigned int boundary_conditions=0) const ;

//! Crop image region \overloading.
    CImg&lt;T&gt;&amp; crop(const int x0, const int y0,
                  const int x1, const int y1,
                  const unsigned int boundary_conditions=0) ;

//! Crop image region \newinstance.
    CImg&lt;T&gt; get_crop(const int x0, const int y0,
                     const int x1, const int y1,
                     const unsigned int boundary_conditions=0) const ;

//! Crop image region \overloading.
    CImg&lt;T&gt;&amp; crop(const int x0, const int x1, const unsigned int boundary_conditions=0) ;

//! Crop image region \newinstance.
    CImg&lt;T&gt; get_crop(const int x0, const int x1, const unsigned int boundary_conditions=0) const ;

//! Autocrop image region, regarding the specified background value.
    CImg&lt;T&gt;&amp; autocrop(const T&amp; value, const char *const axes="czyx") ;

//! Autocrop image region, regarding the specified background value \newinstance.
    CImg&lt;T&gt; get_autocrop(const T&amp; value, const char *const axes="czyx") const ;

//! Autocrop image region, regarding the specified background color.
    /**
       \param color Color used for the crop. If \c 0, color is guessed.
       \param axes Axes used for the crop.
    **/
    CImg&lt;T&gt;&amp; autocrop(const T *const color=0, const char *const axes="zyx") ;

//! Autocrop image region, regarding the specified background color \newinstance.
    CImg&lt;T&gt; get_autocrop(const T *const color=0, const char *const axes="zyx") const ;

//! Return specified image column.
    /**
       \param x0 Image column.
    **/
    CImg&lt;T&gt; get_column(const int x0) const ;

//! Return specified image column \inplace.
    CImg&lt;T&gt;&amp; column(const int x0) ;

//! Return specified range of image columns.
    /**
       \param x0 Starting image column.
       \param x1 Ending image column.
    **/
    CImg&lt;T&gt;&amp; columns(const int x0, const int x1) ;

//! Return specified range of image columns \inplace.
    CImg&lt;T&gt; get_columns(const int x0, const int x1) const ;

//! Return specified image row.
    CImg&lt;T&gt; get_row(const int y0) const ;

//! Return specified image row \inplace.
    /**
       \param y0 Image row.
    **/
    CImg&lt;T&gt;&amp; row(const int y0) ;

//! Return specified range of image rows.
    /**
       \param y0 Starting image row.
       \param y1 Ending image row.
    **/
    CImg&lt;T&gt; get_rows(const int y0, const int y1) const ;

//! Return specified range of image rows \inplace.
    CImg&lt;T&gt;&amp; rows(const int y0, const int y1) ;

//! Return specified image slice.
    /**
       \param z0 Image slice.
    **/
    CImg&lt;T&gt; get_slice(const int z0) const ;

//! Return specified image slice \inplace.
    CImg&lt;T&gt;&amp; slice(const int z0) ;

//! Return specified range of image slices.
    /**
       \param z0 Starting image slice.
       \param z1 Ending image slice.
    **/
    CImg&lt;T&gt; get_slices(const int z0, const int z1) const ;

//! Return specified range of image slices \inplace.
    CImg&lt;T&gt;&amp; slices(const int z0, const int z1) ;

//! Return specified image channel.
    /**
       \param c0 Image channel.
    **/
    CImg&lt;T&gt; get_channel(const int c0) const ;

//! Return specified image channel \inplace.
    CImg&lt;T&gt;&amp; channel(const int c0) ;

//! Return specified range of image channels.
    /**
       \param c0 Starting image channel.
       \param c1 Ending image channel.
    **/
    CImg&lt;T&gt; get_channels(const int c0, const int c1) const ;

//! Return specified range of image channels \inplace.
    CImg&lt;T&gt;&amp; channels(const int c0, const int c1) ;

//! Return stream line of a 2D or 3D vector field.
    CImg&lt;floatT&gt; get_streamline(const float x, const float y, const float z,
                                const float L=256, const float dl=0.1f,
                                const unsigned int interpolation_type=2, const bool is_backward_tracking=false,
                                const bool is_oriented_only=false) const ;

//! Return stream line of a 3D vector field.
    /**
       \param func Vector field function.
       \param x X-coordinate of the starting point of the streamline.
       \param y Y-coordinate of the starting point of the streamline.
       \param z Z-coordinate of the starting point of the streamline.
       \param L Streamline length.
       \param dl Streamline length increment.
       \param interpolation_type Type of interpolation.
         Can be &lt;tt&gt;{ 0=nearest int | 1=linear | 2=2nd-order RK | 3=4th-order RK. }&lt;/tt&gt;.
       \param is_backward_tracking Tells if the streamline is estimated forward or backward.
       \param is_oriented_only Tells if the direction of the vectors must be ignored.
       \param x0 X-coordinate of the first bounding-box vertex.
       \param y0 Y-coordinate of the first bounding-box vertex.
       \param z0 Z-coordinate of the first bounding-box vertex.
       \param x1 X-coordinate of the second bounding-box vertex.
       \param y1 Y-coordinate of the second bounding-box vertex.
       \param z1 Z-coordinate of the second bounding-box vertex.
    **/
    template&lt;typename tfunc&gt;
    static CImg&lt;floatT&gt; streamline(const tfunc&amp; func,
                                   const float x, const float y, const float z,
                                   const float L=256, const float dl=0.1f,
                                   const unsigned int interpolation_type=2, const bool is_backward_tracking=false,
                                   const bool is_oriented_only=false,
                                   const float x0=0, const float y0=0, const float z0=0,
                                   const float x1=0, const float y1=0, const float z1=0) ;

//! Return stream line of a 3D vector field \overloading.
    static CImg&lt;floatT&gt; streamline(const char *const expression,
                                   const float x, const float y, const float z,
                                   const float L=256, const float dl=0.1f,
                                   const unsigned int interpolation_type=2, const bool is_backward_tracking=true,
                                   const bool is_oriented_only=false,
                                   const float x0=0, const float y0=0, const float z0=0,
                                   const float x1=0, const float y1=0, const float z1=0) ;

//! Return a shared-memory image referencing a range of pixels of the image instance.
    /**
       \param x0 X-coordinate of the starting pixel.
       \param x1 X-coordinate of the ending pixel.
       \param y0 Y-coordinate.
       \param z0 Z-coordinate.
       \param c0 C-coordinate.
     **/
    CImg&lt;T&gt; get_shared_points(const unsigned int x0, const unsigned int x1,
                              const unsigned int y0=0, const unsigned int z0=0, const unsigned int c0=0) ;

//! Return a shared-memory image referencing a range of pixels of the image instance \const.
    const CImg&lt;T&gt; get_shared_points(const unsigned int x0, const unsigned int x1,
                                    const unsigned int y0=0, const unsigned int z0=0, const unsigned int c0=0) const ;

//! Return a shared-memory image referencing a range of rows of the image instance.
    /**
       \param y0 Y-coordinate of the starting row.
       \param y1 Y-coordinate of the ending row.
       \param z0 Z-coordinate.
       \param c0 C-coordinate.
    **/
    CImg&lt;T&gt; get_shared_rows(const unsigned int y0, const unsigned int y1,
                             const unsigned int z0=0, const unsigned int c0=0) ;

//! Return a shared-memory image referencing a range of rows of the image instance \const.
    const CImg&lt;T&gt; get_shared_rows(const unsigned int y0, const unsigned int y1,
                                   const unsigned int z0=0, const unsigned int c0=0) const ;

//! Return a shared-memory image referencing one row of the image instance.
    /**
       \param y0 Y-coordinate.
       \param z0 Z-coordinate.
       \param c0 C-coordinate.
    **/
    CImg&lt;T&gt; get_shared_row(const unsigned int y0, const unsigned int z0=0, const unsigned int c0=0) ;

//! Return a shared-memory image referencing one row of the image instance \const.
    const CImg&lt;T&gt; get_shared_row(const unsigned int y0, const unsigned int z0=0, const unsigned int c0=0) const ;

//! Return a shared memory image referencing a range of slices of the image instance.
    /**
       \param z0 Z-coordinate of the starting slice.
       \param z1 Z-coordinate of the ending slice.
       \param c0 C-coordinate.
    **/
    CImg&lt;T&gt; get_shared_slices(const unsigned int z0, const unsigned int z1, const unsigned int c0=0) ;

//! Return a shared memory image referencing a range of slices of the image instance \const.
    const CImg&lt;T&gt; get_shared_slices(const unsigned int z0, const unsigned int z1, const unsigned int c0=0) const ;

//! Return a shared-memory image referencing one slice of the image instance.
    /**
       \param z0 Z-coordinate.
       \param c0 C-coordinate.
    **/
    CImg&lt;T&gt; get_shared_slice(const unsigned int z0, const unsigned int c0=0) ;

//! Return a shared-memory image referencing one slice of the image instance \const.
    const CImg&lt;T&gt; get_shared_slice(const unsigned int z0, const unsigned int c0=0) const ;

//! Return a shared-memory image referencing a range of channels of the image instance.
    /**
       \param c0 C-coordinate of the starting channel.
       \param c1 C-coordinate of the ending channel.
    **/
    CImg&lt;T&gt; get_shared_channels(const unsigned int c0, const unsigned int c1) ;

//! Return a shared-memory image referencing a range of channels of the image instance \const.
    const CImg&lt;T&gt; get_shared_channels(const unsigned int c0, const unsigned int c1) const ;

//! Return a shared-memory image referencing one channel of the image instance.
    /**
       \param c0 C-coordinate.
    **/
    CImg&lt;T&gt; get_shared_channel(const unsigned int c0) ;

//! Return a shared-memory image referencing one channel of the image instance \const.
    const CImg&lt;T&gt; get_shared_channel(const unsigned int c0) const ;

//! Return a shared-memory version of the image instance.
    CImg&lt;T&gt; get_shared() ;

//! Return a shared-memory version of the image instance \const.
    const CImg&lt;T&gt; get_shared() const ;

//! Split image into a list along specified axis.
    /**
       \param axis Splitting axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param nb Number of split parts.
       \note
       - If \c nb==0, instance image is split into blocs of egal values along the specified axis.
       - If \c nb&lt;=0, instance image is split into blocs of -\c nb pixel wide.
       - If \c nb&gt;0, instance image is split into \c nb blocs.
    **/
    CImgList&lt;T&gt; get_split(const char axis, const int nb=-1) const ;

//! Split image into a list of sub-images, according to a specified splitting value sequence and optionally axis.
    /**
       \param values Splitting value sequence.
       \param axis Axis along which the splitting is performed. Can be '0' to ignore axis.
       \param keep_values Tells if the splitting sequence must be kept in the split blocs.
     **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt; get_split(const CImg&lt;t&gt;&amp; values, const char axis=0, const bool keep_values=true) const ;

//! Append two images along specified axis.
    /**
       \param img Image to append with instance image.
       \param axis Appending axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param align Append alignment in \c [0,1].
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; append(const CImg&lt;t&gt;&amp; img, const char axis='x', const float align=0) ;

//! Append two images along specified axis \specialization.
    CImg&lt;T&gt;&amp; append(const CImg&lt;T&gt;&amp; img, const char axis='x', const float align=0) ;

//! Append two images along specified axis \const.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_append(const CImg&lt;T&gt;&amp; img, const char axis='x', const float align=0) const ;

//! Append two images along specified axis \specialization.
    CImg&lt;T&gt; get_append(const CImg&lt;T&gt;&amp; img, const char axis='x', const float align=0) const ;

//! \name Filtering / Transforms
    //@;

//! Correlate image by a kernel.
    /**
       \param kernel = the correlation kernel.
       \param boundary_conditions Boundary condition. Can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
       \param is_normalized = enable local normalization.
       \param channel_mode Channel processing mode.
                           Can be { 0=all | 1=one for one (default) | 2=partial sum | 3=full sum }.
       \param xcenter X-coordinate of the kernel center (~0U&gt;&gt;1 means 'centered').
       \param ycenter Y-coordinate of the kernel center (~0U&gt;&gt;1 means 'centered').
       \param zcenter Z-coordinate of the kernel center (~0U&gt;&gt;1 means 'centered').
       \param xstart Starting X-coordinate of the instance image.
       \param ystart Starting Y-coordinate of the instance image.
       \param zstart Starting Z-coordinate of the instance image.
       \param xend Ending X-coordinate of the instance image.
       \param yend Ending Y-coordinate of the instance image.
       \param zend Ending Z-coordinate of the instance image.
       \param xstride Stride along the X-axis.
       \param ystride Stride along the Y-axis.
       \param zstride Stride along the Z-axis.
       \param xdilation Dilation along the X-axis.
       \param ydilation Dilation along the Y-axis.
       \param zdilation Dilation along the Z-axis.
       \param interpolation_type Can be { false=nearest | true=linear }.
       \note
       - The correlation of the image instance \p *this by the kernel \p kernel is defined to be:
       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x + \beta_x\;(i - c_x),\alpha_y\;y + \beta_y\;(j -
                    c_y),\alpha_z\;z + \beta_z\;(k - c_z))*kernel(i,j,k).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; correlate(const CImg&lt;t&gt;&amp; kernel, const unsigned int boundary_conditions=1,
                       const bool is_normalized=false, const unsigned int channel_mode=1,
                       const int xcenter=(int)(~0U&gt;&gt;1),
                       const int ycenter=(int)(~0U&gt;&gt;1),
                       const int zcenter=(int)(~0U&gt;&gt;1),
                       const int xstart=0,
                       const int ystart=0,
                       const int zstart=0,
                       const int xend=(int)(~0U&gt;&gt;1),
                       const int yend=(int)(~0U&gt;&gt;1),
                       const int zend=(int)(~0U&gt;&gt;1),
                       const float xstride=1, const float ystride=1, const float zstride=1,
                       const float xdilation=1, const float ydilation=1, const float zdilation=1,
                       const bool interpolation_type=false) ;

//! Correlate image by a kernel \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Ttfloat&gt; _correlate(const CImg&lt;t&gt;&amp; kernel, const unsigned int boundary_conditions,
                                   const bool is_normalized, const unsigned int channel_mode,
                                   const int xcenter, const int ycenter, const int zcenter,
                                   const int xstart, const int ystart, const int zstart,
                                   const int xend, const int yend, const int zend,
                                   const float xstride, const float ystride, const float zstride,
                                   const float xdilation, const float ydilation, const float zdilation,
                                   const bool interpolation_type, const bool is_convolve) const ;

//! Convolve image by a kernel.
    /**
       \param kernel = the correlation kernel.
       \param boundary_conditions Boundary condition. Can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
       \param is_normalized = enable local normalization.
       \param channel_mode Channel processing mode.
                           Can be { 0=all | 1=one for one (default) | 2=partial sum | 3=full sum }.
       \param xcenter X-coordinate of the kernel center (~0U means 'centered').
       \param ycenter Y-coordinate of the kernel center (~0U means 'centered').
       \param zcenter Z-coordinate of the kernel center (~0U means 'centered').
       \param xstart Starting X-coordinate of the instance image.
       \param ystart Starting Y-coordinate of the instance image.
       \param zstart Starting Z-coordinate of the instance image.
       \param xend Ending X-coordinate of the instance image.
       \param yend Ending Y-coordinate of the instance image.
       \param zend Ending Z-coordinate of the instance image.
       \param xstride Stride along the X-axis.
       \param ystride Stride along the Y-axis.
       \param zstride Stride along the Z-axis.
       \param xdilation Dilation along the X-axis.
       \param ydilation Dilation along the Y-axis.
       \param zdilation Dilation along the Z-axis.
       \param interpolation_type Can be { false=nearest | true=linear }.
       \note
       - The convolution of the image instance \p *this by the kernel \p kernel is defined to be:
       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x - \beta_x\;(i - c_x),\alpha_y\;y
                    - \beta_y\;(j - c_y),\alpha_z\;z - \beta_z\;(k - c_z))*kernel(i,j,k).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; convolve(const CImg&lt;t&gt;&amp; kernel, const unsigned int boundary_conditions=1,
                      const bool is_normalized=false, const unsigned int channel_mode=1,
                      const int xcenter=(int)(~0U&gt;&gt;1),
                      const int ycenter=(int)(~0U&gt;&gt;1),
                      const int zcenter=(int)(~0U&gt;&gt;1),
                      const int xstart=0,
                      const int ystart=0,
                      const int zstart=0,
                      const int xend=(int)(~0U&gt;&gt;1),
                      const int yend=(int)(~0U&gt;&gt;1),
                      const int zend=(int)(~0U&gt;&gt;1),
                      const float xstride=1, const float ystride=1, const float zstride=1,
                      const float xdilation=1, const float ydilation=1, const float zdilation=1,
                      const bool interpolation_type=false) ;

//! Convolve image by a kernel \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Ttfloat&gt; get_convolve(const CImg&lt;t&gt;&amp; kernel, const unsigned int boundary_conditions=1,
                                     const bool is_normalized=false, const unsigned int channel_mode=1,
                                     const int xcenter=(int)(~0U&gt;&gt;1),
                                     const int ycenter=(int)(~0U&gt;&gt;1),
                                     const int zcenter=(int)(~0U&gt;&gt;1),
                                     const int xstart=0,
                                     const int ystart=0,
                                     const int zstart=0,
                                     const int xend=(int)(~0U&gt;&gt;1),
                                     const int yend=(int)(~0U&gt;&gt;1),
                                     const int zend=(int)(~0U&gt;&gt;1),
                                     const float xstride=1, const float ystride=1, const float zstride=1,
                                     const float xdilation=1, const float ydilation=1, const float zdilation=1,
                                     const bool interpolation_type=false) const ;

//! Cumulate image values, optionally along specified axis.
    /**
       \param axis Cumulation axis. Set it to 0 to cumulate all values globally without taking axes into account.
    **/
    CImg&lt;T&gt;&amp; cumulate(const char axis=0) ;

//! Cumulate image values, optionally along specified axis \newinstance.
    CImg&lt;Tlong&gt; get_cumulate(const char axis=0) const ;

//! Cumulate image values, along specified axes.
    /**
       \param axes Cumulation axes, as a C-string.
       \note \c axes may contains multiple characters, e.g. \c "xyz"
    **/
    CImg&lt;T&gt;&amp; cumulate(const char *const axes) ;

//! Cumulate image values, along specified axes \newinstance.
    CImg&lt;Tlong&gt; get_cumulate(const char *const axes) const ;

//! Erode image by a structuring element.
    /**
       \param kernel Structuring element.
       \param boundary_conditions Boundary conditions.
       \param is_real Do the erosion in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; erode(const CImg&lt;t&gt;&amp; kernel, const bool boundary_conditions=true,
                   const bool is_real=false) ;

//! Erode image by a structuring element \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_erode(const CImg&lt;t&gt;&amp; kernel, const bool boundary_conditions=true,
                             const bool is_real=false) const ;

//! Erode image by a rectangular structuring element of specified size.
    /**
       \param sx Width of the structuring element.
       \param sy Height of the structuring element.
       \param sz Depth of the structuring element.
    **/
    CImg&lt;T&gt;&amp; erode(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) ;

//! Erode image by a rectangular structuring element of specified size \newinstance.
    CImg&lt;T&gt; get_erode(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) const ;

//! Erode the image by a square structuring element of specified size.
    /**
       \param s Size of the structuring element.
    **/
    CImg&lt;T&gt;&amp; erode(const unsigned int s) ;

//! Erode the image by a square structuring element of specified size \newinstance.
    CImg&lt;T&gt; get_erode(const unsigned int s) const ;

//! Dilate image by a structuring element.
    /**
       \param kernel Structuring element.
       \param boundary_conditions Boundary conditions.
       \param is_real Do the dilation in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; dilate(const CImg&lt;t&gt;&amp; kernel, const bool boundary_conditions=true,
                    const bool is_real=false) ;

//! Dilate image by a structuring element \newinstance.
    template&lt;typename t&gt;
    CImg&lt;_cimg_Tt&gt; get_dilate(const CImg&lt;t&gt;&amp; kernel, const bool boundary_conditions=true,
                              const bool is_real=false) const ;

//! Dilate image by a rectangular structuring element of specified size.
    /**
       \param sx Width of the structuring element.
       \param sy Height of the structuring element.
       \param sz Depth of the structuring element.
    **/
    CImg&lt;T&gt;&amp; dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) ;

//! Dilate image by a rectangular structuring element of specified size \newinstance.
    CImg&lt;T&gt; get_dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) const ;

//! Dilate image by a square structuring element of specified size.
    /**
       \param s Size of the structuring element.
    **/
    CImg&lt;T&gt;&amp; dilate(const unsigned int s) ;

//! Dilate image by a square structuring element of specified size \newinstance.
    CImg&lt;T&gt; get_dilate(const unsigned int s) const ;

//! Compute watershed transform.
    /**
       \param priority Priority map.
       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
       \note Non-zero values of the instance instance are propagated to zero-valued ones according to
       specified the priority map.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; watershed(const CImg&lt;t&gt;&amp; priority, const bool is_high_connectivity=false) ;

//! Compute watershed transform \newinstance.
    template&lt;typename t&gt;
    CImg&lt;T&gt; get_watershed(const CImg&lt;t&gt;&amp; priority, const bool is_high_connectivity=false) const ;

//! Apply recursive Deriche filter.
    /**
       \param sigma Standard deviation of the filter.
       \param order Order of the filter. Can be &lt;tt&gt;{ 0=smooth-filter | 1=1st-derivative | 2=2nd-derivative }&lt;/tt&gt;.
       \param axis Axis along which the filter is computed. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ 0=dirichlet | 1=neumann }&lt;/tt&gt;.
    **/
    CImg&lt;T&gt;&amp; deriche(const float sigma, const unsigned int order=0, const char axis='x',
                     const bool boundary_conditions=true) ;

//! Apply recursive Deriche filter \newinstance.
    CImg&lt;Tfloat&gt; get_deriche(const float sigma, const unsigned int order=0, const char axis='x',
                             const bool boundary_conditions=true) const ;

//! Van Vliet recursive Gaussian filter.
    /**
       \param sigma standard deviation of the Gaussian filter
       \param order the order of the filter 0,1,2,3
       \param axis  Axis along which the filter is computed. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ 0=dirichlet | 1=neumann }&lt;/tt&gt;.
       \note dirichlet boundary condition has a strange behavior

       I.T. Young, L.J. van Vliet, M. van Ginkel, Recursive Gabor filtering.
       IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.

       (this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)

       Boundary conditions (only for order 0) using Triggs matrix, from
       B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
       recursive filtering. IEEE Trans. Signal Processing,
       vol. 54, pp. 2365-2367, 2006.
    **/
    CImg&lt;T&gt;&amp; vanvliet(const float sigma, const unsigned int order, const char axis='x',
                      const bool boundary_conditions=true) ;

//! Blur image using Van Vliet recursive Gaussian filter. \newinstance.
    CImg&lt;Tfloat&gt; get_vanvliet(const float sigma, const unsigned int order, const char axis='x',
                              const bool boundary_conditions=true) const ;

//! Blur image.
    /**
       \param sigma_x Standard deviation of the blur, along the X-axis.
       \param sigma_y Standard deviation of the blur, along the Y-axis.
       \param sigma_z Standard deviation of the blur, along the Z-axis.
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ false=dirichlet | true=neumann }&lt;/tt&gt;.
       \param is_gaussian Tells if the blur uses a gaussian (\c true) or quasi-gaussian (\c false) kernel.
       \note
       - The blur is computed as a 0-order Vanvliet (gaussian) or Deriche filter (quasi-gaussian).
       - This is a recursive algorithm, not depending on the values of the standard deviations.
       \see deriche(), vanvliet().
    **/
    CImg&lt;T&gt;&amp; blur(const float sigma_x, const float sigma_y, const float sigma_z,
                  const bool boundary_conditions=true, const bool is_gaussian=true) ;

//! Blur image \newinstance.
    CImg&lt;Tfloat&gt; get_blur(const float sigma_x, const float sigma_y, const float sigma_z,
                          const bool boundary_conditions=true, const bool is_gaussian=true) const ;

//! Blur image isotropically.
    /**
       \param sigma Standard deviation of the blur.
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ 0=dirichlet | 1=neumann }&lt;/tt&gt;.a
       \param is_gaussian Use a gaussian kernel (VanVliet) is set, a quasi-gaussian (Deriche) otherwise.
       \see deriche(), vanvliet().
    **/
    CImg&lt;T&gt;&amp; blur(const float sigma, const bool boundary_conditions=true, const bool is_gaussian=true) ;

//! Blur image isotropically \newinstance.
    CImg&lt;Tfloat&gt; get_blur(const float sigma, const bool boundary_conditions=true, const bool is_gaussian=true) const ;

//! Blur image anisotropically, directed by a field of diffusion tensors.
    /**
       \param G Field of square roots of diffusion tensors/vectors used to drive the smoothing.
       \param amplitude Amplitude of the smoothing.
       \param dl Spatial discretization.
       \param da Angular discretization.
       \param gauss_prec Precision of the diffusion process.
       \param interpolation_type Interpolation scheme.
         Can be &lt;tt&gt;{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }&lt;/tt&gt;.
       \param is_fast_approx Tells if a fast approximation of the gaussian function is used or not.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; blur_anisotropic(const CImg&lt;t&gt;&amp; G,
                              const float amplitude=60, const float dl=0.8f, const float da=30,
                              const float gauss_prec=2, const unsigned int interpolation_type=0,
                              const bool is_fast_approx=1) ;

//! Blur image anisotropically, directed by a field of diffusion tensors \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_blur_anisotropic(const CImg&lt;t&gt;&amp; G,
                                      const float amplitude=60, const float dl=0.8f, const float da=30,
                                      const float gauss_prec=2, const unsigned int interpolation_type=0,
                                      const bool is_fast_approx=true) const ;

//! Blur image anisotropically, in an edge-preserving way.
    /**
       \param amplitude Amplitude of the smoothing.
       \param sharpness Sharpness.
       \param anisotropy Anisotropy.
       \param alpha Standard deviation of the gradient blur.
       \param sigma Standard deviation of the structure tensor blur.
       \param dl Spatial discretization.
       \param da Angular discretization.
       \param gauss_prec Precision of the diffusion process.
       \param interpolation_type Interpolation scheme.
         Can be &lt;tt&gt;{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }&lt;/tt&gt;.
       \param is_fast_approx Tells if a fast approximation of the gaussian function is used or not.
     **/
    CImg&lt;T&gt;&amp; blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.6f,
                              const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f, const float da=30,
                              const float gauss_prec=2, const unsigned int interpolation_type=0,
                              const bool is_fast_approx=true) ;

//! Blur image anisotropically, in an edge-preserving way \newinstance.
    CImg&lt;Tfloat&gt; get_blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.6f,
                                      const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,
                                      const float da=30, const float gauss_prec=2,
                                      const unsigned int interpolation_type=0,
                                      const bool is_fast_approx=true) const ;

//! Blur image, with the joint bilateral filter.
    /**
       \param guide Image used to model the smoothing weights.
       \param sigma_x Amount of blur along the X-axis.
       \param sigma_y Amount of blur along the Y-axis.
       \param sigma_z Amount of blur along the Z-axis.
       \param sigma_r Amount of blur along the value axis.
       \param sampling_x Amount of downsampling along the X-axis used for the approximation.
         Defaults (0) to sigma_x.
       \param sampling_y Amount of downsampling along the Y-axis used for the approximation.
         Defaults (0) to sigma_y.
       \param sampling_z Amount of downsampling along the Z-axis used for the approximation.
         Defaults (0) to sigma_z.
       \param sampling_r Amount of downsampling along the value axis used for the approximation.
         Defaults (0) to sigma_r.
       \note This algorithm uses the optimisation technique proposed by S. Paris and F. Durand, in ECCV'2006
       (extended for 3D volumetric images).
       It is based on the reference implementation http://people.csail.mit.edu/jiawen/software/bilateralFilter.m
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; blur_bilateral(const CImg&lt;t&gt;&amp; guide,
                            const float sigma_x, const float sigma_y,
                            const float sigma_z, const float sigma_r,
                            const float sampling_x, const float sampling_y,
                            const float sampling_z, const float sampling_r) ;

//! Blur image, with the joint bilateral filter \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_blur_bilateral(const CImg&lt;t&gt;&amp; guide,
                                    const float sigma_x, const float sigma_y,
                                    const float sigma_z, const float sigma_r,
                                    const float sampling_x, const float sampling_y,
                                    const float sampling_z, const float sampling_r) const ;

//! Blur image using the joint bilateral filter.
    /**
       \param guide Image used to model the smoothing weights.
       \param sigma_s Amount of blur along the XYZ-axes.
       \param sigma_r Amount of blur along the value axis.
       \param sampling_s Amount of downsampling along the XYZ-axes used for the approximation. Defaults to sigma_s.
       \param sampling_r Amount of downsampling along the value axis used for the approximation. Defaults to sigma_r.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; blur_bilateral(const CImg&lt;t&gt;&amp; guide,
                            const float sigma_s, const float sigma_r,
                            const float sampling_s=0, const float sampling_r=0) ;

//! Blur image using the bilateral filter \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_blur_bilateral(const CImg&lt;t&gt;&amp; guide,
                                    const float sigma_s, const float sigma_r,
                                    const float sampling_s=0, const float sampling_r=0) const ;

//! Blur image with a box filter.
    /**
       \param boxsize_x Size of the box window, along the X-axis (can be subpixel).
       \param boxsize_y Size of the box window, along the Y-axis (can be subpixel).
       \param boxsize_z Size of the box window, along the Z-axis (can be subpixel).
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ false=dirichlet | true=neumann }&lt;/tt&gt;.
       \param nb_iter Number of filter iterations.
       \note
       - This is a recursive algorithm, not depending on the values of the box kernel size.
       \see blur().
    **/
    CImg&lt;T&gt;&amp; blur_box(const float boxsize_x, const float boxsize_y, const float boxsize_z,
                      const bool boundary_conditions=true,
                      const unsigned int nb_iter=1) ;

//! Blur image with a box filter \newinstance.
    CImg&lt;Tfloat&gt; get_blur_box(const float boxsize_x, const float boxsize_y, const float boxsize_z,
                              const bool boundary_conditions=true) const ;

//! Blur image with a box filter.
    /**
       \param boxsize Size of the box window (can be subpixel).
       \param boundary_conditions Boundary conditions. Can be &lt;tt&gt;{ 0=dirichlet | 1=neumann }&lt;/tt&gt;.a
       \see deriche(), vanvliet().
    **/
    CImg&lt;T&gt;&amp; blur_box(const float boxsize, const bool boundary_conditions=true) ;

//! Blur image with a box filter \newinstance.
    CImg&lt;Tfloat&gt; get_blur_box(const float boxsize, const bool boundary_conditions=true) const ;

//! Blur image, with the image guided filter.
    /**
       \param guide Image used to guide the smoothing process.
       \param radius Spatial radius. If negative, it is expressed as a percentage of the largest image size.
       \param regularization Regularization parameter.
                             If negative, it is expressed as a percentage of the guide value range.
       \note This method implements the filtering algorithm described in:
       He, Kaiming; Sun, Jian; Tang, Xiaoou, "Guided Image Filtering," Pattern Analysis and Machine Intelligence,
       IEEE Transactions on , vol.35, no.6, pp.1397,1409, June 2013
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; blur_guided(const CImg&lt;t&gt;&amp; guide, const float radius, const float regularization) ;

//! Blur image, with the image guided filter \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_blur_guided(const CImg&lt;t&gt;&amp; guide, const float radius, const float regularization) const ;

//! Blur image using patch-based space.
    /**
       \param guide Image used to model the smoothing weights.
       \param sigma_s Amount of blur along the XYZ-axes.
       \param sigma_r Amount of blur along the value axis.
       \param patch_size Size of the patches.
       \param lookup_size Size of the window to search similar patches.
       \param smoothness Smoothness for the patch comparison.
       \param is_fast_approx Tells if a fast approximation of the gaussian function is used or not.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; blur_patch(const CImg&lt;t&gt;&amp; guide,
                        const float sigma_s, const float sigma_r, const unsigned int patch_size=3,
                        const unsigned int lookup_size=4, const float smoothness=0, const bool is_fast_approx=true) ;

//! Blur image using patch-based space \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_blur_patch(const CImg&lt;t&gt;&amp; guide,
                                const float sigma_s, const float sigma_r, const unsigned int patch_size=3,
                                const unsigned int lookup_size=4, const float smoothness=0,
                                const bool is_fast_approx=true) const ;

//! Blur image using patch-based space \simplification.
    CImg&lt;T&gt;&amp; blur_patch(const float sigma_s, const float sigma_r, const unsigned int patch_size=3,
                        const unsigned int lookup_size=4, const float smoothness=0, const bool is_fast_approx=true) ;

//! Blur image using patch-based space \simplification \newinstance.
    CImg&lt;Tfloat&gt; get_blur_patch(const float sigma_s, const float sigma_r, const unsigned int patch_size=3,
                                const unsigned int lookup_size=4, const float smoothness=0,
                                const bool is_fast_approx=true) const ;

//! Blur image with the median filter.
    /**
       \param n Size of the median filter.
       \param threshold Threshold used to discard pixels too far from the current pixel value in the median computation.
    **/
    CImg&lt;T&gt;&amp; blur_median(const unsigned int n, const float threshold=0) ;

//! Blur image with the median filter \newinstance.
    CImg&lt;T&gt; get_blur_median(const unsigned int n, const float threshold=0) const ;

//! Sharpen image.
    /**
       \param amplitude Sharpening amplitude
       \param sharpen_type Select sharpening method. Can be &lt;tt&gt;{ false=inverse diffusion | true=shock filters }&lt;/tt&gt;.
       \param edge Edge threshold (shock filters only).
       \param alpha Gradient smoothness (shock filters only).
       \param sigma Tensor smoothness (shock filters only).
    **/
    CImg&lt;T&gt;&amp; sharpen(const float amplitude, const bool sharpen_type=false, const float edge=1,
                     const float alpha=0, const float sigma=0) ;

//! Sharpen image \newinstance.
    CImg&lt;T&gt; get_sharpen(const float amplitude, const bool sharpen_type=false, const float edge=1,
                        const float alpha=0, const float sigma=0) const ;

//! Return image gradient.
    /**
       \param axes Axes considered for the gradient computation, as a C-string (e.g "xy").
       \param scheme = Numerical scheme used for the gradient computation:
       - -1 = Backward finite differences
       - 0 = Centered finite differences (default)
       - 1 = Forward finite differences
       - 2 = Using Sobel kernels
       - 3 = Using rotation invariant kernels
       - 4 = Using Deriche recursive filter.
       - 5 = Using Van Vliet recursive filter.
    **/
    CImgList&lt;Tfloat&gt; get_gradient(const char *const axes=0, const int scheme=0) const ;

//! Return image hessian.
    /**
       \param axes Axes considered for the hessian computation, as a C-string (e.g "xy").
    **/
    CImgList&lt;Tfloat&gt; get_hessian(const char *const axes=0) const ;

//! Compute image Laplacian.
    CImg&lt;T&gt;&amp; laplacian() ;

//! Compute image Laplacian \newinstance.
    CImg&lt;Tfloat&gt; get_laplacian() const ;

//! Compute the structure tensor field of an image.
    /**
       \param is_fwbw_scheme scheme. Can be &lt;tt&gt;{ false=centered | true=forward-backward }&lt;/tt&gt;
    **/
    CImg&lt;T&gt;&amp; structure_tensors(const bool is_fwbw_scheme=false) ;

//! Compute the structure tensor field of an image \newinstance.
    CImg&lt;Tfloat&gt; get_structure_tensors(const bool is_fwbw_scheme=false) const ;

//! Compute field of diffusion tensors for edge-preserving smoothing.
    /**
       \param sharpness Sharpness
       \param anisotropy Anisotropy
       \param alpha Standard deviation of the gradient blur.
       \param sigma Standard deviation of the structure tensor blur.
       \param is_sqrt Tells if the square root of the tensor field is computed instead.
    **/
    CImg&lt;T&gt;&amp; diffusion_tensors(const float sharpness=0.7f, const float anisotropy=0.6f,
                               const float alpha=0.6f, const float sigma=1.1f, const bool is_sqrt=false) ;

//! Compute field of diffusion tensors for edge-preserving smoothing \newinstance.
    CImg&lt;Tfloat&gt; get_diffusion_tensors(const float sharpness=0.7f, const float anisotropy=0.6f,
                                       const float alpha=0.6f, const float sigma=1.1f, const bool is_sqrt=false) const ;

//! Estimate displacement field between two images.
    /**
       \param source Reference image.
       \param smoothness Smoothness of estimated displacement field.
       \param precision Precision required for algorithm convergence.
       \param nb_scales Number of scales used to estimate the displacement field.
       \param iteration_max Maximum number of iterations allowed for one scale.
       \param is_backward If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).
       \param guide Image used as the initial correspondence estimate for the algorithm.
       'guide' may have a last channel with boolean values (0=false | other=true) that
       tells for each pixel if its correspondence vector is constrained to its initial value (constraint mask).
    **/
    CImg&lt;T&gt;&amp; displacement(const CImg&lt;T&gt;&amp; source, const float smoothness=0.1f, const float precision=5.f,
                          const unsigned int nb_scales=0, const unsigned int iteration_max=10000,
                          const bool is_backward=false,
                          const CImg&lt;floatT&gt;&amp; guide=CImg&lt;floatT&gt;::const_empty()) ;

//! Estimate displacement field between two images \newinstance.
    CImg&lt;floatT&gt; get_displacement(const CImg&lt;T&gt;&amp; source,
                                  const float smoothness=0.1f, const float precision=5.f,
                                  const unsigned int nb_scales=0, const unsigned int iteration_max=10000,
                                  const bool is_backward=false,
                                  const CImg&lt;floatT&gt;&amp; guide=CImg&lt;floatT&gt;::const_empty()) const ;

//! Compute correspondence map between two images, using a patch-matching algorithm.
    /**
        \param patch_image The image containing the reference patches to match with the instance image.
        \param patch_width Width of the patch used for matching.
        \param patch_height Height of the patch used for matching.
        \param patch_depth Depth of the patch used for matching.
        \param nb_iterations Number of patch-match iterations.
        \param nb_randoms Number of randomization attempts (per pixel).
        \param patch_penalization Penalization factor in score related patch occurrences.
               if negative, also tells that identity result is not avoided.
        \param guide Image used as the initial correspondence estimate for the algorithm.
          'guide' may have a last channel with boolean values (0=false | other=true) that
          tells for each pixel if its correspondence vector is constrained to its initial value (constraint mask).
        \param[out] matching_score Returned as the image of matching scores.
    **/
    template&lt;typename t1, typename t2&gt;
    CImg&lt;T&gt;&amp; matchpatch(const CImg&lt;T&gt;&amp; patch_image,
                        const unsigned int patch_width,
                        const unsigned int patch_height,
                        const unsigned int patch_depth,
                        const unsigned int nb_iterations,
                        const unsigned int nb_randoms,
                        const float patch_penalization,
                        const CImg&lt;t1&gt; &amp;guide,
                        CImg&lt;t2&gt; &amp;matching_score) ;

//! Compute correspondence map between two images, using the patch-match algorithm \newinstance.
    template&lt;typename t1, typename t2&gt;
    CImg&lt;intT&gt; get_matchpatch(const CImg&lt;T&gt;&amp; patch_image,
                              const unsigned int patch_width,
                              const unsigned int patch_height,
                              const unsigned int patch_depth,
                              const unsigned int nb_iterations,
                              const unsigned int nb_randoms,
                              const float patch_penalization,
                              const CImg&lt;t1&gt; &amp;guide,
                              CImg&lt;t2&gt; &amp;matching_score) const ;

//! Compute correspondence map between two images, using the patch-match algorithm \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; matchpatch(const CImg&lt;T&gt;&amp; patch_image,
                        const unsigned int patch_width,
                        const unsigned int patch_height,
                        const unsigned int patch_depth,
                        const unsigned int nb_iterations=5,
                        const unsigned int nb_randoms=5,
                        const float patch_penalization=0,
                        const CImg&lt;t&gt; &amp;guide=CImg&lt;t&gt;::const_empty()) ;

//! Compute correspondence map between two images, using the patch-match algorithm \overloading.
    template&lt;typename t&gt;
    CImg&lt;intT&gt; get_matchpatch(const CImg&lt;T&gt;&amp; patch_image,
                              const unsigned int patch_width,
                              const unsigned int patch_height,
                              const unsigned int patch_depth,
                              const unsigned int nb_iterations=5,
                              const unsigned int nb_randoms=5,
                              const float patch_penalization=0,
                              const CImg&lt;t&gt; &amp;guide=CImg&lt;t&gt;::const_empty()) const ;

//! Compute Euclidean distance function to a specified value.
    /**
        \param value Reference value.
        \param metric Type of metric. Can be &lt;tt&gt;{ 0=Chebyshev | 1=Manhattan | 2=Euclidean | 3=Squared-euclidean }&lt;/tt&gt;.
        \note
        The distance transform implementation has been submitted by A. Meijster, and implements
        the article 'W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink,
                     "A general algorithm for computing distance transforms in linear time.",
                     In: Mathematical Morphology and its Applications to Image and Signal Processing,
                     J. Goutsias, L. Vincent, and D.S. Bloomberg (eds.), Kluwer, 2000, pp. 331-340.'
         The submitted code has then been modified to fit CImg coding style and constraints.
    **/
    CImg&lt;T&gt;&amp; distance(const T&amp; value, const unsigned int metric=2) ;

//! Compute distance to a specified value \newinstance.
    CImg&lt;Tfloat&gt; get_distance(const T&amp; value, const unsigned int metric=2) const ;

//! Compute chamfer distance to a specified value, with a custom metric.
    /**
       \param value Reference value.
       \param metric_mask Metric mask.
       \note The algorithm code has been initially proposed by A. Meijster, and modified by D. TschumperlÃ©.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; distance(const T&amp; value, const CImg&lt;t&gt;&amp; metric_mask) ;

//! Compute chamfer distance to a specified value, with a custom metric \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_distance(const T&amp; value, const CImg&lt;t&gt;&amp; metric_mask) const ;

//! Compute distance to a specified value, according to a custom metric (use dijkstra algorithm).
    /**
       \param value Reference value.
       \param metric Field of distance potentials.
       \param is_high_connectivity Tells if the algorithm uses low or high connectivity.
       \param[out] return_path An image containing the nodes of the minimal path.
     **/
    template&lt;typename t, typename to&gt;
    CImg&lt;T&gt;&amp; distance_dijkstra(const T&amp; value, const CImg&lt;t&gt;&amp; metric, const bool is_high_connectivity,
                               CImg&lt;to&gt;&amp; return_path) ;

//! Compute distance map to a specified value, according to a custom metric (use dijkstra algorithm) \newinstance.
    template&lt;typename t, typename to&gt;
    CImg&lt;typename cimg::superset&lt;t,long&gt;::type&gt;
    get_distance_dijkstra(const T&amp; value, const CImg&lt;t&gt;&amp; metric, const bool is_high_connectivity,
                          CImg&lt;to&gt;&amp; return_path) const ;

//! Compute distance map to a specified value, according to a custom metric (use dijkstra algorithm). \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; distance_dijkstra(const T&amp; value, const CImg&lt;t&gt;&amp; metric,
                               const bool is_high_connectivity=false) ;

//! Compute distance map to a specified value, according to a custom metric (use dijkstra algorithm). \newinstance.
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_distance_dijkstra(const T&amp; value, const CImg&lt;t&gt;&amp; metric,
                                       const bool is_high_connectivity=false) const ;

//! Compute distance map to one source point, according to a custom metric (use fast marching algorithm).
    /**
       \param value Reference value.
       \param metric Field of distance potentials.
     **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; distance_eikonal(const T&amp; value, const CImg&lt;t&gt;&amp; metric) ;

//! Compute distance map to one source point, according to a custom metric (use fast marching algorithm).
    template&lt;typename t&gt;
    CImg&lt;Tfloat&gt; get_distance_eikonal(const T&amp; value, const CImg&lt;t&gt;&amp; metric) const ;

//! Compute distance function to 0-valued isophotes, using the Eikonal PDE.
    /**
       \param nb_iterations Number of PDE iterations.
       \param band_size Size of the narrow band.
       \param time_step Time step of the PDE iterations.
    **/
    CImg&lt;T&gt;&amp; distance_eikonal(const unsigned int nb_iterations, const float band_size=0, const float time_step=0.5f) ;

//! Compute distance function to 0-valued isophotes, using the Eikonal PDE \newinstance.
    CImg&lt;Tfloat&gt; get_distance_eikonal(const unsigned int nb_iterations, const float band_size=0,
                                      const float time_step=0.5f) const ;

//! Compute Haar multiscale wavelet transform.
    /**
       \param axis Axis considered for the transform.
       \param invert Set inverse of direct transform.
       \param nb_scales Number of scales used for the transform.
    **/
    CImg&lt;T&gt;&amp; haar(const char axis, const bool invert=false, const unsigned int nb_scales=1) ;

//! Compute Haar multiscale wavelet transform \newinstance.
    CImg&lt;Tfloat&gt; get_haar(const char axis, const bool invert=false, const unsigned int nb_scales=1) const ;

//! Compute Haar multiscale wavelet transform \overloading.
    /**
       \param invert Set inverse of direct transform.
       \param nb_scales Number of scales used for the transform.
    **/
    CImg&lt;T&gt;&amp; haar(const bool invert=false, const unsigned int nb_scales=1) ;

//! Compute Haar multiscale wavelet transform \newinstance.
    CImg&lt;Tfloat&gt; get_haar(const bool invert=false, const unsigned int nb_scales=1) const ;

//! Compute 1D Fast Fourier Transform, along a specified axis.
    /**
       \param axis Axis along which the FFT is computed.
       \param is_inverse Tells if the forward (\c false) or inverse (\c true) FFT is computed.
    **/
    CImgList&lt;Tfloat&gt; get_FFT(const char axis, const bool is_inverse=false) const ;

//! Compute n-D Fast Fourier Transform.
    /**
      \param is_inverse Tells if the forward (\c false) or inverse (\c true) FFT is computed.
    **/
    CImgList&lt;Tfloat&gt; get_FFT(const bool is_inverse=false) const ;

//! Compute 1D Fast Fourier Transform, along a specified axis.
    /**
       \param[in,out] real Real part of the pixel values.
       \param[in,out] imag Imaginary part of the pixel values.
       \param axis Axis along which the FFT is computed.
       \param is_inverse Tells if the forward (\c false) or inverse (\c true) FFT is computed.
    **/
    static void FFT(CImg&lt;T&gt;&amp; real, CImg&lt;T&gt;&amp; imag, const char axis, const bool is_inverse=false,
                    const unsigned int nb_threads=0) ;

//! Compute n-D Fast Fourier Transform.
    /**
       \param[in,out] real Real part of the pixel values.
       \param[in,out] imag Imaginary part of the pixel values.
       \param is_inverse Tells if the forward (\c false) or inverse (\c true) FFT is computed.
       \param nb_threads Number of parallel threads used for the computation.
         Use \c 0 to set this to the number of available cpus.
    **/
    static void FFT(CImg&lt;T&gt;&amp; real, CImg&lt;T&gt;&amp; imag, const bool is_inverse=false,
                    const unsigned int nb_threads=0) ;

//! \name 3D Objects Management
    //@;

//! Rotate 3D object's vertices.
    /**
       \param x X-coordinate of the rotation axis, or first quaternion coordinate.
       \param y Y-coordinate of the rotation axis, or second quaternion coordinate.
       \param z Z-coordinate of the rotation axis, or second quaternion coordinate.
       \param w Angle of the rotation axis (in degree), or fourth quaternion coordinate.
       \param is_quaternion Tell is the four arguments denotes a set { axis + angle } or a quaternion (x,y,z,w).
    **/
    CImg&lt;T&gt;&amp; rotate_object3d(const float x, const float y, const float z, const float w,
                             const bool is_quaternion=false) ;

//! Shift 3D object's vertices.
    /**
       \param tx X-coordinate of the 3D displacement vector.
       \param ty Y-coordinate of the 3D displacement vector.
       \param tz Z-coordinate of the 3D displacement vector.
    **/
    CImg&lt;T&gt;&amp; shift_object3d(const float tx, const float ty=0, const float tz=0) ;

//! Shift 3D object's vertices \newinstance.
    CImg&lt;Tfloat&gt; get_shift_object3d(const float tx, const float ty=0, const float tz=0) const ;

//! Shift 3D object's vertices, so that it becomes centered.
    /**
       \note The object center is computed as its barycenter.
    **/
    CImg&lt;T&gt;&amp; shift_object3d() ;

//! Shift 3D object's vertices, so that it becomes centered \newinstance.
    CImg&lt;Tfloat&gt; get_shift_object3d() const ;

//! Resize 3D object.
    /**
       \param sx Width of the 3D object's bounding box.
       \param sy Height of the 3D object's bounding box.
       \param sz Depth of the 3D object's bounding box.
    **/
    CImg&lt;T&gt;&amp; resize_object3d(const float sx, const float sy=-100, const float sz=-100) ;

//! Resize 3D object \newinstance.
    CImg&lt;Tfloat&gt; get_resize_object3d(const float sx, const float sy=-100, const float sz=-100) const ;

//! Resize 3D object to unit size.
    CImg&lt;T&gt; resize_object3d() ;

//! Resize 3D object to unit size \newinstance.
    CImg&lt;Tfloat&gt; get_resize_object3d() const ;

//! Merge two 3D objects together.
    /**
       \param[in,out] primitives Primitives data of the current 3D object.
       \param obj_vertices Vertices data of the additional 3D object.
       \param obj_primitives Primitives data of the additional 3D object.
    **/
    template&lt;typename tf, typename tp, typename tff&gt;
    CImg&lt;T&gt;&amp; append_object3d(CImgList&lt;tf&gt;&amp; primitives, const CImg&lt;tp&gt;&amp; obj_vertices,
                             const CImgList&lt;tff&gt;&amp; obj_primitives) ;

//! Texturize primitives of a 3D object.
    /**
       \param[in,out] primitives Primitives data of the 3D object.
       \param[in,out] colors Colors data of the 3D object.
       \param texture Texture image to map to 3D object.
       \param coords Texture-mapping coordinates.
    **/
    template&lt;typename tp, typename tc, typename tt, typename tx&gt;
    const CImg&lt;T&gt;&amp; texturize_object3d(CImgList&lt;tp&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors,
                                      const CImg&lt;tt&gt;&amp; texture, const CImg&lt;tx&gt;&amp; coords=CImg&lt;tx&gt;::const_empty()) const ;

//! Generate a 3D elevation of the image instance.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param[out] colors The returned list of the 3D object colors.
       \param elevation The input elevation map.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");
       CImgList&lt;unsigned int&gt; faces3d;
       CImgList&lt;unsigned char&gt; colors3d;
       const CImg&lt;float&gt; points3d = img.get_elevation3d(faces3d,colors3d,img.get_norm()*0.2);
       CImg&lt;unsigned char&gt;().display_object3d("Elevation3d",points3d,faces3d,colors3d);
       \endcode
       \image html ref_elevation3d.jpg
    **/
    template&lt;typename tf, typename tc, typename te&gt;
    CImg&lt;floatT&gt; get_elevation3d(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors, const CImg&lt;te&gt;&amp; elevation) const ;

//! Generate the 3D projection planes of the image instance.
    /**
       \param[out] primitives Primitives data of the returned 3D object.
       \param[out] colors Colors data of the returned 3D object.
       \param x0 X-coordinate of the projection point.
       \param y0 Y-coordinate of the projection point.
       \param z0 Z-coordinate of the projection point.
       \param normalize_colors Tells if the created textures have normalized colors.
    **/
    template&lt;typename tf, typename tc&gt;
    CImg&lt;floatT&gt; get_projections3d(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors,
                                   const unsigned int x0, const unsigned int y0, const unsigned int z0,
                                   const bool normalize_colors=false) const ;

//! Generate a isoline of the image instance as a 3D object.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param isovalue The returned list of the 3D object colors.
       \param size_x The number of subdivisions along the X-axis.
       \param size_y The number of subdisivions along the Y-axis.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       const CImg&lt;float&gt; img("reference.jpg");
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = img.get_isoline3d(faces3d,100);
       CImg&lt;unsigned char&gt;().display_object3d("Isoline3d",points3d,faces3d,colors3d);
       \endcode
       \image html ref_isoline3d.jpg
    **/
    template&lt;typename tf&gt;
    CImg&lt;floatT&gt; get_isoline3d(CImgList&lt;tf&gt;&amp; primitives, const float isovalue,
                               const int size_x=-100, const int size_y=-100) const ;

//! Compute isolines of a function, as a 3D object.
    /**
       \param[out] primitives Primitives data of the resulting 3D object.
       \param func Elevation functor. Must have &lt;tt&gt;operator()(x,y)&lt;/tt&gt; defined.
       \param isovalue Isovalue to extract from function.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param size_x Resolution of the function along the X-axis.
       \param size_y Resolution of the function along the Y-axis.
       \note Use the marching squares algorithm for extracting the isolines.
     **/
    template&lt;typename tf, typename tfunc&gt;
    static CImg&lt;floatT&gt; isoline3d(CImgList&lt;tf&gt;&amp; primitives, const tfunc&amp; func, const float isovalue,
                                  const float x0, const float y0, const float x1, const float y1,
                                  const int size_x=256, const int size_y=256) ;

//! Compute isolines of a function, as a 3D object.
    /**
       \param[out] add_vertex : Functor with operator()(x,y,z) defined for adding new vertex.
       \param[out] add_segment : Functor with operator()(i,j) defined for adding new segment.
       \param func Elevation function. Is of type &lt;tt&gt;float (*func)(const float x,const float y)&lt;/tt&gt;.
       \param isovalue Isovalue to extract from function.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param size_x Resolution of the function along the X-axis.
       \param size_y Resolution of the function along the Y-axis.
       \note Use the marching squares algorithm for extracting the isolines.
     **/
    template&lt;typename tv, typename tf, typename tfunc&gt;
    static void isoline3d(tv&amp; add_vertex, tf&amp; add_segment, const tfunc&amp; func, const float isovalue,
                          const float x0, const float y0, const float x1, const float y1,
                          const int size_x, const int size_y) ;

//! Compute isolines of a function, as a 3D object \overloading.
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; isoline3d(CImgList&lt;tf&gt;&amp; primitives, const char *const expression, const float isovalue,
                                  const float x0, const float y0, const float x1, const float y1,
                                  const int size_x=256, const int size_y=256) ;

//! Generate an isosurface of the image instance as a 3D object.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param isovalue The returned list of the 3D object colors.
       \param size_x Number of subdivisions along the X-axis.
       \param size_y Number of subdisivions along the Y-axis.
       \param size_z Number of subdisivions along the Z-axis.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       const CImg&lt;float&gt; img = CImg&lt;unsigned char&gt;("reference.jpg").resize(-100,-100,20);
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = img.get_isosurface3d(faces3d,100);
       CImg&lt;unsigned char&gt;().display_object3d("Isosurface3d",points3d,faces3d,colors3d);
       \endcode
       \image html ref_isosurface3d.jpg
    **/
    template&lt;typename tf&gt;
    CImg&lt;floatT&gt; get_isosurface3d(CImgList&lt;tf&gt;&amp; primitives, const float isovalue,
                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const ;

//! Compute isosurface of a function, as a 3D object.
    /**
       \param[out] primitives Primitives data of the resulting 3D object.
       \param func Implicit function. Is of type &lt;tt&gt;float (*func)(const float x, const float y, const float z)&lt;/tt&gt;.
       \param isovalue Isovalue to extract.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param z0 Z-coordinate of the starting point.
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param z1 Z-coordinate of the ending point.
       \param size_x Resolution of the elevation function along the X-axis.
       \param size_y Resolution of the elevation function along the Y-axis.
       \param size_z Resolution of the elevation function along the Z-axis.
       \note Use the marching cubes algorithm for extracting the isosurface.
     **/
    template&lt;typename tf, typename tfunc&gt;
    static CImg&lt;floatT&gt; isosurface3d(CImgList&lt;tf&gt;&amp; primitives, const tfunc&amp; func, const float isovalue,
                                     const float x0, const float y0, const float z0,
                                     const float x1, const float y1, const float z1,
                                     const int size_x=32, const int size_y=32, const int size_z=32) ;

//! Compute isosurface of a function, as a 3D object.
    /**
       \param[out] add_vertex : Functor with operator()(x,y,z) defined for adding new vertex.
       \param[out] add_triangle : Functor with operator()(i,j) defined for adding new segment.
       \param func Implicit function. Is of type &lt;tt&gt;float (*func)(const float x, const float y, const float z)&lt;/tt&gt;.
       \param isovalue Isovalue to extract.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param z0 Z-coordinate of the starting point.
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param z1 Z-coordinate of the ending point.
       \param size_x Resolution of the elevation function along the X-axis.
       \param size_y Resolution of the elevation function along the Y-axis.
       \param size_z Resolution of the elevation function along the Z-axis.
       \note Use the marching cubes algorithm for extracting the isosurface.
     **/
    template&lt;typename tv, typename tf, typename tfunc&gt;
    static void isosurface3d(tv&amp; add_vertex, tf&amp; add_triangle, const tfunc&amp; func, const float isovalue,
                             const float x0, const float y0, const float z0,
                             const float x1, const float y1, const float z1,
                             const int size_x, const int size_y, const int size_z) ;

//! Compute isosurface of a function, as a 3D object \overloading.
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; isosurface3d(CImgList&lt;tf&gt;&amp; primitives, const char *const expression, const float isovalue,
                                     const float x0, const float y0, const float z0,
                                     const float x1, const float y1, const float z1,
                                     const int dx=32, const int dy=32, const int dz=32) ;

//! Compute 3D elevation of a function as a 3D object.
    /**
       \param[out] primitives Primitives data of the resulting 3D object.
       \param func Elevation function. Is of type &lt;tt&gt;float (*func)(const float x,const float y)&lt;/tt&gt;.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param size_x Resolution of the function along the X-axis.
       \param size_y Resolution of the function along the Y-axis.
    **/
    template&lt;typename tf, typename tfunc&gt;
    static CImg&lt;floatT&gt; elevation3d(CImgList&lt;tf&gt;&amp; primitives, const tfunc&amp; func,
                                    const float x0, const float y0, const float x1, const float y1,
                                    const int size_x=256, const int size_y=256) ;

//! Compute 3D elevation of a function, as a 3D object \overloading.
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; elevation3d(CImgList&lt;tf&gt;&amp; primitives, const char *const expression,
                                    const float x0, const float y0, const float x1, const float y1,
                                    const int size_x=256, const int size_y=256) ;

//! Generate a 3D box object.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param size_x The width of the box (dimension along the X-axis).
       \param size_y The height of the box (dimension along the Y-axis).
       \param size_z The depth of the box (dimension along the Z-axis).
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::box3d(faces3d,10,20,30);
       CImg&lt;unsigned char&gt;().display_object3d("Box3d",points3d,faces3d);
       \endcode
       \image html ref_box3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; box3d(CImgList&lt;tf&gt;&amp; primitives,
                              const float size_x=200, const float size_y=100, const float size_z=100) ;

//! Generate a 3D cone.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param radius The radius of the cone basis.
       \param size_z The cone's height.
       \param subdivisions The number of basis angular subdivisions.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::cone3d(faces3d,50);
       CImg&lt;unsigned char&gt;().display_object3d("Cone3d",points3d,faces3d);
       \endcode
       \image html ref_cone3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; cone3d(CImgList&lt;tf&gt;&amp; primitives,
                               const float radius=50, const float size_z=100, const unsigned int subdivisions=24) ;

//! Generate a 3D cylinder.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param radius The radius of the cylinder basis.
       \param size_z The cylinder's height.
       \param subdivisions The number of basis angular subdivisions.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::cylinder3d(faces3d,50);
       CImg&lt;unsigned char&gt;().display_object3d("Cylinder3d",points3d,faces3d);
       \endcode
       \image html ref_cylinder3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; cylinder3d(CImgList&lt;tf&gt;&amp; primitives,
                                   const float radius=50, const float size_z=100, const unsigned int subdivisions=24) ;

//! Generate a 3D torus.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param radius1 The large radius.
       \param radius2 The small radius.
       \param subdivisions1 The number of angular subdivisions for the large radius.
       \param subdivisions2 The number of angular subdivisions for the small radius.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::torus3d(faces3d,20,4);
       CImg&lt;unsigned char&gt;().display_object3d("Torus3d",points3d,faces3d);
       \endcode
       \image html ref_torus3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; torus3d(CImgList&lt;tf&gt;&amp; primitives,
                                const float radius1=100, const float radius2=30,
                                const unsigned int subdivisions1=24, const unsigned int subdivisions2=12) ;

//! Generate a 3D XY-plane.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param size_x The width of the plane (dimension along the X-axis).
       \param size_y The height of the plane (dimensions along the Y-axis).
       \param subdivisions_x The number of planar subdivisions along the X-axis.
       \param subdivisions_y The number of planar subdivisions along the Y-axis.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::plane3d(faces3d,100,50);
       CImg&lt;unsigned char&gt;().display_object3d("Plane3d",points3d,faces3d);
       \endcode
       \image html ref_plane3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; plane3d(CImgList&lt;tf&gt;&amp; primitives,
                                const float size_x=100, const float size_y=100,
                                const unsigned int subdivisions_x=10, const unsigned int subdivisions_y=10) ;

//! Generate a 3D sphere.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param radius The radius of the sphere (dimension along the X-axis).
       \param subdivisions The number of recursive subdivisions from an initial icosahedron.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; points3d = CImg&lt;float&gt;::sphere3d(faces3d,100,4);
       CImg&lt;unsigned char&gt;().display_object3d("Sphere3d",points3d,faces3d);
       \endcode
       \image html ref_sphere3d.jpg
    **/
    template&lt;typename tf&gt;
    static CImg&lt;floatT&gt; sphere3d(CImgList&lt;tf&gt;&amp; primitives,
                                 const float radius=50, const unsigned int subdivisions=3) ;

//! Generate a 3D ellipsoid.
    /**
       \param[out] primitives The returned list of the 3D object primitives
                              (template type \e tf should be at least \e unsigned \e int).
       \param tensor The tensor which gives the shape and size of the ellipsoid.
       \param subdivisions The number of recursive subdivisions from an initial stretched icosahedron.
       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg&lt;float&gt; image (0&lt;=i&lt;=N - 1).
       \par Example
       \code
       CImgList&lt;unsigned int&gt; faces3d;
       const CImg&lt;float&gt; tensor = CImg&lt;float&gt;::diagonal(10,7,3),
                         points3d = CImg&lt;float&gt;::ellipsoid3d(faces3d,tensor,4);
       CImg&lt;unsigned char&gt;().display_object3d("Ellipsoid3d",points3d,faces3d);
       \endcode
       \image html ref_ellipsoid3d.jpg
    **/
    template&lt;typename tf, typename t&gt;
    static CImg&lt;floatT&gt; ellipsoid3d(CImgList&lt;tf&gt;&amp; primitives,
                                    const CImg&lt;t&gt;&amp; tensor, const unsigned int subdivisions=3) ;

//! Convert 3D object into a CImg3d representation.
    /**
       \param primitives Primitives data of the 3D object.
       \param colors Colors data of the 3D object.
       \param opacities Opacities data of the 3D object.
       \param full_check Tells if full checking of the 3D object must be performed.
    **/
    template&lt;typename tp, typename tc, typename to&gt;
    CImg&lt;T&gt;&amp; object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                              const CImgList&lt;tc&gt;&amp; colors,
                              const to&amp; opacities,
                              const bool full_check=true) ;

//! Convert 3D object into a CImg3d representation \overloading.
    template&lt;typename tp, typename tc&gt;
    CImg&lt;T&gt;&amp; object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                              const CImgList&lt;tc&gt;&amp; colors,
                              const bool full_check=true) ;

//! Convert 3D object into a CImg3d representation \overloading.
    template&lt;typename tp&gt;
    CImg&lt;T&gt;&amp; object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                              const bool full_check=true) ;

//! Convert 3D object into a CImg3d representation \overloading.
    CImg&lt;T&gt;&amp; object3dtoCImg3d(const bool full_check=true) ;

//! Convert 3D object into a CImg3d representation \newinstance.
    template&lt;typename tp, typename tc, typename to&gt;
    CImg&lt;floatT&gt; get_object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                                      const CImgList&lt;tc&gt;&amp; colors,
                                      const to&amp; opacities,
                                      const bool full_check=true) const ;

//! Convert 3D object into a CImg3d representation \overloading.
    template&lt;typename tp, typename tc&gt;
    CImg&lt;floatT&gt; get_object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                                      const CImgList&lt;tc&gt;&amp; colors,
                                      const bool full_check=true) const ;

//! Convert 3D object into a CImg3d representation \overloading.
    template&lt;typename tp&gt;
    CImg&lt;floatT&gt; get_object3dtoCImg3d(const CImgList&lt;tp&gt;&amp; primitives,
                                      const bool full_check=true) const ;

//! Convert 3D object into a CImg3d representation \overloading.
    CImg&lt;floatT&gt; get_object3dtoCImg3d(const bool full_check=true) const ;

//! Convert CImg3d representation into a 3D object.
    /**
       \param[out] primitives Primitives data of the 3D object.
       \param[out] colors Colors data of the 3D object.
       \param[out] opacities Opacities data of the 3D object.
       \param full_check Tells if full checking of the 3D object must be performed.
    **/
    template&lt;typename tp, typename tc, typename to&gt;
    CImg&lt;T&gt;&amp; CImg3dtoobject3d(CImgList&lt;tp&gt;&amp; primitives,
                              CImgList&lt;tc&gt;&amp; colors,
                              CImgList&lt;to&gt;&amp; opacities,
                              const bool full_check=true) ;

//! Convert CImg3d representation into a 3D object \newinstance.
    template&lt;typename tp, typename tc, typename to&gt;
    CImg&lt;T&gt; get_CImg3dtoobject3d(CImgList&lt;tp&gt;&amp; primitives,
                                 CImgList&lt;tc&gt;&amp; colors,
                                 CImgList&lt;to&gt;&amp; opacities,
                                 const bool full_check=true) const ;

//! \name Drawing Functions
    //@;

//! Draw a 3D point.
    /**
       \param x0 X-coordinate of the point.
       \param y0 Y-coordinate of the point.
       \param z0 Z-coordinate of the point.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \note
       - To set pixel values without clipping needs, you should use the faster CImg::operator()() function.
       \par Example:
       \code
       CImg&lt;unsigned char&gt; img(100,100,1,3,0);
       const unsigned char color[] = { 255,128,64 };
       img.draw_point(50,50,color);
       \endcode
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_point(const int x0, const int y0, const int z0,
                        const tc *const color, const float opacity=1) ;

//! Draw a 2D point \simplification.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_point(const int x0, const int y0,
                        const tc *const color, const float opacity=1) ;

//! Draw a 2D line.
    /**
       \param x0 X-coordinate of the starting line point.
       \param y0 Y-coordinate of the starting line point.
       \param x1 X-coordinate of the ending line point.
       \param y1 Y-coordinate of the ending line point.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch Tells if a reinitialization of the hash state must be done.
       \note
       - Line routine uses Bresenham's algorithm.
       - Set \p init_hatch = false to draw consecutive hatched segments without breaking the line pattern.
       \par Example:
       \code
       CImg&lt;unsigned char&gt; img(100,100,1,3,0);
       const unsigned char color[] = { 255,128,64 };
        img.draw_line(40,40,80,70,color);
       \endcode
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(int x0, int y0,
                       int x1, int y1,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a 2D line, with z-buffering.
    /**
       \param zbuffer Zbuffer image.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param z0 Z-coordinate of the starting point
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param z1 Z-coordinate of the ending point.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch Tells if a reinitialization of the hash state must be done.
    **/
    template&lt;typename tz,typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(CImg&lt;tz&gt;&amp; zbuffer,
                       int x0, int y0, const float z0,
                       int x1, int y1, const float z1,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a textured 2D line.
    /**
       \param x0 X-coordinate of the starting line point.
       \param y0 Y-coordinate of the starting line point.
       \param x1 X-coordinate of the ending line point.
       \param y1 Y-coordinate of the ending line point.
       \param texture Texture image defining the pixel colors.
       \param tx0 X-coordinate of the starting texture point.
       \param ty0 Y-coordinate of the starting texture point.
       \param tx1 X-coordinate of the ending texture point.
       \param ty1 Y-coordinate of the ending texture point.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch Tells if the hash variable must be reinitialized.
       \note
       - Line routine uses the well known Bresenham's algorithm.
       \par Example:
       \code
       CImg&lt;unsigned char&gt; img(100,100,1,3,0), texture("texture256x256.ppm");
       const unsigned char color[] = { 255,128,64 };
       img.draw_line(40,40,80,70,texture,0,0,255,255);
       \endcode
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(int x0, int y0,
                       int x1, int y1,
                       const CImg&lt;tc&gt;&amp; texture,
                       int tx0, int ty0,
                       int tx1, int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a textured 2D line, with perspective correction.
    /**
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param z0 Z-coordinate of the starting point
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param z1 Z-coordinate of the ending point.
       \param texture Texture image defining the pixel colors.
       \param tx0 X-coordinate of the starting texture point.
       \param ty0 Y-coordinate of the starting texture point.
       \param tx1 X-coordinate of the ending texture point.
       \param ty1 Y-coordinate of the ending texture point.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch Tells if the hash variable must be reinitialized.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(int x0, int y0, const float z0,
                       int x1, int y1, const float z1,
                       const CImg&lt;tc&gt;&amp; texture,
                       const int tx0, const int ty0,
                       const int tx1, const int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a textured 2D line, with perspective correction and z-buffering.
    /**
       \param zbuffer Z-buffer image.
       \param x0 X-coordinate of the starting point.
       \param y0 Y-coordinate of the starting point.
       \param z0 Z-coordinate of the starting point
       \param x1 X-coordinate of the ending point.
       \param y1 Y-coordinate of the ending point.
       \param z1 Z-coordinate of the ending point.
       \param texture Texture image defining the pixel colors.
       \param tx0 X-coordinate of the starting texture point.
       \param ty0 Y-coordinate of the starting texture point.
       \param tx1 X-coordinate of the ending texture point.
       \param ty1 Y-coordinate of the ending texture point.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch Tells if the hash variable must be reinitialized.
    **/
    template&lt;typename tz, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(CImg&lt;tz&gt;&amp; zbuffer,
                       int x0, int y0, const float z0,
                       int x1, int y1, const float z1,
                       const CImg&lt;tc&gt;&amp; texture,
                       const int tx0, const int ty0,
                       const int tx1, const int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a set of consecutive lines.
    /**
       \param points Coordinates of vertices, stored as a list of vectors.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch If set to true, init hatch motif.
       \note
       - This function uses several call to the single CImg::draw_line() procedure,
       depending on the vectors size in \p points.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_line(const CImg&lt;t&gt;&amp; points,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a 2D arrow.
    /**
       \param x0 X-coordinate of the starting arrow point (tail).
       \param y0 Y-coordinate of the starting arrow point (tail).
       \param x1 X-coordinate of the ending arrow point (head).
       \param y1 Y-coordinate of the ending arrow point (head).
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param angle Aperture angle of the arrow head.
       \param length Length of the arrow head. If negative, describes a percentage of the arrow length.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_arrow(const int x0, const int y0,
                        const int x1, const int y1,
                        const tc *const color, const float opacity=1,
                        const float angle=30, const float length=-10,
                        const unsigned int pattern=~0U) ;

//! Draw a 2D spline.
    /**
       \param x0 X-coordinate of the starting curve point
       \param y0 Y-coordinate of the starting curve point
       \param u0 X-coordinate of the starting velocity
       \param v0 Y-coordinate of the starting velocity
       \param x1 X-coordinate of the ending curve point
       \param y1 Y-coordinate of the ending curve point
       \param u1 X-coordinate of the ending velocity
       \param v1 Y-coordinate of the ending velocity
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param precision Curve drawing precision.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch If \c true, init hatch motif.
       \note
       - The curve is a 2D cubic Bezier spline, from the set of specified starting/ending points
       and corresponding velocity vectors.
       - The spline is drawn as a sequence of connected segments. The \p precision parameter sets the
       average number of pixels in each drawn segment.
       - A cubic Bezier curve is sometimes defined by a set of 4 points { (\p x0,\p y0), (\p xa,\p ya),
         (\p xb,\p yb), (\p x1,\p y1) } where (\p x0,\p y0) is the starting point, (\p x1,\p y1) is the ending point
         and (\p xa,\p ya), (\p xb,\p yb) are two
       \e control points.
       The starting and ending velocities (\p u0,\p v0) and (\p u1,\p v1) can be deduced easily from
       the control points as
       \p u0 = (\p xa - \p x0), \p v0 = (\p ya - \p y0), \p u1 = (\p x1 - \p xb) and \p v1 = (\p y1 - \p yb).
       \par Example:
       \code
       CImg&lt;unsigned char&gt; img(100,100,1,3,0);
       const unsigned char color[] = { 255,255,255 };
       img.draw_spline(30,30,0,100,90,40,0,-100,color);
       \endcode
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_spline(const int x0, const int y0, const float u0, const float v0,
                         const int x1, const int y1, const float u1, const float v1,
                         const tc *const color, const float opacity=1,
                         const float precision=0.25, const unsigned int pattern=~0U,
                         const bool init_hatch=true) ;

//! Draw a textured 2D spline.
    /**
       \param x0 X-coordinate of the starting curve point
       \param y0 Y-coordinate of the starting curve point
       \param u0 X-coordinate of the starting velocity
       \param v0 Y-coordinate of the starting velocity
       \param x1 X-coordinate of the ending curve point
       \param y1 Y-coordinate of the ending curve point
       \param u1 X-coordinate of the ending velocity
       \param v1 Y-coordinate of the ending velocity
       \param texture Texture image defining line pixel colors.
       \param tx0 X-coordinate of the starting texture point.
       \param ty0 Y-coordinate of the starting texture point.
       \param tx1 X-coordinate of the ending texture point.
       \param ty1 Y-coordinate of the ending texture point.
       \param precision Curve drawing precision.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch if \c true, reinit hatch motif.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_spline(const int x0, const int y0, const float u0, const float v0,
                         const int x1, const int y1, const float u1, const float v1,
                         const CImg&lt;t&gt;&amp; texture,
                         const int tx0, const int ty0, const int tx1, const int ty1,
                         const float opacity=1,
                         const float precision=4, const unsigned int pattern=~0U,
                         const bool init_hatch=true) ;

//! Draw a set of consecutive splines.
    /**
       \param points Vertices data.
       \param tangents Tangents data.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param is_closed_set Tells if the drawn spline set is closed.
       \param precision Precision of the drawing.
       \param pattern An integer whose bits describe the line pattern.
       \param init_hatch If \c true, init hatch motif.
    **/
    template&lt;typename tp, typename tt, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_spline(const CImg&lt;tp&gt;&amp; points, const CImg&lt;tt&gt;&amp; tangents,
                         const tc *const color, const float opacity=1,
                         const bool is_closed_set=false, const float precision=4,
                         const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a set of consecutive splines \overloading.
    /**
       Similar to previous function, with the point tangents automatically estimated from the given points set.
    **/
    template&lt;typename tp, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_spline(const CImg&lt;tp&gt;&amp; points,
                         const tc *const color, const float opacity=1,
                         const bool is_closed_set=false, const float precision=4,
                         const unsigned int pattern=~0U, const bool init_hatch=true) ;

//! Draw a filled 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex.
       \param y0 Y-coordinate of the first vertex.
       \param x1 X-coordinate of the second vertex.
       \param y1 Y-coordinate of the second vertex.
       \param x2 X-coordinate of the third vertex.
       \param y2 Y-coordinate of the third vertex.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
     **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color, const float opacity=1) ;

//! Draw a outlined 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex.
       \param y0 Y-coordinate of the first vertex.
       \param x1 X-coordinate of the second vertex.
       \param y1 Y-coordinate of the second vertex.
       \param x2 X-coordinate of the third vertex.
       \param y2 Y-coordinate of the third vertex.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the outline pattern.
     **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color, const float opacity,
                           const unsigned int pattern) ;

//! Draw a filled 2D triangle, with z-buffering.
    /**
       \param zbuffer Z-buffer image.
       \param x0 X-coordinate of the first vertex.
       \param y0 Y-coordinate of the first vertex.
       \param z0 Z-coordinate of the first vertex.
       \param x1 X-coordinate of the second vertex.
       \param y1 Y-coordinate of the second vertex.
       \param z1 Z-coordinate of the second vertex.
       \param x2 X-coordinate of the third vertex.
       \param y2 Y-coordinate of the third vertex.
       \param z2 Z-coordinate of the third vertex.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
       \param brightness Brightness factor.
    **/
    template&lt;typename tz, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const tc *const color, const float opacity=1,
                           const float brightness=1) ;

//! Draw a Gouraud-shaded 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param bs0 Brightness factor of the first vertex (in [0,2]).
       \param bs1 brightness factor of the second vertex (in [0,2]).
       \param bs2 brightness factor of the third vertex (in [0,2]).
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const tc *const color,
                           float bs0,
                           float bs1,
                           float bs2,
                           const float opacity=1) ;

//! Draw a Gouraud-shaded 2D triangle, with z-buffering \overloading.
    template&lt;typename tz, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const tc *const color,
                           float bs0,
                           float bs1,
                           float bs2,
                           float opacity=1) ;

//! Draw a color-interpolated 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param color1 Pointer to \c spectrum() consecutive values of type \c T, defining the color of the first vertex.
       \param color2 Pointer to \c spectrum() consecutive values of type \c T, defining the color of the second vertex.
       \param color3 Pointer to \c spectrum() consecutive values of type \c T, defining the color of the third vertex.
       \param opacity Drawing opacity.
     **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const tc *color0,
                           const tc *color1,
                           const tc *color2,
                           const float opacity=1) ;

//! Draw a textured 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param texture Texture image used to fill the triangle.
       \param tx0 X-coordinate of the first vertex in the texture image.
       \param ty0 Y-coordinate of the first vertex in the texture image.
       \param tx1 X-coordinate of the second vertex in the texture image.
       \param ty1 Y-coordinate of the second vertex in the texture image.
       \param tx2 X-coordinate of the third vertex in the texture image.
       \param ty2 Y-coordinate of the third vertex in the texture image.
       \param opacity Drawing opacity.
       \param brightness Brightness factor of the drawing (in [0,2]).
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const float opacity=1,
                           const float brightness=1) ;

//! Draw a 2D textured triangle, with perspective correction.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const float opacity=1,
                           const float brightness=1) ;

//! Draw a textured 2D triangle, with perspective correction and z-buffering.
    template&lt;typename tz, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const float opacity=1,
                           const float brightness=1) ;

//! Draw a Phong-shaded 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param light Light image.
       \param lx0 X-coordinate of the first vertex in the light image.
       \param ly0 Y-coordinate of the first vertex in the light image.
       \param lx1 X-coordinate of the second vertex in the light image.
       \param ly1 Y-coordinate of the second vertex in the light image.
       \param lx2 X-coordinate of the third vertex in the light image.
       \param ly2 Y-coordinate of the third vertex in the light image.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc, typename tl&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const tc *const color,
                           const CImg&lt;tl&gt;&amp; light,
                           int lx0, int ly0,
                           int lx1, int ly1,
                           int lx2, int ly2,
                           const float opacity=1) ;

//! Draw a Phong-shaded 2D triangle, with z-buffering.
    template&lt;typename tz, typename tc, typename tl&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const tc *const color,
                           const CImg&lt;tl&gt;&amp; light,
                           int lx0, int ly0,
                           int lx1, int ly1,
                           int lx2, int ly2,
                           const float opacity=1) ;

//! Draw a textured Gouraud-shaded 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param texture Texture image used to fill the triangle.
       \param tx0 X-coordinate of the first vertex in the texture image.
       \param ty0 Y-coordinate of the first vertex in the texture image.
       \param tx1 X-coordinate of the second vertex in the texture image.
       \param ty1 Y-coordinate of the second vertex in the texture image.
       \param tx2 X-coordinate of the third vertex in the texture image.
       \param ty2 Y-coordinate of the third vertex in the texture image.
       \param bs0 Brightness factor of the first vertex.
       \param bs1 Brightness factor of the second vertex.
       \param bs2 Brightness factor of the third vertex.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           float bs0,
                           float bs1,
                           float bs2,
                           const float opacity=1) ;

//! Draw a textured Gouraud-shaded 2D triangle, with perspective correction \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           float bs0,
                           float bs1,
                           float bs2,
                           const float opacity=1) ;

//! Draw a textured Gouraud-shaded 2D triangle, with perspective correction and z-buffering \overloading.
    template&lt;typename tz, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           float bs0,
                           float bs1,
                           float bs2,
                           const float opacity=1) ;

//! Draw a textured Phong-shaded 2D triangle.
    /**
       \param x0 X-coordinate of the first vertex in the image instance.
       \param y0 Y-coordinate of the first vertex in the image instance.
       \param x1 X-coordinate of the second vertex in the image instance.
       \param y1 Y-coordinate of the second vertex in the image instance.
       \param x2 X-coordinate of the third vertex in the image instance.
       \param y2 Y-coordinate of the third vertex in the image instance.
       \param texture Texture image used to fill the triangle.
       \param tx0 X-coordinate of the first vertex in the texture image.
       \param ty0 Y-coordinate of the first vertex in the texture image.
       \param tx1 X-coordinate of the second vertex in the texture image.
       \param ty1 Y-coordinate of the second vertex in the texture image.
       \param tx2 X-coordinate of the third vertex in the texture image.
       \param ty2 Y-coordinate of the third vertex in the texture image.
       \param light Light image.
       \param lx0 X-coordinate of the first vertex in the light image.
       \param ly0 Y-coordinate of the first vertex in the light image.
       \param lx1 X-coordinate of the second vertex in the light image.
       \param ly1 Y-coordinate of the second vertex in the light image.
       \param lx2 X-coordinate of the third vertex in the light image.
       \param ly2 Y-coordinate of the third vertex in the light image.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc, typename tl&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0,
                           int x1, int y1,
                           int x2, int y2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const CImg&lt;tl&gt;&amp; light,
                           int lx0, int ly0,
                           int lx1, int ly1,
                           int lx2, int ly2,
                           const float opacity=1) ;

//! Draw a textured Phong-shaded 2D triangle, with perspective correction.
    template&lt;typename tc, typename tl&gt;
    CImg&lt;T&gt;&amp; draw_triangle(int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const CImg&lt;tl&gt;&amp; light,
                           int lx0, int ly0,
                           int lx1, int ly1,
                           int lx2, int ly2,
                           const float opacity=1) ;

//! Draw a textured Phong-shaded 2D triangle, with perspective correction and z-buffering.
    template&lt;typename tz, typename tc, typename tl&gt;
    CImg&lt;T&gt;&amp; draw_triangle(CImg&lt;tz&gt;&amp; zbuffer,
                           int x0, int y0, const float z0,
                           int x1, int y1, const float z1,
                           int x2, int y2, const float z2,
                           const CImg&lt;tc&gt;&amp; texture,
                           int tx0, int ty0,
                           int tx1, int ty1,
                           int tx2, int ty2,
                           const CImg&lt;tl&gt;&amp; light,
                           int lx0, int ly0,
                           int lx1, int ly1,
                           int lx2, int ly2,
                           const float opacity=1) ;

//! Draw a filled 4D rectangle.
    /**
       \param x0 X-coordinate of the upper-left rectangle corner.
       \param y0 Y-coordinate of the upper-left rectangle corner.
       \param z0 Z-coordinate of the upper-left rectangle corner.
       \param c0 C-coordinate of the upper-left rectangle corner.
       \param x1 X-coordinate of the lower-right rectangle corner.
       \param y1 Y-coordinate of the lower-right rectangle corner.
       \param z1 Z-coordinate of the lower-right rectangle corner.
       \param c1 C-coordinate of the lower-right rectangle corner.
       \param val Scalar value used to fill the rectangle area.
       \param opacity Drawing opacity.
    **/
    CImg&lt;T&gt;&amp; draw_rectangle(const int x0, const int y0, const int z0, const int c0,
                            const int x1, const int y1, const int z1, const int c1,
                            const T val, const float opacity=1) ;

//! Draw a filled 3D rectangle.
    /**
       \param x0 X-coordinate of the upper-left rectangle corner.
       \param y0 Y-coordinate of the upper-left rectangle corner.
       \param z0 Z-coordinate of the upper-left rectangle corner.
       \param x1 X-coordinate of the lower-right rectangle corner.
       \param y1 Y-coordinate of the lower-right rectangle corner.
       \param z1 Z-coordinate of the lower-right rectangle corner.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_rectangle(const int x0, const int y0, const int z0,
                            const int x1, const int y1, const int z1,
                            const tc *const color, const float opacity=1) ;

//! Draw a filled 2D rectangle.
    /**
       \param x0 X-coordinate of the upper-left rectangle corner.
       \param y0 Y-coordinate of the upper-left rectangle corner.
       \param x1 X-coordinate of the lower-right rectangle corner.
       \param y1 Y-coordinate of the lower-right rectangle corner.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_rectangle(const int x0, const int y0,
                            const int x1, const int y1,
                            const tc *const color, const float opacity=1) ;

//! Draw a outlined 2D rectangle \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_rectangle(const int x0, const int y0,
                            const int x1, const int y1,
                            const tc *const color, const float opacity,
                            const unsigned int pattern) ;

//! Draw a filled 2D polygon.
    /**
       \param points Set of polygon vertices.
       \param color Pointer to \c spectrum() consecutive values of type \c T, defining the drawing color.
       \param opacity Drawing opacity.
     **/
    template&lt;typename tp, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_polygon(const CImg&lt;tp&gt;&amp; points,
                          const tc *const color, const float opacity=1) ;

//! Draw a outlined 2D or 3D polygon \overloading.
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_polygon(const CImg&lt;t&gt;&amp; points,
                          const tc *const color, const float opacity, const unsigned int pattern) ;

//! Draw a filled 2D ellipse.
    /**
       \param x0 X-coordinate of the ellipse center.
       \param y0 Y-coordinate of the ellipse center.
       \param r1 First radius of the ellipse.
       \param r2 Second radius of the ellipse.
       \param angle Angle of the first radius.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_ellipse(const int x0, const int y0, const float r1, const float r2, const float angle,
                          const tc *const color, const float opacity=1) ;

//! Draw a filled 2D ellipse \overloading.
    /**
       \param x0 X-coordinate of the ellipse center.
       \param y0 Y-coordinate of the ellipse center.
       \param tensor Diffusion tensor describing the ellipse.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_ellipse(const int x0, const int y0, const CImg&lt;t&gt; &amp;tensor,
                          const tc *const color, const float opacity=1) ;

//! Draw an outlined 2D ellipse.
    /**
       \param x0 X-coordinate of the ellipse center.
       \param y0 Y-coordinate of the ellipse center.
       \param r1 First radius of the ellipse.
       \param r2 Second radius of the ellipse.
       \param angle Angle of the first radius.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the outline pattern.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_ellipse(const int x0, const int y0, const float r1, const float r2, const float angle,
                          const tc *const color, const float opacity, const unsigned int pattern) ;

//! Draw an outlined 2D ellipse \overloading.
    /**
       \param x0 X-coordinate of the ellipse center.
       \param y0 Y-coordinate of the ellipse center.
       \param tensor Diffusion tensor describing the ellipse.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the outline pattern.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_ellipse(const int x0, const int y0, const CImg&lt;t&gt; &amp;tensor,
                          const tc *const color, const float opacity,
                          const unsigned int pattern) ;

//! Draw a filled 2D circle.
    /**
       \param x0 X-coordinate of the circle center.
       \param y0 Y-coordinate of the circle center.
       \param radius  Circle radius.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \note
       - Circle version of the Bresenham's algorithm is used.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_circle(const int x0, const int y0, int radius,
                         const tc *const color, const float opacity=1) ;

//! Draw an outlined 2D circle.
    /**
       \param x0 X-coordinate of the circle center.
       \param y0 Y-coordinate of the circle center.
       \param radius Circle radius.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern An integer whose bits describe the outline pattern.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_circle(const int x0, const int y0, int radius,
                         const tc *const color, const float opacity,
                         const unsigned int pattern) ;

//! Draw an image.
    /**
       \param sprite Sprite image.
       \param x0 X-coordinate of the sprite position.
       \param y0 Y-coordinate of the sprite position.
       \param z0 Z-coordinate of the sprite position.
       \param c0 C-coordinate of the sprite position.
       \param opacity Drawing opacity.
    **/
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg&lt;t&gt;&amp; sprite, const float opacity=1) ;

//! Draw an image \specialization.
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg&lt;T&gt;&amp; sprite, const float opacity=1) ;

//! Draw an image \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0, const int z0,
                        const CImg&lt;t&gt;&amp; sprite, const float opacity=1) ;

//! Draw an image \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0,
                        const CImg&lt;t&gt;&amp; sprite, const float opacity=1) ;

//! Draw an image \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0,
                        const CImg&lt;t&gt;&amp; sprite, const float opacity=1) ;

//! Draw an image \overloading.
    template&lt;typename t&gt;
    CImg&lt;T&gt;&amp; draw_image(const CImg&lt;t&gt;&amp; sprite, const float opacity=1) ;

//! Draw a masked image.
    /**
       \param sprite Sprite image.
       \param mask Mask image.
       \param x0 X-coordinate of the sprite position in the image instance.
       \param y0 Y-coordinate of the sprite position in the image instance.
       \param z0 Z-coordinate of the sprite position in the image instance.
       \param c0 C-coordinate of the sprite position in the image instance.
       \param mask_max_value Maximum pixel value of the mask image \c mask.
       \param opacity Drawing opacity.
       \note
       - Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
       - Dimensions along x,y and z of \p sprite and \p mask must be the same.
    **/
    template&lt;typename ti, typename tm&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg&lt;ti&gt;&amp; sprite, const CImg&lt;tm&gt;&amp; mask, const float opacity=1,
                        const float mask_max_value=1) ;

//! Draw a masked image \overloading.
    template&lt;typename ti, typename tm&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0, const int z0,
                        const CImg&lt;ti&gt;&amp; sprite, const CImg&lt;tm&gt;&amp; mask, const float opacity=1,
                        const float mask_max_value=1) ;

//! Draw a image \overloading.
    template&lt;typename ti, typename tm&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0, const int y0,
                        const CImg&lt;ti&gt;&amp; sprite, const CImg&lt;tm&gt;&amp; mask, const float opacity=1,
                        const float mask_max_value=1) ;

//! Draw a image \overloading.
    template&lt;typename ti, typename tm&gt;
    CImg&lt;T&gt;&amp; draw_image(const int x0,
                        const CImg&lt;ti&gt;&amp; sprite, const CImg&lt;tm&gt;&amp; mask, const float opacity=1,
                        const float mask_max_value=1) ;

//! Draw an image.
    template&lt;typename ti, typename tm&gt;
    CImg&lt;T&gt;&amp; draw_image(const CImg&lt;ti&gt;&amp; sprite, const CImg&lt;tm&gt;&amp; mask, const float opacity=1,
                        const float mask_max_value=1) ;

//! Draw a text string.
    /**
       \param x0 X-coordinate of the text in the image instance.
       \param y0 Y-coordinate of the text in the image instance.
       \param text Format of the text ('printf'-style format string).
       \param foreground_color Pointer to \c spectrum() consecutive values, defining the foreground drawing color.
       \param background_color Pointer to \c spectrum() consecutive values, defining the background drawing color.
       \param opacity Drawing opacity.
       \param font Font used for drawing text.
    **/
    template&lt;typename tc1, typename tc2, typename t&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc1 *const foreground_color, const tc2 *const background_color,
                       const float opacity, const CImgList&lt;t&gt;&amp; font, ...) ;

//! Draw a text string \overloading.
    /**
       \note A transparent background is used for the text.
    **/
    template&lt;typename tc, typename t&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc *const foreground_color, const int,
                       const float opacity, const CImgList&lt;t&gt;&amp; font, ...) ;

//! Draw a text string \overloading.
    /**
       \note A transparent foreground is used for the text.
    **/
    template&lt;typename tc, typename t&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const int, const tc *const background_color,
                       const float opacity, const CImgList&lt;t&gt;&amp; font, ...) ;

//! Draw a text string \overloading.
    /**
       \param x0 X-coordinate of the text in the image instance.
       \param y0 Y-coordinate of the text in the image instance.
       \param text Format of the text ('printf'-style format string).
       \param foreground_color Array of spectrum() values of type \c T,
         defining the foreground color (0 means 'transparent').
       \param background_color Array of spectrum() values of type \c T,
         defining the background color (0 means 'transparent').
       \param opacity Drawing opacity.
       \param font_height Height of the text font (exact match for 13,23,53,103, interpolated otherwise).
    **/
    template&lt;typename tc1, typename tc2&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc1 *const foreground_color, const tc2 *const background_color,
                       const float opacity=1, const unsigned int font_height=13, ...) ;

//! Draw a text string \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc *const foreground_color, const int background_color=0,
                       const float opacity=1, const unsigned int font_height=13, ...) ;

//! Draw a text string \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_text(const int x0, const int y0,
                       const char *const text,
                       const int, const tc *const background_color,
                       const float opacity=1, const unsigned int font_height=13, ...) ;

//! Draw a 2D vector field.
    /**
       \param flow Image of 2D vectors used as input data.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param sampling Length (in pixels) between each arrow.
       \param factor Length factor of each arrow (if &lt;0, computed as a percentage of the maximum length).
       \param is_arrow Tells if arrows must be drawn, instead of oriented segments.
       \param pattern Used pattern to draw lines.
       \note Clipping is supported.
    **/
    template&lt;typename t1, typename t2&gt;
    CImg&lt;T&gt;&amp; draw_quiver(const CImg&lt;t1&gt;&amp; flow,
                         const t2 *const color, const float opacity=1,
                         const unsigned int sampling=25, const float factor=-20,
                         const bool is_arrow=true, const unsigned int pattern=~0U) ;

//! Draw a 2D vector field, using a field of colors.
    /**
       \param flow Image of 2D vectors used as input data.
       \param color Image of spectrum()-D vectors corresponding to the color of each arrow.
       \param opacity Opacity of the drawing.
       \param sampling Length (in pixels) between each arrow.
       \param factor Length factor of each arrow (if &lt;0, computed as a percentage of the maximum length).
       \param is_arrow Tells if arrows must be drawn, instead of oriented segments.
       \param pattern Used pattern to draw lines.
       \note Clipping is supported.
    **/
    template&lt;typename t1, typename t2&gt;
    CImg&lt;T&gt;&amp; draw_quiver(const CImg&lt;t1&gt;&amp; flow,
                         const CImg&lt;t2&gt;&amp; color, const float opacity=1,
                         const unsigned int sampling=25, const float factor=-20,
                         const bool is_arrow=true, const unsigned int pattern=~0U) ;

//! Draw a labeled horizontal axis.
    /**
       \param values_x Values along the horizontal axis.
       \param y Y-coordinate of the horizontal axis in the image instance.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern Drawing pattern.
       \param font_height Height of the labels (exact match for 13,23,53,103, interpolated otherwise).
       \param allow_zero Enable/disable the drawing of label '0' if found.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_axis(const CImg&lt;t&gt;&amp; values_x, const int y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const unsigned int font_height=13,
                       const bool allow_zero=true, const float round_x=0) ;

//! Draw a labeled vertical axis.
    /**
       \param x X-coordinate of the vertical axis in the image instance.
       \param values_y Values along the Y-axis.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern Drawing pattern.
       \param font_height Height of the labels (exact match for 13,23,53,103, interpolated otherwise).
       \param allow_zero Enable/disable the drawing of label '0' if found.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_axis(const int x, const CImg&lt;t&gt;&amp; values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const unsigned int font_height=13,
                       const bool allow_zero=true, const float round_y=0) ;

//! Draw labeled horizontal and vertical axes.
    /**
       \param values_x Values along the X-axis.
       \param values_y Values along the Y-axis.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern_x Drawing pattern for the X-axis.
       \param pattern_y Drawing pattern for the Y-axis.
       \param font_height Height of the labels (exact match for 13,23,53,103, interpolated otherwise).
       \param allow_zero Enable/disable the drawing of label '0' if found.
    **/
    template&lt;typename tx, typename ty, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_axes(const CImg&lt;tx&gt;&amp; values_x, const CImg&lt;ty&gt;&amp; values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U,
                       const unsigned int font_height=13, const bool allow_zero=true,
                       const float round_x=0, const float round_y=0) ;

//! Draw labeled horizontal and vertical axes \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_axes(const float x0, const float x1, const float y0, const float y1,
                       const tc *const color, const float opacity=1,
                       const int subdivisionx=-60, const int subdivisiony=-60,
                       const float precisionx=0, const float precisiony=0,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U,
                       const unsigned int font_height=13) ;

//! Draw 2D grid.
    /**
       \param values_x X-coordinates of the vertical lines.
       \param values_y Y-coordinates of the horizontal lines.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
       \param pattern_x Drawing pattern for vertical lines.
       \param pattern_y Drawing pattern for horizontal lines.
    **/
    template&lt;typename tx, typename ty, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_grid(const CImg&lt;tx&gt;&amp; values_x, const CImg&lt;ty&gt;&amp; values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U) ;

//! Draw 2D grid \simplification.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_grid(const float delta_x,  const float delta_y,
                       const float offsetx, const float offsety,
                       const bool invertx, const bool inverty,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U) ;

//! Draw 1D graph.
    /**
       \param data Image containing the graph values I = f(x).
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.

       \param plot_type Define the type of the plot:
                      - 0 = No plot.
                      - 1 = Plot using segments.
                      - 2 = Plot using cubic splines.
                      - 3 = Plot with bars.
       \param vertex_type Define the type of points:
                      - 0 = No points.
                      - 1 = Point.
                      - 2 = Straight cross.
                      - 3 = Diagonal cross.
                      - 4 = Filled circle.
                      - 5 = Outlined circle.
                      - 6 = Square.
                      - 7 = Diamond.
       \param ymin Lower bound of the y-range.
       \param ymax Upper bound of the y-range.
       \param pattern Drawing pattern.
       \note
         - if \c ymin==ymax==0, the y-range is computed automatically from the input samples.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_graph(const CImg&lt;t&gt;&amp; data,
                        const tc *const color, const float opacity=1,
                        const unsigned int plot_type=1, const int vertex_type=1,
                        const double ymin=0, const double ymax=0, const unsigned int pattern=~0U) ;

//! Draw filled 3D region with the flood fill algorithm.
    /**
       \param x0 X-coordinate of the starting point of the region to fill.
       \param y0 Y-coordinate of the starting point of the region to fill.
       \param z0 Z-coordinate of the starting point of the region to fill.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param[out] region Image that will contain the mask of the filled region mask, as an output.
       \param tolerance Tolerance concerning neighborhood values.
       \param opacity Opacity of the drawing.
       \param is_high_connectivity Tells if 8-connexity must be used.
       \return \c region is initialized with the binary mask of the filled region.
    **/
    template&lt;typename tc, typename t&gt;
    CImg&lt;T&gt;&amp; draw_fill(const int x0, const int y0, const int z0,
                        const tc *const color, const float opacity,
                        CImg&lt;t&gt; &amp;region,
                        const float tolerance = 0,
                        const bool is_high_connectivity = false) ;

//! Draw filled 3D region with the flood fill algorithm \simplification.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_fill(const int x0, const int y0, const int z0,
                       const tc *const color, const float opacity=1,
                       const float tolerance=0, const bool is_high_connexity=false) ;

//! Draw filled 2D region with the flood fill algorithm \simplification.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_fill(const int x0, const int y0,
                       const tc *const color, const float opacity=1,
                       const float tolerance=0, const bool is_high_connexity=false) ;

//! Draw a random plasma texture.
    /**
       \param alpha Alpha-parameter.
       \param beta Beta-parameter.
       \param scale Scale-parameter.
       \note Use the mid-point algorithm to render.
    **/
    CImg&lt;T&gt;&amp; draw_plasma(const float alpha=1, const float beta=0, const unsigned int scale=8) ;

//! Draw a quadratic Mandelbrot or Julia 2D fractal.
    /**
       \param x0 X-coordinate of the upper-left pixel.
       \param y0 Y-coordinate of the upper-left pixel.
       \param x1 X-coordinate of the lower-right pixel.
       \param y1 Y-coordinate of the lower-right pixel.
       \param colormap Colormap.
       \param opacity Drawing opacity.
       \param z0r Real part of the upper-left fractal vertex.
       \param z0i Imaginary part of the upper-left fractal vertex.
       \param z1r Real part of the lower-right fractal vertex.
       \param z1i Imaginary part of the lower-right fractal vertex.
       \param iteration_max Maximum number of iterations for each estimated point.
       \param is_normalized_iteration Tells if iterations are normalized.
       \param is_julia_set Tells if the Mandelbrot or Julia set is rendered.
       \param param_r Real part of the Julia set parameter.
       \param param_i Imaginary part of the Julia set parameter.
       \note Fractal rendering is done by the Escape Time Algorithm.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_mandelbrot(const int x0, const int y0, const int x1, const int y1,
                             const CImg&lt;tc&gt;&amp; colormap, const float opacity=1,
                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
                             const unsigned int iteration_max=255,
                             const bool is_normalized_iteration=false,
                             const bool is_julia_set=false,
                             const double param_r=0, const double param_i=0) ;

//! Draw a quadratic Mandelbrot or Julia 2D fractal \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_mandelbrot(const CImg&lt;tc&gt;&amp; colormap, const float opacity=1,
                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
                             const unsigned int iteration_max=255,
                             const bool is_normalized_iteration=false,
                             const bool is_julia_set=false,
                             const double param_r=0, const double param_i=0) ;

//! Draw a 1D gaussian function.
    /**
       \param xc X-coordinate of the gaussian center.
       \param sigma Standard variation of the gaussian distribution.
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const float xc, const float sigma,
                           const tc *const color, const float opacity=1) ;

//! Draw a 2D gaussian function.
    /**
       \param xc X-coordinate of the gaussian center.
       \param yc Y-coordinate of the gaussian center.
       \param tensor Covariance matrix (must be 2x2).
       \param color Pointer to \c spectrum() consecutive values, defining the drawing color.
       \param opacity Drawing opacity.
    **/
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const float xc, const float yc, const CImg&lt;t&gt;&amp; tensor,
                           const tc *const color, const float opacity=1) ;

//! Draw a 2D gaussian function \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const int xc, const int yc, const float r1, const float r2, const float ru, const float rv,
                           const tc *const color, const float opacity=1) ;

//! Draw a 2D gaussian function \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const float xc, const float yc, const float sigma,
                           const tc *const color, const float opacity=1) ;

//! Draw a 3D gaussian function \overloading.
    template&lt;typename t, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const float xc, const float yc, const float zc, const CImg&lt;t&gt;&amp; tensor,
                           const tc *const color, const float opacity=1) ;

//! Draw a 3D gaussian function \overloading.
    template&lt;typename tc&gt;
    CImg&lt;T&gt;&amp; draw_gaussian(const float xc, const float yc, const float zc, const float sigma,
                           const tc *const color, const float opacity=1) ;

//! Draw a 3D object.
    /**
       \param x0 X-coordinate of the 3D object position
       \param y0 Y-coordinate of the 3D object position
       \param z0 Z-coordinate of the 3D object position
       \param vertices Image Nx3 describing 3D point coordinates
       \param primitives List of P primitives
       \param colors List of P color (or textures)
       \param opacities Image or list of P opacities
       \param render_type d Render type (0=Points, 1=Lines, 2=Faces (no light), 3=Faces (flat), 4=Faces(Gouraud)
       \param is_double_sided Tells if object faces have two sides or are oriented.
       \param focale length of the focale (0 for parallel projection)
       \param lightx X-coordinate of the light
       \param lighty Y-coordinate of the light
       \param lightz Z-coordinate of the light
       \param specular_lightness Amount of specular light.
       \param specular_shininess Shininess of the object
       \param g_opacity Global opacity of the object.
    **/
    template&lt;typename tp, typename tf, typename tc, typename to&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors, const CImg&lt;to&gt;&amp; opacities,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                           const float g_opacity=1) ;

//! Draw a 3D object \simplification.
    template&lt;typename tp, typename tf, typename tc, typename to, typename tz&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors, const CImg&lt;to&gt;&amp; opacities,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           const float g_opacity, CImg&lt;tz&gt;&amp; zbuffer) ;

//! Draw a 3D object \simplification.
    template&lt;typename tp, typename tf, typename tc, typename to&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors, const CImgList&lt;to&gt;&amp; opacities,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                           const float g_opacity=1) ;

//! Draw a 3D object \simplification.
    template&lt;typename tp, typename tf, typename tc, typename to, typename tz&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors, const CImgList&lt;to&gt;&amp; opacities,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           const float g_opacity, CImg&lt;tz&gt;&amp; zbuffer) ;

//! Draw a 3D object \simplification.
    template&lt;typename tp, typename tf, typename tc&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                           const float g_opacity=1) ;

//! Draw a 3D object \simplification.
    template&lt;typename tp, typename tf, typename tc, typename tz&gt;
    CImg&lt;T&gt;&amp; draw_object3d(const float x0, const float y0, const float z0,
                           const CImg&lt;tp&gt;&amp; vertices, const CImgList&lt;tf&gt;&amp; primitives,
                           const CImgList&lt;tc&gt;&amp; colors,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           const float g_opacity, CImg&lt;tz&gt;&amp; zbuffer) ;

//! \name Data Input
    //@;

//! Launch simple interface to select a shape from an image.
    /**
       \param disp Display window to use.
       \param feature_type Type of feature to select. Can be &lt;tt&gt;{ 0=point | 1=line | 2=rectangle | 3=ellipse }&lt;/tt&gt;.
       \param XYZ Pointer to 3 values X,Y,Z which tells about the projection point coordinates, for volumetric images.
       \param exit_on_anykey Exit function when any key is pressed.
    **/
    CImg&lt;T&gt;&amp; select(CImgDisplay &amp;disp,
                    const unsigned int feature_type=2, unsigned int *const XYZ=0,
                    const bool exit_on_anykey=false,
                    const bool is_deep_selection_default=false) ;

//! Simple interface to select a shape from an image \overloading.
    CImg&lt;T&gt;&amp; select(const char *const title,
                    const unsigned int feature_type=2, unsigned int *const XYZ=0,
                    const bool exit_on_anykey=false,
                    const bool is_deep_selection_default=false) ;

//! Simple interface to select a shape from an image \newinstance.
    CImg&lt;intT&gt; get_select(CImgDisplay &amp;disp,
                          const unsigned int feature_type=2, unsigned int *const XYZ=0,
                          const bool exit_on_anykey=false,
                          const bool is_deep_selection_default=false) const ;

//! Simple interface to select a shape from an image \newinstance.
    CImg&lt;intT&gt; get_select(const char *const title,
                          const unsigned int feature_type=2, unsigned int *const XYZ=0,
                          const bool exit_on_anykey=false,
                          const bool is_deep_selection_default=false) const ;

//! Select sub-graph in a graph.
    CImg&lt;intT&gt; get_select_graph(CImgDisplay &amp;disp,
                                const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                const char *const labelx=0, const double xmin=0, const double xmax=0,
                                const char *const labely=0, const double ymin=0, const double ymax=0,
                                const bool exit_on_anykey=false) const ;

//! Load image from a file.
    /**
       \param filename Filename, as a C-string.
       \note The extension of \c filename defines the file format. If no filename
       extension is provided, CImg&lt;T&gt;::get_load() will try to load the file as a .cimg or .cimgz file.
    **/
    CImg&lt;T&gt;&amp; load(const char *const filename) ;

//! Load image from a file \newinstance.
    static CImg&lt;T&gt; get_load(const char *const filename) ;

//! Load image from an ascii file.
    /**
       \param filename Filename, as a C -string.
    **/
    CImg&lt;T&gt;&amp; load_ascii(const char *const filename) ;

//! Load image from an ascii file \inplace.
    static CImg&lt;T&gt; get_load_ascii(const char *const filename) ;

//! Load image from an ascii file \overloading.
    CImg&lt;T&gt;&amp; load_ascii(std::FILE *const file) ;

//! Loadimage from an ascii file \newinstance.
    static CImg&lt;T&gt; get_load_ascii(std::FILE *const file) ;

//! Load image from a DLM file.
    /**
      \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_dlm(const char *const filename) ;

//! Load image from a DLM file \newinstance.
    static CImg&lt;T&gt; get_load_dlm(const char *const filename) ;

//! Load image from a DLM file \overloading.
    CImg&lt;T&gt;&amp; load_dlm(std::FILE *const file) ;

//! Load image from a DLM file \newinstance.
    static CImg&lt;T&gt; get_load_dlm(std::FILE *const file) ;

//! Load image from a BMP file.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_bmp(const char *const filename) ;

//! Load image from a BMP file \newinstance.
    static CImg&lt;T&gt; get_load_bmp(const char *const filename) ;

//! Load image from a BMP file \overloading.
    CImg&lt;T&gt;&amp; load_bmp(std::FILE *const file) ;

//! Load image from a BMP file \newinstance.
    static CImg&lt;T&gt; get_load_bmp(std::FILE *const file) ;

//! Load image from a JPEG file.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_jpeg(const char *const filename) ;

//! Load image from a JPEG file \newinstance.
    static CImg&lt;T&gt; get_load_jpeg(const char *const filename) ;

//! Load image from a JPEG file \overloading.
    CImg&lt;T&gt;&amp; load_jpeg(std::FILE *const file) ;

//! Load image from a JPEG file \newinstance.
    static CImg&lt;T&gt; get_load_jpeg(std::FILE *const file) ;

//! Load image from a file, using Magick++ library.
    /**
       \param filename Filename, as a C-string.
    **/
    // Added April/may 2006 by Christoph Hormann &lt;chris_hormann@gmx.de&gt;
    //   This is experimental code, not much tested, use with care.
    CImg&lt;T&gt;&amp; load_magick(const char *const filename) ;

//! Load image from a file, using Magick++ library \newinstance.
    static CImg&lt;T&gt; get_load_magick(const char *const filename) ;

//! Load image from a PNG file.
    /**
       \param filename Filename, as a C-string.
       \param[out] bits_per_value Number of bits used to store a scalar value in the image file.
    **/
    CImg&lt;T&gt;&amp; load_png(const char *const filename, unsigned int *const bits_per_value=0) ;

//! Load image from a PNG file \newinstance.
    static CImg&lt;T&gt; get_load_png(const char *const filename, unsigned int *const bits_per_value=0) ;

//! Load image from a PNG file \overloading.
    CImg&lt;T&gt;&amp; load_png(std::FILE *const file, unsigned int *const bits_per_value=0) ;

//! Load image from a PNG file \newinstance.
    static CImg&lt;T&gt; get_load_png(std::FILE *const file, unsigned int *const bits_per_value=0) ;

//! Load image from a PNM file.
    /**
      \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_pnm(const char *const filename) ;

//! Load image from a PNM file \newinstance.
    static CImg&lt;T&gt; get_load_pnm(const char *const filename) ;

//! Load image from a PNM file \overloading.
    CImg&lt;T&gt;&amp; load_pnm(std::FILE *const file) ;

//! Load image from a PNM file \newinstance.
    static CImg&lt;T&gt; get_load_pnm(std::FILE *const file) ;

//! Load image from a PFM file.
    /**
      \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_pfm(const char *const filename) ;

//! Load image from a PFM file \newinstance.
    static CImg&lt;T&gt; get_load_pfm(const char *const filename) ;

//! Load image from a PFM file \overloading.
    CImg&lt;T&gt;&amp; load_pfm(std::FILE *const file) ;

//! Load image from a PFM file \newinstance.
    static CImg&lt;T&gt; get_load_pfm(std::FILE *const file) ;

//! Load image from a RGB file.
    /**
      \param filename Filename, as a C-string.
      \param dimw Width of the image buffer.
      \param dimh Height of the image buffer.
    **/
    CImg&lt;T&gt;&amp; load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGB file \newinstance.
    static CImg&lt;T&gt; get_load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGB file \overloading.
    CImg&lt;T&gt;&amp; load_rgb(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGB file \newinstance.
    static CImg&lt;T&gt; get_load_rgb(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGBA file.
    /**
       \param filename Filename, as a C-string.
       \param dimw Width of the image buffer.
       \param dimh Height of the image buffer.
    **/
    CImg&lt;T&gt;&amp; load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGBA file \newinstance.
    static CImg&lt;T&gt; get_load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGBA file \overloading.
    CImg&lt;T&gt;&amp; load_rgba(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a RGBA file \newinstance.
    static CImg&lt;T&gt; get_load_rgba(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) ;

//! Load image from a TIFF file.
    /**
       \param filename Filename, as a C-string.
       \param first_frame First frame to read (for multi-pages tiff).
       \param last_frame Last frame to read (for multi-pages tiff).
       \param step_frame Step value of frame reading.
       \param[out] bits_per_value Number of bits used to store a scalar value in the image file.
       \param[out] voxel_size Voxel size, as stored in the filename.
       \param[out] description Description, as stored in the filename.
       \note
       - libtiff support is enabled by defining the precompilation
        directive \c cimg_use_tif.
       - When libtiff is enabled, 2D and 3D (multipage) several
        channel per pixel are supported for
        &lt;tt&gt;char,uchar,short,ushort,float&lt;/tt&gt; and \c double pixel types.
       - If \c cimg_use_tiff is not defined at compile time the
        function uses CImg&lt;T&gt;&amp; load_other(const char*).
     **/
    CImg&lt;T&gt;&amp; load_tiff(const char *const filename,
                       const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                       const unsigned int step_frame=1, unsigned int *const bits_per_value=0,
                       float *const voxel_size=0, CImg&lt;charT&gt; *const description=0) ;

//! Load image from a TIFF file \newinstance.
    static CImg&lt;T&gt; get_load_tiff(const char *const filename,
                                 const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                 const unsigned int step_frame=1, unsigned int *const bits_per_value=0,
                                 float *const voxel_size=0, CImg&lt;charT&gt; *const description=0) ;

//! Load image from a MINC2 file.
    /**
        \param filename Filename, as a C-string.
    **/
    // (Original code by Haz-Edine Assemlal).
    CImg&lt;T&gt;&amp; load_minc2(const char *const filename) ;

//! Load image from a MINC2 file \newinstance.
    static CImg&lt;T&gt; get_load_minc2(const char *const filename) ;

//! Load image from an ANALYZE7.5/NIFTI file.
    /**
       \param filename Filename, as a C-string.
       \param[out] voxel_size Pointer to the three voxel sizes read from the file.
    **/
    CImg&lt;T&gt;&amp; load_analyze(const char *const filename, float *const voxel_size=0) ;

//! Load image from an ANALYZE7.5/NIFTI file \newinstance.
    static CImg&lt;T&gt; get_load_analyze(const char *const filename, float *const voxel_size=0) ;

//! Load image from an ANALYZE7.5/NIFTI file \overloading.
    CImg&lt;T&gt;&amp; load_analyze(std::FILE *const file, float *const voxel_size=0) ;

//! Load image from an ANALYZE7.5/NIFTI file \newinstance.
    static CImg&lt;T&gt; get_load_analyze(std::FILE *const file, float *const voxel_size=0) ;

//! Load image from a .cimg[z] file.
    /**
      \param filename Filename, as a C-string.
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_cimg(const char *const filename, const char axis='z', const float align=0) ;

//! Load image from a .cimg[z] file \newinstance
    static CImg&lt;T&gt; get_load_cimg(const char *const filename, const char axis='z', const float align=0) ;

//! Load image from a .cimg[z] file \overloading.
    CImg&lt;T&gt;&amp; load_cimg(std::FILE *const file, const char axis='z', const float align=0) ;

//! Load image from a .cimg[z] file \newinstance
    static CImg&lt;T&gt; get_load_cimg(std::FILE *const file, const char axis='z', const float align=0) ;

//! Load sub-images of a .cimg file.
    /**
      \param filename Filename, as a C-string.
      \param n0 Starting frame.
      \param n1 Ending frame (~0U for max).
      \param x0 X-coordinate of the starting sub-image vertex.
      \param y0 Y-coordinate of the starting sub-image vertex.
      \param z0 Z-coordinate of the starting sub-image vertex.
      \param c0 C-coordinate of the starting sub-image vertex.
      \param x1 X-coordinate of the ending sub-image vertex (~0U for max).
      \param y1 Y-coordinate of the ending sub-image vertex (~0U for max).
      \param z1 Z-coordinate of the ending sub-image vertex (~0U for max).
      \param c1 C-coordinate of the ending sub-image vertex (~0U for max).
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_cimg(const char *const filename,
                       const unsigned int n0, const unsigned int n1,
                       const unsigned int x0, const unsigned int y0,
                       const unsigned int z0, const unsigned int c0,
                       const unsigned int x1, const unsigned int y1,
                       const unsigned int z1, const unsigned int c1,
                       const char axis='z', const float align=0) ;

//! Load sub-images of a .cimg file \newinstance.
    static CImg&lt;T&gt; get_load_cimg(const char *const filename,
                                 const unsigned int n0, const unsigned int n1,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0,
                                 const unsigned int x1, const unsigned int y1,
                                 const unsigned int z1, const unsigned int c1,
                                 const char axis='z', const float align=0) ;

//! Load sub-images of a .cimg file \overloading.
    CImg&lt;T&gt;&amp; load_cimg(std::FILE *const file,
                       const unsigned int n0, const unsigned int n1,
                       const unsigned int x0, const unsigned int y0,
                       const unsigned int z0, const unsigned int c0,
                       const unsigned int x1, const unsigned int y1,
                       const unsigned int z1, const unsigned int c1,
                       const char axis='z', const float align=0) ;

//! Load sub-images of a .cimg file \newinstance.
    static CImg&lt;T&gt; get_load_cimg(std::FILE *const file,
                                 const unsigned int n0, const unsigned int n1,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0,
                                 const unsigned int x1, const unsigned int y1,
                                 const unsigned int z1, const unsigned int c1,
                                 const char axis='z', const float align=0) ;

//! Load image from an INRIMAGE-4 file.
    /**
       \param filename Filename, as a C-string.
       \param[out] voxel_size Pointer to the three voxel sizes read from the file.
    **/
    CImg&lt;T&gt;&amp; load_inr(const char *const filename, float *const voxel_size=0) ;

//! Load image from an INRIMAGE-4 file \newinstance.
    static CImg&lt;T&gt; get_load_inr(const char *const filename, float *const voxel_size=0) ;

//! Load image from an INRIMAGE-4 file \overloading.
    CImg&lt;T&gt;&amp; load_inr(std::FILE *const file, float *const voxel_size=0) ;

//! Load image from an INRIMAGE-4 file \newinstance.
    static CImg&lt;T&gt; get_load_inr(std::FILE *const file, float *voxel_size=0) ;

//! Load image from a EXR file.
    /**
      \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_exr(const char *const filename) ;

//! Load image from a EXR file \newinstance.
    static CImg&lt;T&gt; get_load_exr(const char *const filename) ;

//! Load image from a PANDORE-5 file.
    /**
      \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_pandore(const char *const filename) ;

//! Load image from a PANDORE-5 file \newinstance.
    static CImg&lt;T&gt; get_load_pandore(const char *const filename) ;

//! Load image from a PANDORE-5 file \overloading.
    CImg&lt;T&gt;&amp; load_pandore(std::FILE *const file) ;

//! Load image from a PANDORE-5 file \newinstance.
    static CImg&lt;T&gt; get_load_pandore(std::FILE *const file) ;

//! Load image from a PAR-REC (Philips) file.
    /**
      \param filename Filename, as a C-string.
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_parrec(const char *const filename, const char axis='c', const float align=0) ;

//! Load image from a PAR-REC (Philips) file \newinstance.
    static CImg&lt;T&gt; get_load_parrec(const char *const filename, const char axis='c', const float align=0) ;

//! Load image from a raw binary file.
    /**
      \param filename Filename, as a C-string.
      \param size_x Width of the image buffer.
      \param size_y Height of the image buffer.
      \param size_z Depth of the image buffer.
      \param size_c Spectrum of the image buffer.
      \param is_multiplexed Tells if the image values are multiplexed along the C-axis.
      \param invert_endianness Tells if the endianness of the image buffer must be inverted.
      \param offset Starting offset of the read in the specified file.
    **/
    CImg&lt;T&gt;&amp; load_raw(const char *const filename,
                      const unsigned int size_x=0, const unsigned int size_y=1,
                      const unsigned int size_z=1, const unsigned int size_c=1,
                      const bool is_multiplexed=false, const bool invert_endianness=false,
                      const ulongT offset=0) ;

//! Load image from a raw binary file \newinstance.
    static CImg&lt;T&gt; get_load_raw(const char *const filename,
                                const unsigned int size_x=0, const unsigned int size_y=1,
                                const unsigned int size_z=1, const unsigned int size_c=1,
                                const bool is_multiplexed=false, const bool invert_endianness=false,
                                const ulongT offset=0) ;

//! Load image from a raw binary file \overloading.
    CImg&lt;T&gt;&amp; load_raw(std::FILE *const file,
                      const unsigned int size_x=0, const unsigned int size_y=1,
                      const unsigned int size_z=1, const unsigned int size_c=1,
                      const bool is_multiplexed=false, const bool invert_endianness=false,
                      const ulongT offset=0) ;

//! Load image from a raw binary file \newinstance.
    static CImg&lt;T&gt; get_load_raw(std::FILE *const file,
                                const unsigned int size_x=0, const unsigned int size_y=1,
                                const unsigned int size_z=1, const unsigned int size_c=1,
                                const bool is_multiplexed=false, const bool invert_endianness=false,
                                const ulongT offset=0) ;

//! Load image sequence from a YUV file.
    /**
      \param filename Filename, as a C-string.
      \param size_x Width of the frames.
      \param size_y Height of the frames.
      \param chroma_subsampling Type of chroma subsampling. Can be &lt;tt&gt;{ 420 | 422 | 444 }&lt;/tt&gt;.
      \param first_frame Index of the first frame to read.
      \param last_frame Index of the last frame to read.
      \param step_frame Step value for frame reading.
      \param yuv2rgb Tells if the YUV to RGB transform must be applied.
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
    **/
    CImg&lt;T&gt;&amp; load_yuv(const char *const filename,
                      const unsigned int size_x, const unsigned int size_y=1,
                      const unsigned int chroma_subsampling=444,
                      const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                      const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') ;

//! Load image sequence from a YUV file \newinstance.
    static CImg&lt;T&gt; get_load_yuv(const char *const filename,
                                const unsigned int size_x, const unsigned int size_y=1,
                                const unsigned int chroma_subsampling=444,
                                const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') ;

//! Load image sequence from a YUV file \overloading.
    CImg&lt;T&gt;&amp; load_yuv(std::FILE *const file,
                      const unsigned int size_x, const unsigned int size_y=1,
                      const unsigned int chroma_subsampling=444,
                      const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                      const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') ;

//! Load image sequence from a YUV file \newinstance.
    static CImg&lt;T&gt; get_load_yuv(std::FILE *const file,
                                const unsigned int size_x, const unsigned int size_y=1,
                                const unsigned int chroma_subsampling=444,
                                const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') ;

//! Load 3D object from a .OFF file.
    /**
        \param[out] primitives Primitives data of the 3D object.
        \param[out] colors Colors data of the 3D object.
        \param filename Filename, as a C-string.
    **/
    template&lt;typename tf, typename tc&gt;
    CImg&lt;T&gt;&amp; load_off(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors, const char *const filename) ;

//! Load 3D object from a .OFF file \newinstance.
    template&lt;typename tf, typename tc&gt;
    static CImg&lt;T&gt; get_load_off(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors, const char *const filename) ;

//! Load 3D object from a .OFF file \overloading.
    template&lt;typename tf, typename tc&gt;
    CImg&lt;T&gt;&amp; load_off(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors, std::FILE *const file) ;

//! Load 3D object from a .OFF file \newinstance.
    template&lt;typename tf, typename tc&gt;
    static CImg&lt;T&gt; get_load_off(CImgList&lt;tf&gt;&amp; primitives, CImgList&lt;tc&gt;&amp; colors, std::FILE *const file) ;

//! Load image sequence from a video file, using OpenCV library.
    /**
      \param filename Filename, as a C-string.
      \param first_frame Index of the first frame to read.
      \param last_frame Index of the last frame to read.
      \param step_frame Step value for frame reading.
      \param axis Alignment axis.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_video(const char *const filename,
                        const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                        const unsigned int step_frame=1,
                        const char axis='z', const float align=0) ;

//! Load image sequence from a video file, using OpenCV library \newinstance.
    static CImg&lt;T&gt; get_load_video(const char *const filename,
                                  const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                  const unsigned int step_frame=1,
                                  const char axis='z', const float align=0) ;

//! Load image sequence using FFMPEG's external tool 'ffmpeg'.
    /**
      \param filename Filename, as a C-string.
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_ffmpeg_external(const char *const filename, const char axis='z', const float align=0) ;

//! Load image sequence using FFMPEG's external tool 'ffmpeg' \newinstance.
    static CImg&lt;T&gt; get_load_ffmpeg_external(const char *const filename, const char axis='z', const float align=0) ;

//! Load gif file, using Imagemagick or GraphicsMagicks's external tools.
    /**
      \param filename Filename, as a C-string.
      \param axis Appending axis, if file contains multiple images. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
    **/
    CImg&lt;T&gt;&amp; load_gif_external(const char *const filename,
                               const char axis='z', const float align=0) ;

//! Load gif file, using ImageMagick or GraphicsMagick's external tool 'convert' \newinstance.
    static CImg&lt;T&gt; get_load_gif_external(const char *const filename,
                                         const char axis='z', const float align=0) ;

//! Load image from a HEIC file.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_heif(const char *const filename) ;

//! Load image from a HEIC file \newinstance.
    static CImg&lt;T&gt; get_load_heif(const char *const filename) ;

//! Load image using GraphicsMagick's external tool 'gm'.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_graphicsmagick_external(const char *const filename) ;

//! Load image using GraphicsMagick's external tool 'gm' \newinstance.
    static CImg&lt;T&gt; get_load_graphicsmagick_external(const char *const filename) ;

//! Load gzipped image file, using external tool 'gunzip'.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_gzip_external(const char *const filename) ;

//! Load gzipped image file, using external tool 'gunzip' \newinstance.
    static CImg&lt;T&gt; get_load_gzip_external(const char *const filename) ;

//! Load image using ImageMagick's external tool 'convert'.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_imagemagick_external(const char *const filename) ;

//! Load image using ImageMagick's external tool 'convert' \newinstance.
    static CImg&lt;T&gt; get_load_imagemagick_external(const char *const filename) ;

//! Load image from a DICOM file, using Medcon's external tool 'medcon'.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_medcon_external(const char *const filename) ;

//! Load image from a DICOM file, using Medcon's external tool 'medcon' \newinstance.
    static CImg&lt;T&gt; get_load_medcon_external(const char *const filename) ;

//! Load image from a .pdf file.
    /**
       \param filename Filename, as a C-string.
       \param resolution Image resolution.
    **/
    CImg&lt;T&gt;&amp; load_pdf_external(const char *const filename, const unsigned int resolution=400) ;

//! Load image from a .pdf file \newinstance.
    static CImg&lt;T&gt; get_load_pdf_external(const char *const filename, const unsigned int resolution=400) ;

//! Load image from a RAW Color Camera file, using external tool 'dcraw'.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_dcraw_external(const char *const filename) ;

//! Load image from a RAW Color Camera file, using external tool 'dcraw' \newinstance.
    static CImg&lt;T&gt; get_load_dcraw_external(const char *const filename) ;

//! Load image from a camera stream, using OpenCV.
    /**
       \param index Index of the camera to capture images from (from 0 to 63).
       \param capture_width Width of the desired image ('0' stands for default value).
       \param capture_height Height of the desired image ('0' stands for default value).
       \param skip_frames Number of frames to skip before the capture.
       \param release_camera Tells if the camera resource must be released at the end of the method.
    **/
    CImg&lt;T&gt;&amp; load_camera(const unsigned int camera_index=0,
                         const unsigned int capture_width=0, const unsigned int capture_height=0,
                         const unsigned int skip_frames=0, const bool release_camera=true) ;

//! Load image from a camera stream, using OpenCV \newinstance.
    static CImg&lt;T&gt; get_load_camera(const unsigned int camera_index=0,
                                   const unsigned int capture_width=0, const unsigned int capture_height=0,
                                   const unsigned int skip_frames=0, const bool release_camera=true) ;

//! Load image using various non-native ways.
    /**
       \param filename Filename, as a C-string.
    **/
    CImg&lt;T&gt;&amp; load_other(const char *const filename) ;

//! Load image using various non-native ways \newinstance.
    static CImg&lt;T&gt; get_load_other(const char *const filename) ;

//! \name Data Output
    //@;

//! Display information about the image data.
    /**
       \param title Name for the considered image.
       \param display_stats Tells to compute and display image statistics.
    **/
    const CImg&lt;T&gt;&amp; print(const char *const title=0, const bool display_stats=true) const ;

//! Display image into a CImgDisplay window.
    /**
       \param disp Display window.
    **/
    const CImg&lt;T&gt;&amp; display(CImgDisplay&amp; disp) const ;

//! Display image into a CImgDisplay window, in an interactive way.
    /**
        \param disp Display window.
        \param display_info Tells if image information are displayed on the standard output.
        \param[in,out] XYZ Contains the XYZ coordinates at start / exit of the function.
        \param exit_on_anykey Exit function when any key is pressed.
    **/
    const CImg&lt;T&gt;&amp; display(CImgDisplay &amp;disp, const bool display_info, unsigned int *const XYZ=0,
                           const bool exit_on_anykey=false) const ;

//! Display image into an interactive window.
    /**
        \param title Window title
        \param display_info Tells if image information are displayed on the standard output.
        \param[in,out] XYZ Contains the XYZ coordinates at start / exit of the function.
        \param exit_on_anykey Exit function when any key is pressed.
    **/
    const CImg&lt;T&gt;&amp; display(const char *const title=0, const bool display_info=true, unsigned int *const XYZ=0,
                           const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window.
    /**
       \param disp Display window.
       \param vertices Vertices data of the 3D object.
       \param primitives Primitives data of the 3D object.
       \param colors Colors data of the 3D object.
       \param opacities Opacities data of the 3D object.
       \param centering Tells if the 3D object must be centered for the display.
       \param render_static Rendering mode.
       \param render_motion Rendering mode, when the 3D object is moved.
       \param is_double_sided Tells if the object primitives are double-sided.
       \param focale Focale
       \param light_x X-coordinate of the light source.
       \param light_y Y-coordinate of the light source.
       \param light_z Z-coordinate of the light source.
       \param specular_lightness Amount of specular light.
       \param specular_shininess Shininess of the object material.
       \param display_axes Tells if the 3D axes are displayed.
       \param pose_matrix Pointer to 12 values, defining a 3D pose (as a 4x3 matrix).
       \param exit_on_anykey Exit function when any key is pressed.
    **/
    template&lt;typename tp, typename tf, typename tc, typename to&gt;
    const CImg&lt;T&gt;&amp; display_object3d(CImgDisplay&amp; disp,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const CImgList&lt;tc&gt;&amp; colors,
                                    const to&amp; opacities,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp, typename tf, typename tc, typename to&gt;
    const CImg&lt;T&gt;&amp; display_object3d(const char *const title,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const CImgList&lt;tc&gt;&amp; colors,
                                    const to&amp; opacities,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp, typename tf, typename tc&gt;
    const CImg&lt;T&gt;&amp; display_object3d(CImgDisplay &amp;disp,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const CImgList&lt;tc&gt;&amp; colors,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp, typename tf, typename tc&gt;
    const CImg&lt;T&gt;&amp; display_object3d(const char *const title,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const CImgList&lt;tc&gt;&amp; colors,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp, typename tf&gt;
    const CImg&lt;T&gt;&amp; display_object3d(CImgDisplay &amp;disp,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp, typename tf&gt;
    const CImg&lt;T&gt;&amp; display_object3d(const char *const title,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const CImgList&lt;tf&gt;&amp; primitives,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp&gt;
    const CImg&lt;T&gt;&amp; display_object3d(CImgDisplay &amp;disp,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display object 3D in an interactive window \simplification.
    template&lt;typename tp&gt;
    const CImg&lt;T&gt;&amp; display_object3d(const char *const title,
                                    const CImg&lt;tp&gt;&amp; vertices,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0,
                                    const bool exit_on_anykey=false) const ;

//! Display 1D graph in an interactive window.
    /**
       \param disp Display window.
       \param plot_type Plot type. Can be &lt;tt&gt;{ 0=points | 1=segments | 2=splines | 3=bars }&lt;/tt&gt;.
       \param vertex_type Vertex type.
       \param labelx Title for the horizontal axis, as a C-string.
       \param xmin Minimum value along the X-axis.
       \param xmax Maximum value along the X-axis.
       \param labely Title for the vertical axis, as a C-string.
       \param ymin Minimum value along the X-axis.
       \param ymax Maximum value along the X-axis.
       \param exit_on_anykey Exit function when any key is pressed.
    **/
    const CImg&lt;T&gt;&amp; display_graph(CImgDisplay &amp;disp,
                                 const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                 const char *const labelx=0, const double xmin=0, const double xmax=0,
                                 const char *const labely=0, const double ymin=0, const double ymax=0,
                                 const bool exit_on_anykey=false) const ;

//! Display 1D graph in an interactive window \overloading.
    const CImg&lt;T&gt;&amp; display_graph(const char *const title=0,
                                 const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                 const char *const labelx=0, const double xmin=0, const double xmax=0,
                                 const char *const labely=0, const double ymin=0, const double ymax=0,
                                 const bool exit_on_anykey=false) const ;

//! Save image as a file.
    /**
       \param filename Filename, as a C-string.
       \param number When positive, represents an index added to the filename. Otherwise, no number is added.
       \param digits Number of digits used for adding the number to the filename.
       \note
       - The used file format is defined by the file extension in the filename \p filename.
       - Parameter \p number can be used to add a 6-digit number to the filename before saving.

    **/
    const CImg&lt;T&gt;&amp; save(const char *const filename, const int number=-1, const unsigned int digits=6) const ;

//! Save image as an ascii file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_ascii(const char *const filename) const ;

//! Save image as an Ascii file \overloading.
    const CImg&lt;T&gt;&amp; save_ascii(std::FILE *const file) const ;

//! Save image as a .cpp source file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_cpp(const char *const filename) const ;

//! Save image as a .cpp source file \overloading.
    const CImg&lt;T&gt;&amp; save_cpp(std::FILE *const file) const ;

//! Save image as a DLM file.
    /**
       \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_dlm(const char *const filename) const ;

//! Save image as a DLM file \overloading.
    const CImg&lt;T&gt;&amp; save_dlm(std::FILE *const file) const ;

//! Save image as a BMP file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_bmp(const char *const filename) const ;

//! Save image as a BMP file \overloading.
    const CImg&lt;T&gt;&amp; save_bmp(std::FILE *const file) const ;

//! Save image as a JPEG file.
    /**
      \param filename Filename, as a C-string.
      \param quality Image quality (in %)
    **/
    const CImg&lt;T&gt;&amp; save_jpeg(const char *const filename, const unsigned int quality=100) const ;

//! Save image as a JPEG file \overloading.
    const CImg&lt;T&gt;&amp; save_jpeg(std::FILE *const file, const unsigned int quality=100) const ;

//! Save image, using built-in ImageMagick++ library.
    /**
      \param filename Filename, as a C-string.
      \param bytes_per_pixel Force the number of bytes per pixel for the saving, when possible.
    **/
    const CImg&lt;T&gt;&amp; save_magick(const char *const filename, const unsigned int bytes_per_pixel=0) const ;

//! Save image as a PNG file.
    /**
       \param filename Filename, as a C-string.
       \param bytes_per_pixel Force the number of bytes per pixels for the saving, when possible.
    **/
    const CImg&lt;T&gt;&amp; save_png(const char *const filename, const unsigned int bytes_per_pixel=0) const ;

//! Save image as a PNG file \overloading.
    const CImg&lt;T&gt;&amp; save_png(std::FILE *const file, const unsigned int bytes_per_pixel=0) const ;

//! Save image as a PNM file.
    /**
      \param filename Filename, as a C-string.
      \param bytes_per_pixel Force the number of bytes per pixels for the saving.
    **/
    const CImg&lt;T&gt;&amp; save_pnm(const char *const filename, const unsigned int bytes_per_pixel=0) const ;

//! Save image as a PNM file \overloading.
    const CImg&lt;T&gt;&amp; save_pnm(std::FILE *const file, const unsigned int bytes_per_pixel=0) const ;

//! Save image as a PNK file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_pnk(const char *const filename) const ;

//! Save image as a PNK file \overloading.
    const CImg&lt;T&gt;&amp; save_pnk(std::FILE *const file) const ;

//! Save image as a PFM file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_pfm(const char *const filename) const ;

//! Save image as a PFM file \overloading.
    const CImg&lt;T&gt;&amp; save_pfm(std::FILE *const file) const ;

//! Save image as a RGB file.
    /**
      \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_rgb(const char *const filename) const ;

//! Save image as a RGB file \overloading.
    const CImg&lt;T&gt;&amp; save_rgb(std::FILE *const file) const ;

//! Save image as a RGBA file.
    /**
       \param filename Filename, as a C-string.
    **/
    const CImg&lt;T&gt;&amp; save_rgba(const char *const filename) const ;

//! Save image as a RGBA file \overloading.
    const CImg&lt;T&gt;&amp; save_rgba(std::FILE *const file) const ;

//! Save image as a TIFF file.
    /**
       \param filename Filename, as a C-string.
       \param compression_type Type of data compression. Can be &lt;tt&gt;{ 0=None | 1=LZW | 2=JPEG }&lt;/tt&gt;.
       \param[out] voxel_size Voxel size, to be stored in the filename.
       \param[out] description Description, to be stored in the filename.
       \param use_bigtiff Allow to save big tiff files (&gt;4Gb).
       \note
       - libtiff support is enabled by defining the precompilation
        directive \c cimg_use_tif.
       - When libtiff is enabled, 2D and 3D (multipage) several
        channel per pixel are supported for
        &lt;tt&gt;char,uchar,short,ushort,float&lt;/tt&gt; and \c double pixel types.
       - If \c cimg_use_tiff is not defined at compile time the
        function uses CImg&lt;T&gt;&amp;save_other(const char*).
     **/
    const CImg&lt;T&gt;&amp; save_tiff(const char *const filename, const unsigned int compression_type=0,

                             const float *const voxel_size=0, const char *const description=0,
                             const bool use_bigtiff=true) const ;

//! Save image as a MINC2 file.
    /**
       \param filename Filename, as a C-string.
       \param imitate_file If non-zero, reference filename, as a C-string, to borrow header from.
    **/
    const CImg&lt;T&gt;&amp; save_minc2(const char *const filename,
                              const char *const imitate_file=0) const ;

//! Save image as an ANALYZE7.5 or NIFTI file.
    /**
      \param filename Filename, as a C-string.
      \param voxel_size Pointer to 3 consecutive values that tell about the voxel sizes along the X,Y and Z dimensions.
    **/
    const CImg&lt;T&gt;&amp; save_analyze(const char *const filename, const float *const voxel_size=0) const ;

//! Save image as a .cimg file.
    /**
      \param filename Filename, as a C-string.
      \param is_compressed Tells if the file contains compressed image data.
    **/
    const CImg&lt;T&gt;&amp; save_cimg(const char *const filename, const bool is_compressed=false) const ;

//! Save image as a .cimg file \overloading.
    const CImg&lt;T&gt;&amp; save_cimg(std::FILE *const file, const bool is_compressed=false) const ;

//! Save image as a sub-image into an existing .cimg file.
    /**
      \param filename Filename, as a C-string.
      \param n0 Index of the image inside the file.
      \param x0 X-coordinate of the sub-image location.
      \param y0 Y-coordinate of the sub-image location.
      \param z0 Z-coordinate of the sub-image location.
      \param c0 C-coordinate of the sub-image location.
    **/
    const CImg&lt;T&gt;&amp; save_cimg(const char *const filename,
                             const unsigned int n0,
                             const unsigned int x0, const unsigned int y0,
                             const unsigned int z0, const unsigned int c0) const ;

//! Save image as a sub-image into an existing .cimg file \overloading.
    const CImg&lt;T&gt;&amp; save_cimg(std::FILE *const file,
                             const unsigned int n0,
                             const unsigned int x0, const unsigned int y0,
                             const unsigned int z0, const unsigned int c0) const ;

//! Save blank image as a .cimg file.
    /**
        \param filename Filename, as a C-string.
        \param dx Width of the image.
        \param dy Height of the image.
        \param dz Depth of the image.
        \param dc Number of channels of the image.
        \note
        - All pixel values of the saved image are set to \c 0.
        - Use this method to save large images without having to instantiate and allocate them.
    **/
    static void save_empty_cimg(const char *const filename,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) ;

//! Save blank image as a .cimg file \overloading.
    /**
       Same as save_empty_cimg(const char *,unsigned int,unsigned int,unsigned int,unsigned int)
       with a file stream argument instead of a filename string.
    **/
    static void save_empty_cimg(std::FILE *const file,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) ;

//! Save image as an INRIMAGE-4 file.
    /**
      \param filename Filename, as a C-string.
      \param voxel_size Pointer to 3 values specifying the voxel sizes along the X,Y and Z dimensions.
    **/
    const CImg&lt;T&gt;&amp; save_inr(const char *const filename, const float *const voxel_size=0) const ;

//! Save image as an INRIMAGE-4 file \overloading.
    const CImg&lt;T&gt;&amp; save_inr(std::FILE *const file, const float *const voxel_size=0) const ;

//! Save image as an OpenEXR file.
    /**
       \param filename Filename, as a C-string.
       \note The OpenEXR file format is &lt;a href="http://en.wikipedia.org/wiki/OpenEXR"&gt;described here&lt;/a&gt;.
    **/
    const CImg&lt;T&gt;&amp; save_exr(const char *const filename) const ;

//! Save image as a Pandore-5 file.
    /**
       \param filename Filename, as a C-string.
       \param colorspace Colorspace data field in output file
       (see &lt;a href="http://www.greyc.ensicaen.fr/~regis/Pandore"&gt;Pandore file specifications&lt;/a&gt;
       for more information).
    **/
    const CImg&lt;T&gt;&amp; save_pandore(const char *const filename, const unsigned int colorspace=0) const ;

//! Save image as a Pandore-5 file \overloading.
    /**
        Same as save_pandore(const char *,unsigned int) const
        with a file stream argument instead of a filename string.
    **/
    const CImg&lt;T&gt;&amp; save_pandore(std::FILE *const file, const unsigned int colorspace=0) const ;

//! Save image as a raw data file.
    /**
       \param filename Filename, as a C-string.
       \param is_multiplexed Tells if the image channels are stored in a multiplexed way (\c true) or not (\c false).
       \note The .raw format does not store the image dimensions in the output file,
       so you have to keep track of them somewhere to be able to read the file correctly afterwards.
    **/
    const CImg&lt;T&gt;&amp; save_raw(const char *const filename, const bool is_multiplexed=false) const ;

//! Save image as a raw data file \overloading.
    /**
       Same as save_raw(const char *,bool) const
       with a file stream argument instead of a filename string.
    **/
    const CImg&lt;T&gt;&amp; save_raw(std::FILE *const file, const bool is_multiplexed=false) const ;

//! Save image as a .yuv video file.
    /**
       \param filename Filename, as a C-string.
       \param chroma_subsampling Type of chroma subsampling. Can be &lt;tt&gt;{ 420 | 422 | 444 }&lt;/tt&gt;.
       \param is_rgb Tells if pixel values of the instance image are RGB-coded (\c true) or YUV-coded (\c false).
       \note Each slice of the instance image is considered to be a single frame of the output video file.
    **/
    const CImg&lt;T&gt;&amp; save_yuv(const char *const filename,
                            const unsigned int chroma_subsampling=444,
                            const bool is_rgb=true) const ;

//! Save image as a .yuv video file \overloading.
    /**
       Same as save_yuv(const char*,const unsigned int,const bool) const
       with a file stream argument instead of a filename string.
    **/
    const CImg&lt;T&gt;&amp; save_yuv(std::FILE *const file,
                            const unsigned int chroma_subsampling=444,
                            const bool is_rgb=true) const ;

//! Save 3D object as an Object File Format (.off) file.
    /**
       \param filename Filename, as a C-string.
       \param primitives List of 3D object primitives.
       \param colors List of 3D object colors.
       \note
       - Instance image contains the vertices data of the 3D object.
       - Textured, transparent or sphere-shaped primitives cannot be managed by the .off file format.
       Such primitives will be lost or simplified during file saving.
       - The .off file format is &lt;a href="http://people.sc.fsu.edu/~jburkardt/html/off_format.html"&gt;described here&lt;/a&gt;.
    **/
    template&lt;typename tf, typename tc&gt;
    const CImg&lt;T&gt;&amp; save_off(const CImgList&lt;tf&gt;&amp; primitives, const CImgList&lt;tc&gt;&amp; colors,
                            const char *const filename) const ;

//! Save 3D object as an Object File Format (.off) file \overloading.
    /**
       Same as save_off(const CImgList&lt;tf&gt;&amp;,const CImgList&lt;tc&gt;&amp;,const char*) const
       with a file stream argument instead of a filename string.
    **/
    template&lt;typename tf, typename tc&gt;
    const CImg&lt;T&gt;&amp; save_off(const CImgList&lt;tf&gt;&amp; primitives, const CImgList&lt;tc&gt;&amp; colors,
                            std::FILE *const file) const ;

//! Save volumetric image as a video (using the OpenCV library when available).
    /**
      \param filename Filename to write data to.
      \param fps Number of frames per second.
      \param codec Type of compression (See http://www.fourcc.org/codecs.php to see available codecs).
      \param keep_open Tells if the video writer associated to the specified filename
        must be kept open or not (to allow frames to be added in the same file afterwards).
    **/
    const CImg&lt;T&gt;&amp; save_video(const char *const filename, const unsigned int fps=25,
                              const char *codec=0, const bool keep_open=false) const ;

//! Save volumetric image as a video, using ffmpeg external binary.
    /**
       \param filename Filename, as a C-string.
       \param fps Video framerate.
       \param codec Video codec, as a C-string.
       \param bitrate Video bitrate.
       \note
       - Each slice of the instance image is considered to be a single frame of the output video file.
       - This method uses \c ffmpeg, an external executable binary provided by
         &lt;a href="http://www.ffmpeg.org"&gt;FFmpeg&lt;/a&gt;.
       It must be installed for the method to succeed.
    **/
    const CImg&lt;T&gt;&amp; save_ffmpeg_external(const char *const filename, const unsigned int fps=25,
                                        const char *const codec=0, const unsigned int bitrate=2048) const ;

//! Save image using gzip external binary.
    /**
       \param filename Filename, as a C-string.
       \note This method uses \c gzip, an external executable binary provided by
         &lt;a href="//http://www.gzip.org"&gt;gzip&lt;/a&gt;.
       It must be installed for the method to succeed.
    **/
    const CImg&lt;T&gt;&amp; save_gzip_external(const char *const filename) const ;

//! Save image using GraphicsMagick's external binary.
    /**
       \param filename Filename, as a C-string.
       \param quality Image quality (expressed in percent), when the file format supports it.
       \note This method uses \c gm, an external executable binary provided by
         &lt;a href="http://www.graphicsmagick.org"&gt;GraphicsMagick&lt;/a&gt;.
       It must be installed for the method to succeed.
    **/
    const CImg&lt;T&gt;&amp; save_graphicsmagick_external(const char *const filename, const unsigned int quality=100) const ;

//! Save image using ImageMagick's external binary.
    /**
       \param filename Filename, as a C-string.
       \param quality Image quality (expressed in percent), when the file format supports it.
       \note This method uses \c convert, an external executable binary provided by
       &lt;a href="http://www.imagemagick.org"&gt;ImageMagick&lt;/a&gt;.
       It must be installed for the method to succeed.
    **/
    const CImg&lt;T&gt;&amp; save_imagemagick_external(const char *const filename, const unsigned int quality=100) const ;

//! Save image as a Dicom file.
    /**
       \param filename Filename, as a C-string.
       \note This method uses \c medcon, an external executable binary provided by
         &lt;a href="http://xmedcon.sourceforge.net"&gt;(X)Medcon&lt;/a&gt;.
       It must be installed for the method to succeed.
    **/
    const CImg&lt;T&gt;&amp; save_medcon_external(const char *const filename) const ;

//! Serialize a CImg&lt;T&gt; instance into a raw CImg&lt;unsigned char&gt; buffer.
    /**
       \param is_compressed tells if zlib compression must be used for serialization
       (this requires 'cimg_use_zlib' been enabled).
    **/
    CImg&lt;ucharT&gt; get_serialize(const bool is_compressed=false) const ;

//! Represent a list of images CImg&lt;T&gt;.
  template&lt;typename T&gt;
  class CImgList ;

//! Simple iterator type, to loop through each image of a list.
    /**
       \note
       - The \c CImgList&lt;T&gt;::iterator type is defined as a &lt;tt&gt;CImg&lt;T&gt;*&lt;/tt&gt;.
       - You may use it like this:
       \code
       CImgList&lt;&gt; list;   // Assuming this image list is not empty
       for (CImgList&lt;&gt;::iterator it = list.begin(); it&lt;list.end(); ++it) (*it).mirror('x');
       \endcode
       - Using the loop macro \c cimglist_for is another (more concise) alternative:
       \code
       cimglist_for(list,l) list[l].mirror('x');
       \endcode
    **/
    typedef CImg&lt;T&gt;* iterator;

//! Simple const iterator type, to loop through each image of a \c const list instance.
    /**
       \note
       - The \c CImgList&lt;T&gt;::const_iterator type is defined to be a &lt;tt&gt;const CImg&lt;T&gt;*&lt;/tt&gt;.
       - Similar to CImgList&lt;T&gt;::iterator, but for constant list instances.
    **/
    typedef const CImg&lt;T&gt;* const_iterator;

//! Pixel value type.
    /**
       Refer to the pixels value type of the images in the list.
       \note
       - The \c CImgList&lt;T&gt;::value_type type of a \c CImgList&lt;T&gt; is defined to be a \c T.
         It is then similar to CImg&lt;T&gt;::value_type.
       - \c CImgList&lt;T&gt;::value_type is actually not used in %CImg methods. It has been mainly defined for
         compatibility with STL naming conventions.
    **/
    typedef T value_type;

//! \name Plugins
    //@;

//! \name Constructors / Destructor / Instance Management
    //@;

//! Destructor.
    /**
       Destroy current list instance.
       \note
       - Any allocated buffer is deallocated.
       - Destroying an empty list does nothing actually.
     **/
    ~CImgList() ;

//! Default constructor.
    /**
       Construct a new empty list instance.
       \note
       - An empty list has no pixel data and its dimension width() is set to \c 0, as well as its
         image buffer pointer data().
       - An empty list may be reassigned afterwards, with the family of the assign() methods.
         In all cases, the type of pixels stays \c T.
     **/
    CImgList():
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list containing empty images.
    /**
       \param n Number of empty images.
       \note Useful when you know by advance the number of images you want to manage, as
       it will allocate the right amount of memory for the list, without needs for reallocation
       (that may occur when starting from an empty list and inserting several images in it).
    **/
    explicit CImgList(const unsigned int n):_width(n) ;

//! Construct list containing images of specified size.
    /**
       \param n Number of images.
       \param width Width of images.
       \param height Height of images.
       \param depth Depth of images.
       \param spectrum Number of channels of images.
       \note Pixel values are not initialized and may probably contain garbage.
    **/
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height=1,
             const unsigned int depth=1, const unsigned int spectrum=1):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list containing images of specified size, and initialize pixel values.
    /**
       \param n Number of images.
       \param width Width of images.
       \param height Height of images.
       \param depth Depth of images.
       \param spectrum Number of channels of images.
       \param val Initialization value for images pixels.
    **/
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const T&amp; val):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list containing images of specified size, and initialize pixel values from a sequence of integers.
    /**
       \param n Number of images.
       \param width Width of images.
       \param height Height of images.
       \param depth Depth of images.
       \param spectrum Number of channels of images.
       \param val0 First value of the initializing integers sequence.
       \param val1 Second value of the initializing integers sequence.
       \warning You must specify at least &lt;tt&gt;width*height*depth*spectrum&lt;/tt&gt; values in your argument list,
         or you will probably segfault.
    **/
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const int val0, const int val1, ...):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list containing images of specified size, and initialize pixel values from a sequence of doubles.
    /**
       \param n Number of images.
       \param width Width of images.
       \param height Height of images.
       \param depth Depth of images.
       \param spectrum Number of channels of images.
       \param val0 First value of the initializing doubles sequence.
       \param val1 Second value of the initializing doubles sequence.
       \warning You must specify at least &lt;tt&gt;width*height*depth*spectrum&lt;/tt&gt; values in your argument list,
         or you will probably segfault.
    **/
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const double val0, const double val1, ...):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list containing copies of an input image.
    /**
       \param n Number of images.
       \param img Input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of \c img.
    **/
    template&lt;typename t&gt;
    CImgList(const unsigned int n, const CImg&lt;t&gt;&amp; img, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from one image.
    /**
       \param img Input image to copy in the constructed list.
       \param is_shared Tells if the element of the list is a shared or non-shared copy of \c img.
     **/
    template&lt;typename t&gt;
    explicit CImgList(const CImg&lt;t&gt;&amp; img, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from two images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
     **/
    template&lt;typename t1, typename t2&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from three images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from four images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param img4 Fourth input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
             const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from five images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param img4 Fourth input image to copy in the constructed list.
       \param img5 Fifth input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
             const CImg&lt;t5&gt;&amp; img5, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from six images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param img4 Fourth input image to copy in the constructed list.
       \param img5 Fifth input image to copy in the constructed list.
       \param img6 Sixth input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
             const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from seven images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param img4 Fourth input image to copy in the constructed list.
       \param img5 Fifth input image to copy in the constructed list.
       \param img6 Sixth input image to copy in the constructed list.
       \param img7 Seventh input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
             const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const CImg&lt;t7&gt;&amp; img7, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list from eight images.
    /**
       \param img1 First input image to copy in the constructed list.
       \param img2 Second input image to copy in the constructed list.
       \param img3 Third input image to copy in the constructed list.
       \param img4 Fourth input image to copy in the constructed list.
       \param img5 Fifth input image to copy in the constructed list.
       \param img6 Sixth input image to copy in the constructed list.
       \param img7 Seventh input image to copy in the constructed list.
       \param img8 Eighth input image to copy in the constructed list.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8&gt;
    CImgList(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
             const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const CImg&lt;t7&gt;&amp; img7, const CImg&lt;t8&gt;&amp; img8,
             const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) ;

//! Construct list copy.
    /**
       \param list Input list to copy.
       \note The shared state of each element of the constructed list is kept the same as in \c list.
    **/
    template&lt;typename t&gt;
    CImgList(const CImgList&lt;t&gt;&amp; list):_width(0),_allocated_width(0),_data(0) ;

//! Construct list copy \specialization.
    CImgList(const CImgList&lt;T&gt;&amp; list):_width(0),_allocated_width(0),_data(0) ;

//! Construct list copy, and force the shared state of the list elements.
    /**
       \param list Input list to copy.
       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
    **/
    template&lt;typename t&gt;
    CImgList(const CImgList&lt;t&gt;&amp; list, const bool is_shared):_width(0),_allocated_width(0),_data(0) ;

//! Construct list by reading the content of a file.
    /**
       \param filename Filename, as a C-string.
    **/
    explicit CImgList(const char *const filename):_width(0),_allocated_width(0),_data(0) ;

//! Construct list from the content of a display window.
    /**
       \param disp Display window to get content from.
       \note Constructed list contains a single image only.
    **/
    explicit CImgList(const CImgDisplay&amp; disp):_width(0),_allocated_width(0),_data(0) ;

//! Return a list with elements being shared copies of images in the list instance.
    /**
      \note &lt;tt&gt;list2 = list1.get_shared()&lt;/tt&gt; is equivalent to &lt;tt&gt;list2.assign(list1,true)&lt;/tt&gt;.
    **/
    CImgList&lt;T&gt; get_shared() ;

//! Return a list with elements being shared copies of images in the list instance \const.
    const CImgList&lt;T&gt; get_shared() const ;

//! Destructor \inplace.
    /**
       \see CImgList().
    **/
    CImgList&lt;T&gt;&amp; assign() ;

//! Destructor \inplace.
    /**
       Equivalent to assign().
       \note Only here for compatibility with STL naming conventions.
    **/
    CImgList&lt;T&gt;&amp; clear() ;

//! Construct list containing empty images \inplace.
    /**
       \see CImgList(unsigned int).
    **/
    CImgList&lt;T&gt;&amp; assign(const unsigned int n) ;

//! Construct list containing images of specified size \inplace.
    /**
       \see CImgList(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int).
    **/
    CImgList&lt;T&gt;&amp; assign(const unsigned int n, const unsigned int width, const unsigned int height=1,
                        const unsigned int depth=1, const unsigned int spectrum=1) ;

//! Construct list containing images of specified size, and initialize pixel values \inplace.
    /**
       \see CImgList(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, const T).
    **/
    CImgList&lt;T&gt;&amp; assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum, const T&amp; val) ;

//! Construct list with images of specified size, and initialize pixel values from a sequence of integers \inplace.
    /**
       \see CImgList(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, const int, const int, ...).
    **/
    CImgList&lt;T&gt;&amp; assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum, const int val0, const int val1, ...) ;

//! Construct list with images of specified size, and initialize pixel values from a sequence of doubles \inplace.
    /**
       \see CImgList(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,const double,const double,...).
    **/
    CImgList&lt;T&gt;&amp; assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum,
                        const double val0, const double val1, ...) ;

//! Construct list containing copies of an input image \inplace.
    /**
       \see CImgList(unsigned int, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; assign(const unsigned int n, const CImg&lt;t&gt;&amp; img, const bool is_shared=false) ;

//! Construct list from one image \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t&gt;&amp; img, const bool is_shared=false) ;

//! Construct list from two images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const bool is_shared=false) ;

//! Construct list from three images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const bool is_shared=false) ;

//! Construct list from four images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
                        const bool is_shared=false) ;

//! Construct list from five images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
                        const CImg&lt;t5&gt;&amp; img5, const bool is_shared=false) ;

//! Construct list from six images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
                        const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const bool is_shared=false) ;

//! Construct list from seven images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,
       const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
                        const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const CImg&lt;t7&gt;&amp; img7, const bool is_shared=false) ;

//! Construct list from eight images \inplace.
    /**
       \see CImgList(const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,const CImg&lt;t&gt;&amp;,
       const CImg&lt;t&gt;&amp;, const CImg&lt;t&gt;&amp;, bool).
    **/
    template&lt;typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8&gt;
    CImgList&lt;T&gt;&amp; assign(const CImg&lt;t1&gt;&amp; img1, const CImg&lt;t2&gt;&amp; img2, const CImg&lt;t3&gt;&amp; img3, const CImg&lt;t4&gt;&amp; img4,
                        const CImg&lt;t5&gt;&amp; img5, const CImg&lt;t6&gt;&amp; img6, const CImg&lt;t7&gt;&amp; img7, const CImg&lt;t8&gt;&amp; img8,
                        const bool is_shared=false) ;

//! Construct list as a copy of an existing list and force the shared state of the list elements \inplace.
    /**
      \see CImgList(const CImgList&lt;t&gt;&amp;, bool is_shared).
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; assign(const CImgList&lt;t&gt;&amp; list, const bool is_shared=false) ;

//! Construct list as a copy of an existing list and force shared state of elements \inplace \specialization.
    CImgList&lt;T&gt;&amp; assign(const CImgList&lt;T&gt;&amp; list, const bool is_shared=false) ;

//! Construct list by reading the content of a file \inplace.
    /**
      \see CImgList(const char *const).
    **/
    CImgList&lt;T&gt;&amp; assign(const char *const filename) ;

//! Construct list from the content of a display window \inplace.
    /**
      \see CImgList(const CImgDisplay&amp;).
    **/
    CImgList&lt;T&gt;&amp; assign(const CImgDisplay &amp;disp) ;

//! Transfer the content of the list instance to another list.
    /**
       \param list Destination list.
       \note When returning, the current list instance is empty and the initial content of \c list is destroyed.
    **/
    template&lt;typename t&gt;
    CImgList&lt;t&gt;&amp; move_to(CImgList&lt;t&gt;&amp; list) ;

//! Transfer the content of the list instance at a specified position in another list.
    /**
       \param list Destination list.
       \param pos Index of the insertion in the list.
       \note When returning, the list instance is empty and the initial content of \c list is preserved
       (only images indexes may be modified).
     **/
    template&lt;typename t&gt;
    CImgList&lt;t&gt;&amp; move_to(CImgList&lt;t&gt;&amp; list, const unsigned int pos) ;

//! Swap all fields between two list instances.
    /**
       \param list List to swap fields with.
       \note Can be used to exchange the content of two lists in a fast way.
    **/
    CImgList&lt;T&gt;&amp; swap(CImgList&lt;T&gt;&amp; list) ;

//! Return a reference to an empty list.
    /**
      \note Can be used to define default values in a function taking a CImgList&lt;T&gt; as an argument.
      \code
      void f(const CImgList&lt;char&gt;&amp; list=CImgList&lt;char&gt;::empty());
      \endcode
    **/
    static CImgList&lt;T&gt;&amp; empty() ;

//! Return a reference to an empty list \const.
    static const CImgList&lt;T&gt;&amp; const_empty() ;

//! \name Overloaded Operators
    //@;

//! Return a reference to one image element of the list.
    /**
       \param pos Index of the image element.
    **/
    CImg&lt;T&gt;&amp; operator()(const unsigned int pos) ;

//! Return a reference to one image of the list.
    /**
       \param pos Index of the image element.
    **/
    const CImg&lt;T&gt;&amp; operator()(const unsigned int pos) const ;

//! Return a reference to one pixel value of one image of the list.
    /**
       \param pos Index of the image element.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list(n,x,y,z,c)&lt;/tt&gt; is equivalent to &lt;tt&gt;list[n](x,y,z,c)&lt;/tt&gt;.
    **/
    T&amp; operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
                  const unsigned int z=0, const unsigned int c=0) ;

//! Return a reference to one pixel value of one image of the list \const.
    const T&amp; operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
                        const unsigned int z=0, const unsigned int c=0) const ;

//! Return pointer to the first image of the list.
    /**
       \note Images in a list are stored as a buffer of \c CImg&lt;T&gt;.
    **/
    operator CImg&lt;T&gt;*() ;

//! Return pointer to the first image of the list \const.
    operator const CImg&lt;T&gt;*() const ;

//! Construct list from one image \inplace.
    /**
        \param img Input image to copy in the constructed list.
        \note &lt;tt&gt;list = img;&lt;/tt&gt; is equivalent to &lt;tt&gt;list.assign(img);&lt;/tt&gt;.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; operator=(const CImg&lt;t&gt;&amp; img) ;

//! Construct list from another list.
    /**
       \param list Input list to copy.
       \note &lt;tt&gt;list1 = list2&lt;/tt&gt; is equivalent to &lt;tt&gt;list1.assign(list2);&lt;/tt&gt;.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; operator=(const CImgList&lt;t&gt;&amp; list) ;

//! Construct list from another list \specialization.
    CImgList&lt;T&gt;&amp; operator=(const CImgList&lt;T&gt;&amp; list) ;

//! Construct list by reading the content of a file \inplace.
    /**
       \see CImgList(const char *const).
    **/
    CImgList&lt;T&gt;&amp; operator=(const char *const filename) ;

//! Construct list from the content of a display window \inplace.
    /**
        \see CImgList(const CImgDisplay&amp;).
    **/
    CImgList&lt;T&gt;&amp; operator=(const CImgDisplay&amp; disp) ;

//! Return a non-shared copy of a list.
    /**
        \note &lt;tt&gt;+list&lt;/tt&gt; is equivalent to &lt;tt&gt;CImgList&lt;T&gt;(list,false)&lt;/tt&gt;.
          It forces the copy to have non-shared elements.
    **/
    CImgList&lt;T&gt; operator+() const ;

//! Return a copy of the list instance, where image \c img has been inserted at the end.
    /**
       \param img Image inserted at the end of the instance copy.
       \note Define a convenient way to create temporary lists of images, as in the following code:
       \code
       (img1,img2,img3,img4).display("My four images");
       \endcode
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; operator,(const CImg&lt;t&gt;&amp; img) ;

//! Return a copy of the list instance, where image \c img has been inserted at the end \const.
    template&lt;typename t&gt;
    CImgList&lt;T&gt; operator,(const CImg&lt;t&gt;&amp; img) const ;

//! Return a copy of the list instance, where all elements of input list \c list have been inserted at the end.
    /**
       \param list List inserted at the end of the instance copy.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; operator,(const CImgList&lt;t&gt;&amp; list) ;

//! Return a copy of the list instance, where all elements of input \c list have been inserted at the end \const.
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; operator,(const CImgList&lt;t&gt;&amp; list) const ;

//! Return image corresponding to the appending of all images of the instance list along specified axis.
    /**
      \param axis Appending axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \note &lt;tt&gt;list&gt;'x'&lt;/tt&gt; is equivalent to &lt;tt&gt;list.get_append('x')&lt;/tt&gt;.
    **/
    CImg&lt;T&gt; operator&gt;(const char axis) const ;

//! Return list corresponding to the splitting of all images of the instance list along specified axis.
    /**
      \param axis Axis used for image splitting.
      \note &lt;tt&gt;list&lt;'x'&lt;/tt&gt; is equivalent to &lt;tt&gt;list.get_split('x')&lt;/tt&gt;.
    **/
    CImgList&lt;T&gt; operator&lt;(const char axis) const ;

//! \name Instance Characteristics
    //@;

//! Return the type of image pixel values as a C string.
    /**
       Return a \c char* string containing the usual type name of the image pixel values
       (i.e. a stringified version of the template parameter \c T).
       \note
       - The returned string may contain spaces (as in \c "unsigned char").
       - If the pixel type \c T does not correspond to a registered type, the string &lt;tt&gt;"unknown"&lt;/tt&gt; is returned.
    **/
    static const char* pixel_type() ;

//! Return the size of the list, i.e. the number of images contained in it.
    /**
      \note Similar to size() but returns result as a (signed) integer.
    **/
    int width() const ;

//! Return the size of the list, i.e. the number of images contained in it.
    /**
      \note Similar to width() but returns result as an unsigned integer.
    **/
    unsigned int size() const ;

//! Return pointer to the first image of the list.
    /**
       \note Images in a list are stored as a buffer of \c CImg&lt;T&gt;.
    **/
    CImg&lt;T&gt; *data() ;

//! Return pointer to the first image of the list \const.
    const CImg&lt;T&gt; *data() const ;

//! Return pointer to the pos-th image of the list.
    /**
       \param pos Index of the image element to access.
       \note &lt;tt&gt;list.data(n);&lt;/tt&gt; is equivalent to &lt;tt&gt;list.data + n;&lt;/tt&gt;.
    **/
#if cimg_verbosity&gt;=3
    CImg&lt;T&gt; *data(const unsigned int pos) ;

//! Return pointer to the pos-th image of the list \const.
    const CImg&lt;T&gt; *data(const unsigned int l) const ;

//! Return iterator to the first image of the list.
    /**
    **/
    iterator begin() ;

//! Return iterator to the first image of the list \const.
    const_iterator begin() const ;

//! Return iterator to one position after the last image of the list.
    /**
    **/
    iterator end() ;

//! Return iterator to one position after the last image of the list \const.
    const_iterator end() const ;

//! Return reference to the first image of the list.
    /**
    **/
    CImg&lt;T&gt;&amp; front() ;

//! Return reference to the first image of the list \const.
    const CImg&lt;T&gt;&amp; front() const ;

//! Return a reference to the last image of the list.
    /**
    **/
    const CImg&lt;T&gt;&amp; back() const ;

//! Return a reference to the last image of the list \const.
    CImg&lt;T&gt;&amp; back() ;

//! Return pos-th image of the list.
    /**
       \param pos Index of the image element to access.
    **/
    CImg&lt;T&gt;&amp; at(const int pos) ;

//! Access to pixel value with Dirichlet boundary conditions.
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note &lt;tt&gt;list.atNXYZC(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZC(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNXYZC(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to pixel value with Dirichlet boundary conditions \const.
    T atNXYZC(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to pixel value with Neumann boundary conditions.
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list.atNXYZC(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZC(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNXYZC(const int pos, const int x, const int y, const int z, const int c) ;

//! Access to pixel value with Neumann boundary conditions \const.
    T atNXYZC(const int pos, const int x, const int y, const int z, const int c) const ;

//! Access pixel value with Dirichlet boundary conditions for the 3 coordinates (\c pos, \c x,\c y,\c z).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNXYZ(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access pixel value with Dirichlet boundary conditions for the 3 coordinates (\c pos, \c x,\c y,\c z) \const.
    T atNXYZ(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to pixel value with Neumann boundary conditions for the 4 coordinates (\c pos, \c x,\c y,\c z).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
   T&amp; atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) ;

//! Access to pixel value with Neumann boundary conditions for the 4 coordinates (\c pos, \c x,\c y,\c z) \const.
    T atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) const ;

//! Access to pixel value with Dirichlet boundary conditions for the 3 coordinates (\c pos, \c x,\c y).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNXY(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to pixel value with Dirichlet boundary conditions for the 3 coordinates (\c pos, \c x,\c y) \const.
    T atNXY(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to pixel value with Neumann boundary conditions for the 3 coordinates (\c pos, \c x,\c y).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) ;

//! Access to pixel value with Neumann boundary conditions for the 3 coordinates (\c pos, \c x,\c y) \const.
    T atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) const ;

//! Access to pixel value with Dirichlet boundary conditions for the 2 coordinates (\c pos,\c x).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNX(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to pixel value with Dirichlet boundary conditions for the 2 coordinates (\c pos,\c x) \const.
    T atNX(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Access to pixel value with Neumann boundary conditions for the 2 coordinates (\c pos, \c x).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) ;

//! Access to pixel value with Neumann boundary conditions for the 2 coordinates (\c pos, \c x) \const.
    T atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) const ;

//! Access to pixel value with Dirichlet boundary conditions for the coordinate (\c pos).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \param out_value Default value returned if \c offset is outside image bounds.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atN(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) ;

//! Access to pixel value with Dirichlet boundary conditions for the coordinate (\c pos) \const.
    T atN(const int pos, const int x, const int y, const int z, const int c, const T&amp; out_value) const ;

//! Return pixel value with Neumann boundary conditions for the coordinate (\c pos).
    /**
       \param pos Index of the image element to access.
       \param x X-coordinate of the pixel value.
       \param y Y-coordinate of the pixel value.
       \param z Z-coordinate of the pixel value.
       \param c C-coordinate of the pixel value.
       \note &lt;tt&gt;list.atNXYZ(p,x,y,z,c);&lt;/tt&gt; is equivalent to &lt;tt&gt;list[p].atXYZ(x,y,z,c);&lt;/tt&gt;.
    **/
    T&amp; atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) ;

//! Return pixel value with Neumann boundary conditions for the coordinate (\c pos) \const.
    T atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) const ;

//! \name Instance Checking
    //@;

//! Return \c true if list is empty.
    /**
    **/
    bool is_empty() const ;

//! Test if number of image elements is equal to specified value.
    /**
        \param size_n Number of image elements to test.
    **/
    bool is_sameN(const unsigned int size_n) const ;

//! Test if number of image elements is equal between two images lists.
    /**
        \param list Input list to compare with.
    **/
    template&lt;typename t&gt;
    bool is_sameN(const CImgList&lt;t&gt;&amp; list) const ;

//! Test if dimensions of each image of the list match specified arguments.
    /**
      \param dx Checked image width.
      \param dy Checked image height.
      \param dz Checked image depth.
      \param dc Checked image spectrum.
    **/
    bool is_sameXYZC(const unsigned int dx, const unsigned int dy,
                     const unsigned int dz, const unsigned int dc) const ;

//! Test if list dimensions match specified arguments.
    /**
       \param n Number of images in the list.
       \param dx Checked image width.
       \param dy Checked image height.
       \param dz Checked image depth.
       \param dc Checked image spectrum.
    **/
    bool is_sameNXYZC(const unsigned int n,
                      const unsigned int dx, const unsigned int dy,
                      const unsigned int dz, const unsigned int dc) const ;

//! Test if list contains one particular pixel location.
    /**
       \param n Index of the image whom checked pixel value belong to.
       \param x X-coordinate of the checked pixel value.
       \param y Y-coordinate of the checked pixel value.
       \param z Z-coordinate of the checked pixel value.
       \param c C-coordinate of the checked pixel value.
    **/
    bool containsNXYZC(const int n, const int x=0, const int y=0, const int z=0, const int c=0) const ;

//! Test if list contains image with specified index.
    /**
       \param n Index of the checked image.
    **/
    bool containsN(const int n) const ;

//! Test if one image of the list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
       \param[out] n Index of image containing the pixel value, if test succeeds.
       \param[out] x X-coordinate of the pixel value, if test succeeds.
       \param[out] y Y-coordinate of the pixel value, if test succeeds.
       \param[out] z Z-coordinate of the pixel value, if test succeeds.
       \param[out] c C-coordinate of the pixel value, if test succeeds.
       \note If true, set coordinates (n,x,y,z,c).
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; n, t&amp; x, t&amp;y, t&amp; z, t&amp; c) const ;

//! Test if one of the image list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
       \param[out] n Index of image containing the pixel value, if test succeeds.
       \param[out] x X-coordinate of the pixel value, if test succeeds.
       \param[out] y Y-coordinate of the pixel value, if test succeeds.
       \param[out] z Z-coordinate of the pixel value, if test succeeds.
       \note If true, set coordinates (n,x,y,z).
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; n, t&amp; x, t&amp;y, t&amp; z) const ;

//! Test if one of the image list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
       \param[out] n Index of image containing the pixel value, if test succeeds.
       \param[out] x X-coordinate of the pixel value, if test succeeds.
       \param[out] y Y-coordinate of the pixel value, if test succeeds.
       \note If true, set coordinates (n,x,y).
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; n, t&amp; x, t&amp;y) const ;

//! Test if one of the image list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
       \param[out] n Index of image containing the pixel value, if test succeeds.
       \param[out] x X-coordinate of the pixel value, if test succeeds.
       \note If true, set coordinates (n,x).
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; n, t&amp; x) const ;

//! Test if one of the image list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
       \param[out] n Index of image containing the pixel value, if test succeeds.
       \note If true, set coordinates (n).
    **/
    template&lt;typename t&gt;
    bool contains(const T&amp; pixel, t&amp; n) const ;

//! Test if one of the image list contains the specified referenced value.
    /**
       \param pixel Reference to pixel value to test.
    **/
    bool contains(const T&amp; pixel) const ;

//! Test if the list contains the image 'img'.
    /**
       \param img Reference to image to test.
       \param[out] n Index of image in the list, if test succeeds.
       \note If true, returns the position (n) of the image in the list.
    **/
    template&lt;typename t&gt;
    bool contains(const CImg&lt;T&gt;&amp; img, t&amp; n) const ;

//! Test if the list contains the image img.
    /**
       \param img Reference to image to test.
    **/
    bool contains(const CImg&lt;T&gt;&amp; img) const ;

//! \name Mathematical Functions
    //@;

//! Return a reference to the minimum pixel value of the instance list.
    /**
    **/
    T&amp; min() ;

//! Return a reference to the minimum pixel value of the instance list \const.
    const T&amp; min() const ;

//! Return a reference to the maximum pixel value of the instance list.
    /**
    **/
    T&amp; max() ;

//! Return a reference to the maximum pixel value of the instance list \const.
    const T&amp; max() const ;

//! Return a reference to the minimum pixel value of the instance list and return the maximum vvalue as well.
    /**
       \param[out] max_val Value of the maximum value found.
    **/
    template&lt;typename t&gt;
    T&amp; min_max(t&amp; max_val) ;

//! Return a reference to the minimum pixel value of the instance list and return the maximum vvalue as well \const.
    /**
       \param[out] max_val Value of the maximum value found.
    **/
    template&lt;typename t&gt;
    const T&amp; min_max(t&amp; max_val) const ;

//! Return a reference to the minimum pixel value of the instance list and return the minimum value as well.
    /**
       \param[out] min_val Value of the minimum value found.
    **/
    template&lt;typename t&gt;
    T&amp; max_min(t&amp; min_val) ;

//! Return a reference to the minimum pixel value of the instance list and return the minimum value as well \const.
    template&lt;typename t&gt;
    const T&amp; max_min(t&amp; min_val) const ;

//! \name List Manipulation
    //@;

//! Insert a copy of the image \c img into the current image list, at position \c pos.
    /**
        \param img Image to insert a copy to the list.
        \param pos Index of the insertion.
        \param is_shared Tells if the inserted image is a shared copy of \c img or not.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; insert(const CImg&lt;t&gt;&amp; img, const unsigned int pos=~0U, const bool is_shared=false) ;

//! Insert a copy of the image \c img into the current image list, at position \c pos \specialization.
    CImgList&lt;T&gt;&amp; insert(const CImg&lt;T&gt;&amp; img, const unsigned int pos=~0U, const bool is_shared=false) ;

//! Insert a copy of the image \c img into the current image list, at position \c pos \newinstance.
    template&lt;typename t&gt;
    CImgList&lt;T&gt; get_insert(const CImg&lt;t&gt;&amp; img, const unsigned int pos=~0U, const bool is_shared=false) const ;

//! Insert n empty images img into the current image list, at position \p pos.
    /**
       \param n Number of empty images to insert.
       \param pos Index of the insertion.
    **/
    CImgList&lt;T&gt;&amp; insert(const unsigned int n, const unsigned int pos=~0U) ;

//! Insert n empty images img into the current image list, at position \p pos \newinstance.
    CImgList&lt;T&gt; get_insert(const unsigned int n, const unsigned int pos=~0U) const ;

//! Insert \c n copies of the image \c img into the current image list, at position \c pos.
    /**
       \param n Number of image copies to insert.
       \param img Image to insert by copy.
       \param pos Index of the insertion.
       \param is_shared Tells if inserted images are shared copies of \c img or not.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; insert(const unsigned int n, const CImg&lt;t&gt;&amp; img, const unsigned int pos=~0U,
                        const bool is_shared=false) ;

//! Insert \c n copies of the image \c img into the current image list, at position \c pos \newinstance.
    template&lt;typename t&gt;
    CImgList&lt;T&gt; get_insert(const unsigned int n, const CImg&lt;t&gt;&amp; img, const unsigned int pos=~0U,
                           const bool is_shared=false) const ;

//! Insert a copy of the image list \c list into the current image list, starting from position \c pos.
    /**
      \param list Image list to insert.
      \param pos Index of the insertion.
      \param is_shared Tells if inserted images are shared copies of images of \c list or not.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; insert(const CImgList&lt;t&gt;&amp; list, const unsigned int pos=~0U, const bool is_shared=false) ;

//! Insert a copy of the image list \c list into the current image list, starting from position \c pos \newinstance.
    template&lt;typename t&gt;
    CImgList&lt;T&gt; get_insert(const CImgList&lt;t&gt;&amp; list, const unsigned int pos=~0U, const bool is_shared=false) const ;

//! Insert n copies of the list \c list at position \c pos of the current list.
    /**
      \param n Number of list copies to insert.
      \param list Image list to insert.
      \param pos Index of the insertion.
      \param is_shared Tells if inserted images are shared copies of images of \c list or not.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; insert(const unsigned int n, const CImgList&lt;t&gt;&amp; list, const unsigned int pos=~0U,
                        const bool is_shared=false) ;

//! Insert n copies of the list \c list at position \c pos of the current list \newinstance.
    template&lt;typename t&gt;
    CImgList&lt;T&gt; get_insert(const unsigned int n, const CImgList&lt;t&gt;&amp; list, const unsigned int pos=~0U,
                           const bool is_shared=false) const ;

//! Remove all images between from indexes.
    /**
      \param pos1 Starting index of the removal.
      \param pos2 Ending index of the removal.
    **/
    CImgList&lt;T&gt;&amp; remove(const unsigned int pos1, const unsigned int pos2) ;

//! Remove all images between from indexes \newinstance.
    CImgList&lt;T&gt; get_remove(const unsigned int pos1, const unsigned int pos2) const ;

//! Remove image at index \c pos from the image list.
    /**
      \param pos Index of the image to remove.
    **/
    CImgList&lt;T&gt;&amp; remove(const unsigned int pos) ;

//! Remove image at index \c pos from the image list \newinstance.
    CImgList&lt;T&gt; get_remove(const unsigned int pos) const ;

//! Remove last image.
    /**
    **/
    CImgList&lt;T&gt;&amp; remove() ;

//! Remove last image \newinstance.
    CImgList&lt;T&gt; get_remove() const ;

//! Reverse list order.
    CImgList&lt;T&gt;&amp; reverse() ;

//! Reverse list order \newinstance.
    CImgList&lt;T&gt; get_reverse() const ;

//! Return a sublist.
    /**
      \param pos0 Starting index of the sublist.
      \param pos1 Ending index of the sublist.
    **/
    CImgList&lt;T&gt;&amp; images(const unsigned int pos0, const unsigned int pos1) ;

//! Return a sublist \newinstance.
    CImgList&lt;T&gt; get_images(const unsigned int pos0, const unsigned int pos1) const ;

//! Return a shared sublist.
    /**
      \param pos0 Starting index of the sublist.
      \param pos1 Ending index of the sublist.
    **/
    CImgList&lt;T&gt; get_shared_images(const unsigned int pos0, const unsigned int pos1) ;

//! Return a shared sublist \newinstance.
    const CImgList&lt;T&gt; get_shared_images(const unsigned int pos0, const unsigned int pos1) const ;

//! Return a single image which is the appending of all images of the current CImgList instance.
    /**
       \param axis Appending axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param align Appending alignment.
    **/
    CImg&lt;T&gt; get_append(const char axis, const float align=0) const ;

//! Return a list where each image has been split along the specified axis.
    /**
        \param axis Axis to split images along.
        \param nb Number of split parts for each image.
    **/
    CImgList&lt;T&gt;&amp; split(const char axis, const int nb=-1) ;

//! Return a list where each image has been split along the specified axis \newinstance.
    CImgList&lt;T&gt; get_split(const char axis, const int nb=-1) const ;

//! Insert image at the end of the list.
    /**
      \param img Image to insert.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; push_back(const CImg&lt;t&gt;&amp; img) ;

//! Insert image at the front of the list.
    /**
      \param img Image to insert.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; push_front(const CImg&lt;t&gt;&amp; img) ;

//! Insert list at the end of the current list.
    /**
      \param list List to insert.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; push_back(const CImgList&lt;t&gt;&amp; list) ;

//! Insert list at the front of the current list.
    /**
      \param list List to insert.
    **/
    template&lt;typename t&gt;
    CImgList&lt;T&gt;&amp; push_front(const CImgList&lt;t&gt;&amp; list) ;

//! Remove last image.
    /**
    **/
    CImgList&lt;T&gt;&amp; pop_back() ;

//! Remove first image.
    /**
    **/
    CImgList&lt;T&gt;&amp; pop_front() ;

//! Remove image pointed by iterator.
    /**
      \param iter Iterator pointing to the image to remove.
    **/
    CImgList&lt;T&gt;&amp; erase(const iterator iter) ;

//! \name Data Input
    //@;

//! Display a simple interactive interface to select images or sublists.
    /**
       \param disp Window instance to display selection and user interface.
       \param feature_type Can be \c false to select a single image, or \c true to select a sublist.
       \param axis Axis along whom images are appended for visualization.
       \param align Alignment setting when images have not all the same size.
       \param exit_on_anykey Exit function when any key is pressed.
       \return A one-column vector containing the selected image indexes.
    **/
    CImg&lt;intT&gt; get_select(CImgDisplay &amp;disp, const bool feature_type=true,
                          const char axis='x', const float align=0,
                          const bool exit_on_anykey=false) const ;

//! Display a simple interactive interface to select images or sublists.
    /**
       \param title Title of a new window used to display selection and user interface.
       \param feature_type Can be \c false to select a single image, or \c true to select a sublist.
       \param axis Axis along whom images are appended for visualization.
       \param align Alignment setting when images have not all the same size.
       \param exit_on_anykey Exit function when any key is pressed.
       \return A one-column vector containing the selected image indexes.
    **/
    CImg&lt;intT&gt; get_select(const char *const title, const bool feature_type=true,
                          const char axis='x', const float align=0,
                          const bool exit_on_anykey=false) const ;

//! Load a list from a file.
    /**
     \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load(const char *const filename) ;

//! Load a list from a file \newinstance.
    static CImgList&lt;T&gt; get_load(const char *const filename) ;

//! Load a list from a .cimg file.
    /**
      \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_cimg(const char *const filename) ;

//! Load a list from a .cimg file \newinstance.
    static CImgList&lt;T&gt; get_load_cimg(const char *const filename) ;

//! Load a list from a .cimg file.
    /**
      \param file File to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_cimg(std::FILE *const file) ;

//! Load a list from a .cimg file \newinstance.
    static CImgList&lt;T&gt; get_load_cimg(std::FILE *const file) ;

//! Load a sublist list from a (non compressed) .cimg file.
    /**
      \param filename Filename to read data from.
      \param n0 Starting index of images to read (~0U for max).
      \param n1 Ending index of images to read (~0U for max).
      \param x0 Starting X-coordinates of image regions to read.
      \param y0 Starting Y-coordinates of image regions to read.
      \param z0 Starting Z-coordinates of image regions to read.
      \param c0 Starting C-coordinates of image regions to read.
      \param x1 Ending X-coordinates of image regions to read (~0U for max).
      \param y1 Ending Y-coordinates of image regions to read (~0U for max).
      \param z1 Ending Z-coordinates of image regions to read (~0U for max).
      \param c1 Ending C-coordinates of image regions to read (~0U for max).
    **/
    CImgList&lt;T&gt;&amp; load_cimg(const char *const filename,
                           const unsigned int n0, const unsigned int n1,
                           const unsigned int x0, const unsigned int y0,
                           const unsigned int z0, const unsigned int c0,
                           const unsigned int x1, const unsigned int y1,
                           const unsigned int z1, const unsigned int c1) ;

//! Load a sublist list from a (non compressed) .cimg file \newinstance.
    static CImgList&lt;T&gt; get_load_cimg(const char *const filename,
                                     const unsigned int n0, const unsigned int n1,
                                     const unsigned int x0, const unsigned int y0,
                                     const unsigned int z0, const unsigned int c0,
                                     const unsigned int x1, const unsigned int y1,
                                     const unsigned int z1, const unsigned int c1) ;

//! Load a sub-image list from a (non compressed) .cimg file \overloading.
    CImgList&lt;T&gt;&amp; load_cimg(std::FILE *const file,
                           const unsigned int n0, const unsigned int n1,
                           const unsigned int x0, const unsigned int y0,
                           const unsigned int z0, const unsigned int c0,
                           const unsigned int x1, const unsigned int y1,
                           const unsigned int z1, const unsigned int c1) ;

//! Load a sub-image list from a (non compressed) .cimg file \newinstance.
    static CImgList&lt;T&gt; get_load_cimg(std::FILE *const file,
                                     const unsigned int n0, const unsigned int n1,
                                     const unsigned int x0, const unsigned int y0,
                                     const unsigned int z0, const unsigned int c0,
                                     const unsigned int x1, const unsigned int y1,
                                     const unsigned int z1, const unsigned int c1) ;

//! Load a list from a PAR/REC (Philips) file.
    /**
      \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_parrec(const char *const filename) ;

//! Load a list from a PAR/REC (Philips) file \newinstance.
    static CImgList&lt;T&gt; get_load_parrec(const char *const filename) ;

//! Load a list from a YUV image sequence file.
    /**
        \param filename Filename to read data from.
        \param size_x Width of the images.
        \param size_y Height of the images.
        \param chroma_subsampling Type of chroma subsampling. Can be &lt;tt&gt;{ 420 | 422 | 444 }&lt;/tt&gt;.
        \param first_frame Index of first image frame to read.
        \param last_frame Index of last image frame to read.
        \param step_frame Step applied between each frame.
        \param yuv2rgb Apply YUV to RGB transformation during reading.
    **/
    CImgList&lt;T&gt;&amp; load_yuv(const char *const filename,
                          const unsigned int size_x, const unsigned int size_y,
                          const unsigned int chroma_subsampling=444,
                          const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                          const unsigned int step_frame=1, const bool yuv2rgb=true) ;

//! Load a list from a YUV image sequence file \newinstance.
    static CImgList&lt;T&gt; get_load_yuv(const char *const filename,
                                    const unsigned int size_x, const unsigned int size_y=1,
                                    const unsigned int chroma_subsampling=444,
                                    const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                    const unsigned int step_frame=1, const bool yuv2rgb=true) ;

//! Load a list from an image sequence YUV file \overloading.
    CImgList&lt;T&gt;&amp; load_yuv(std::FILE *const file,
                          const unsigned int size_x, const unsigned int size_y,
                          const unsigned int chroma_subsampling=444,
                          const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                          const unsigned int step_frame=1, const bool yuv2rgb=true) ;

//! Load a list from an image sequence YUV file \newinstance.
    static CImgList&lt;T&gt; get_load_yuv(std::FILE *const file,
                                    const unsigned int size_x, const unsigned int size_y=1,
                                    const unsigned int chroma_subsampling=444,
                                    const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                    const unsigned int step_frame=1, const bool yuv2rgb=true) ;

//! Load an image from a video file, using OpenCV library.
    /**
      \param filename Filename, as a C-string.
      \param first_frame Index of the first frame to read.
      \param last_frame Index of the last frame to read (can be higher than the actual number of frames, e.g. '~0U').
      \param step_frame Step value for frame reading.
      \note If step_frame==0, the current video stream is forced to be released (without any frames read).
    **/
    CImgList&lt;T&gt;&amp; load_video(const char *const filename,
                            const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                            const unsigned int step_frame=1) ;

//! Load an image from a video file, using OpenCV library \newinstance.
    static CImgList&lt;T&gt; get_load_video(const char *const filename,
                           const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                           const unsigned int step_frame=1) ;

//! Load an image from a video file using the external tool 'ffmpeg'.
    /**
      \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_ffmpeg_external(const char *const filename) ;

//! Load an image from a video file using the external tool 'ffmpeg' \newinstance.
    static CImgList&lt;T&gt; get_load_ffmpeg_external(const char *const filename) ;

//! Load gif file, using ImageMagick or GraphicsMagick's external tools.
    /**
      \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_gif_external(const char *const filename) ;

//! Load gif file, using ImageMagick or GraphicsMagick's external tools \newinstance.
    static CImgList&lt;T&gt; get_load_gif_external(const char *const filename) ;

//! Load a gzipped list, using external tool 'gunzip'.
    /**
      \param filename Filename to read data from.
    **/
    CImgList&lt;T&gt;&amp; load_gzip_external(const char *const filename) ;

//! Load a gzipped list, using external tool 'gunzip' \newinstance.
    static CImgList&lt;T&gt; get_load_gzip_external(const char *const filename) ;

//! Load images from a TIFF file.
    /**
        \param filename Filename to read data from.
        \param first_frame Index of first image frame to read.
        \param last_frame Index of last image frame to read.
        \param step_frame Step applied between each frame.
        \param[out] bits_per_value Number of bits used to store a scalar value in the image file.
        \param[out] voxel_size Voxel size, as stored in the filename.
        \param[out] description Description, as stored in the filename.
    **/
    CImgList&lt;T&gt;&amp; load_tiff(const char *const filename,
                           const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                           const unsigned int step_frame=1, unsigned int *const bits_per_value=0,
                           float *const voxel_size=0, CImg&lt;charT&gt; *const description=0) ;

//! Load a multi-page TIFF file \newinstance.
    static CImgList&lt;T&gt; get_load_tiff(const char *const filename,
                                     const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                     const unsigned int step_frame=1, unsigned int *const bits_per_value=0,
                                     float *const voxel_size=0, CImg&lt;charT&gt; *const description=0) ;

//! \name Data Output
    //@;

//! Print information about the list on the standard output.
    /**
      \param title Label set to the information displayed.
      \param display_stats Tells if image statistics must be computed and displayed.
    **/
    const CImgList&lt;T&gt;&amp; print(const char *const title=0, const bool display_stats=true) const ;

//! Display the current CImgList instance in an existing CImgDisplay window (by reference).
    /**
       \param disp Reference to an existing CImgDisplay instance, where the current image list will be displayed.
       \param axis Appending axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
       \param align Appending alignment.
       \note This function displays the list images of the current CImgList instance into an existing
         CImgDisplay window.
       Images of the list are appended in a single temporary image for visualization purposes.
       The function returns immediately.
    **/
    const CImgList&lt;T&gt;&amp; display(CImgDisplay &amp;disp, const char axis='x', const float align=0) const ;

//! Display the current CImgList instance in a new display window.
    /**
        \param disp Display window.
        \param display_info Tells if image information are displayed on the standard output.
        \param axis Alignment axis for images viewing.
        \param align Appending alignment.
        \param[in,out] XYZ Contains the XYZ coordinates at start / exit of the function.
        \param exit_on_anykey Exit function when any key is pressed.
        \note This function opens a new window with a specific title and displays the list images of the
          current CImgList instance into it.
        Images of the list are appended in a single temporary image for visualization purposes.
        The function returns when a key is pressed or the display window is closed by the user.
    **/
    const CImgList&lt;T&gt;&amp; display(CImgDisplay &amp;disp, const bool display_info,
                               const char axis='x', const float align=0,
                               unsigned int *const XYZ=0, const bool exit_on_anykey=false) const ;

//! Display the current CImgList instance in a new display window.
    /**
      \param title Title of the opening display window.
      \param display_info Tells if list information must be written on standard output.
      \param axis Appending axis. Can be &lt;tt&gt;{ 'x' | 'y' | 'z' | 'c' }&lt;/tt&gt;.
      \param align Appending alignment.
      \param[in,out] XYZ Contains the XYZ coordinates at start / exit of the function.
      \param exit_on_anykey Exit function when any key is pressed.
    **/
    const CImgList&lt;T&gt;&amp; display(const char *const title=0, const bool display_info=true,
                               const char axis='x', const float align=0,
                               unsigned int *const XYZ=0, const bool exit_on_anykey=false) const ;

//! Save list into a file.
    /**
      \param filename Filename to write data to.
      \param number When positive, represents an index added to the filename. Otherwise, no number is added.
      \param digits Number of digits used for adding the number to the filename.
    **/
    const CImgList&lt;T&gt;&amp; save(const char *const filename, const int number=-1, const unsigned int digits=6) const ;

//! Tell if an image list can be saved as one single file.
    /**
       \param filename Filename, as a C-string.
       \return \c true if the file format supports multiple images, \c false otherwise.
    **/
    static bool is_saveable(const char *const filename) ;

//! Save image sequence as a GIF animated file.
    /**
       \param filename Filename to write data to.
       \param fps Number of desired frames per second.
       \param nb_loops Number of loops (\c 0 for infinite looping).
    **/
    const CImgList&lt;T&gt;&amp; save_gif_external(const char *const filename, const float fps=25,
                                         const unsigned int nb_loops=0) ;

//! Save list as a YUV image sequence file.
    /**
      \param filename Filename to write data to.
      \param chroma_subsampling Type of chroma subsampling. Can be &lt;tt&gt;{ 420 | 422 | 444 }&lt;/tt&gt;.
      \param is_rgb Tells if the RGB to YUV conversion must be done for saving.
    **/
    const CImgList&lt;T&gt;&amp; save_yuv(const char *const filename=0,
                                const unsigned int chroma_subsampling=444,
                                const bool is_rgb=true) const ;

//! Save image sequence into a YUV file.
    /**
      \param file File to write data to.
      \param chroma_subsampling Type of chroma subsampling. Can be &lt;tt&gt;{ 420 | 422 | 444 }&lt;/tt&gt;.
      \param is_rgb Tells if the RGB to YUV conversion must be done for saving.
    **/
    const CImgList&lt;T&gt;&amp; save_yuv(std::FILE *const file,
                                const unsigned int chroma_subsampling=444,
                                const bool is_rgb=true) const ;

//! Save list into a .cimg file.
    /**
       \param filename Filename to write data to.
       \param is_compressed Tells if data compression must be enabled.
    **/
    const CImgList&lt;T&gt;&amp; save_cimg(const char *const filename, const bool is_compressed=false) const ;

//! Save list into a .cimg file.
    /**
       \param file File to write data to.
       \param is_compressed Tells if data compression must be enabled.
    **/
    const CImgList&lt;T&gt;&amp; save_cimg(std::FILE *file, const bool is_compressed=false) const ;

//! Insert the image instance into into an existing .cimg file, at specified coordinates.
    /**
      \param filename Filename to write data to.
      \param n0 Starting index of images to write.
      \param x0 Starting X-coordinates of image regions to write.
      \param y0 Starting Y-coordinates of image regions to write.
      \param z0 Starting Z-coordinates of image regions to write.
      \param c0 Starting C-coordinates of image regions to write.
    **/
    const CImgList&lt;T&gt;&amp; save_cimg(const char *const filename,
                                 const unsigned int n0,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0) const ;

//! Insert the image instance into into an existing .cimg file, at specified coordinates.
    /**
      \param file File to write data to.
      \param n0 Starting index of images to write.
      \param x0 Starting X-coordinates of image regions to write.
      \param y0 Starting Y-coordinates of image regions to write.
      \param z0 Starting Z-coordinates of image regions to write.
      \param c0 Starting C-coordinates of image regions to write.
    **/
    const CImgList&lt;T&gt;&amp; save_cimg(std::FILE *const file,
                                 const unsigned int n0,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0) const ;

//! Save empty (non-compressed) .cimg file with specified dimensions.
    /**
        \param filename Filename to write data to.
        \param nb Number of images to write.
        \param dx Width of images in the written file.
        \param dy Height of images in the written file.
        \param dz Depth of images in the written file.
        \param dc Spectrum of images in the written file.
    **/
    static void save_empty_cimg(const char *const filename,
                                const unsigned int nb,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) ;

//! Save empty .cimg file with specified dimensions.
    /**
        \param file File to write data to.
        \param nb Number of images to write.
        \param dx Width of images in the written file.
        \param dy Height of images in the written file.
        \param dz Depth of images in the written file.
        \param dc Spectrum of images in the written file.
    **/
    static void save_empty_cimg(std::FILE *const file,
                                const unsigned int nb,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) ;

//! Save list as a TIFF file.
    /**
      \param filename Filename to write data to.
      \param compression_type Compression mode used to write data.
      \param voxel_size Voxel size, to be stored in the filename.
      \param description Description, to be stored in the filename.
      \param use_bigtiff Allow to save big tiff files (&gt;4Gb).
    **/
    const CImgList&lt;T&gt;&amp; save_tiff(const char *const filename, const unsigned int compression_type=0,
                                 const float *const voxel_size=0, const char *const description=0,
                                 const bool use_bigtiff=true) const ;

//! Save list as a gzipped file, using external tool 'gzip'.
    /**
      \param filename Filename to write data to.
    **/
    const CImgList&lt;T&gt;&amp; save_gzip_external(const char *const filename) const ;

//! Save image sequence (using the OpenCV library when available).
    /**
       \param filename Filename to write data to.
       \param fps Number of frames per second.
       \param codec Type of compression (See http://www.fourcc.org/codecs.php to see available codecs).
       \param keep_open Tells if the video writer associated to the specified filename
       must be kept open or not (to allow frames to be added in the same file afterwards).
    **/
    const CImgList&lt;T&gt;&amp; save_video(const char *const filename, const unsigned int fps=25,
                                  const char *codec=0, const bool keep_open=false) const ;

//! Save image sequence, using the external tool 'ffmpeg'.
    /**
      \param filename Filename to write data to.
      \param fps Number of frames per second.
      \param codec Type of compression.
      \param bitrate Output bitrate
    **/
    const CImgList&lt;T&gt;&amp; save_ffmpeg_external(const char *const filename, const unsigned int fps=25,
                                            const char *const codec=0, const unsigned int bitrate=2048) const ;

//! Serialize a CImgList&lt;T&gt; instance into a raw CImg&lt;unsigned char&gt; buffer.
    /**
       \param is_compressed tells if zlib compression must be used for serialization
       (this requires 'cimg_use_zlib' been enabled).
    **/
    CImg&lt;ucharT&gt; get_serialize(const bool is_compressed=false) const ;

//! Unserialize a CImg&lt;unsigned char&gt; serialized buffer into a CImgList&lt;T&gt; list.
    template&lt;typename t&gt;
    static CImgList&lt;T&gt; get_unserialize(const CImg&lt;t&gt;&amp; buffer) ;

//! \name Others
    //@;

//! Return a CImg pre-defined font with requested height.
    /**
       \param font_height Height of the desired font (exact match for 13,23,53,103).
       \param is_variable_width Decide if the font has a variable (\c true) or fixed (\c false) width.
    **/
    static const CImgList&lt;ucharT&gt;&amp; font(const unsigned int requested_height, const bool is_variable_width=true) ;

//! Compute a 1D Fast Fourier Transform, along specified axis.
    /**
       \param axis Axis along which the Fourier transform is computed.
       \param invert Tells if the direct (\c false) or inverse transform (\c true) is computed.
    **/
    CImgList&lt;T&gt;&amp; FFT(const char axis, const bool invert=false) ;

//! Compute a 1-D Fast Fourier Transform, along specified axis \newinstance.
    CImgList&lt;Tfloat&gt; get_FFT(const char axis, const bool invert=false) const ;

//! Compute n-D Fast Fourier Transform.
    /**
      \param invert Tells if the direct (\c false) or inverse transform (\c true) is computed.
    **/
    CImgList&lt;T&gt;&amp; FFT(const bool invert=false) ;

//! Compute n-D Fast Fourier Transform \newinstance.
    CImgList&lt;Tfloat&gt; get_FFT(const bool invert=false) const ;

//! Reverse primitives orientations of a 3D object.
    /**
    **/
    CImgList&lt;T&gt;&amp; reverse_object3d() ;

//! Reverse primitives orientations of a 3D object \newinstance.
    CImgList&lt;T&gt; get_reverse_object3d() const ;

//! Search path of an executable (Windows only).
#if cimg_OS==2
    inline bool win_searchpath(const char *const exec_name, char *const res, const unsigned int size_res) ;

//! Get the file or directory attributes with support for UTF-8 paths (Windows only).
#if cimg_OS==2
    inline DWORD win_getfileattributes(const char *const path) ;

//! Get/set path to the &lt;i&gt;Program Files/&lt;/i&gt; directory (Windows only).
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the program files.
    **/
#if cimg_OS==2
    inline const char* win_programfiles_path(const char *const user_path=0, const bool reinit_path=false) ;

//! Get/set path to the \c curl binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c curl binary.
    **/
    inline const char *curl_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the \c dcraw binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c dcraw binary.
    **/
    inline const char *dcraw_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the FFMPEG's \c ffmpeg binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c ffmpeg binary.
    **/
    inline const char *ffmpeg_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the GraphicsMagick's \c gm binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c gm binary.
    **/
    inline const char* graphicsmagick_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the \c gunzip binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c gunzip binary.
    **/
    inline const char *gunzip_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the \c gzip binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c gzip binary.
    **/
    inline const char *gzip_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the ImageMagick's \c convert binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c convert binary.
    **/
    inline const char* imagemagick_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the Medcon's \c medcon binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c medcon binary.
    **/
    inline const char* medcon_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to store temporary files.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path where temporary files can be saved.
    **/
    inline const char* temporary_path(const char *const user_path, const bool reinit_path) ;

//! Get/set path to the \c wget binary.
    /**
       \param user_path Specified path, or \c 0 to get the path currently used.
       \param reinit_path Force path to be recalculated (may take some time).
       \return Path containing the \c wget binary.
    **/
    inline const char *wget_path(const char *const user_path, const bool reinit_path) ;

//! Generate a numbered version of a filename.
    inline char* number_filename(const char *const filename, const int number,
                                 const unsigned int digits, char *const str) ;

//! Return list of files/directories in specified directory.
    /**
       \param path Path to the directory. Set to 0 for current directory.
       \param is_pattern Tell if specified path has a matching pattern in it.
       \param mode Output type, can be primary { 0=files only | 1=folders only | 2=files + folders }.
       \param include_path Tell if \c path must be included in resulting filenames.
       \return A list of filenames.
    **/
    inline CImgList&lt;char&gt; files(const char *const path, const bool is_pattern=false,
                                const unsigned int mode=2, const bool include_path=false) ;

//! Try to guess format from an image file.
    /**
       \param file Input file (can be \c 0 if \c filename is set).
       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
       \return C-string containing the guessed file format, or \c 0 if nothing has been guessed.
    **/
    inline const char *ftype(std::FILE *const file, const char *const filename) ;

//! Load file from network as a local temporary file.
    /**
       \param url URL of the filename, as a C-string.
       \param[out] filename_local C-string containing the path to a local copy of \c filename.
       \param timeout Maximum time (in seconds) authorized for downloading the file from the URL.
       \param try_fallback When using libcurl, tells using system calls as fallbacks in case of libcurl failure.
       \param referer Referer used, as a C-string.
       \return Value of \c filename_local.
       \note Use the \c libcurl library, or the external binaries \c wget or \c curl to perform the download.
    **/
    inline char *load_network(const char *const url, char *const filename_local,
                              const unsigned int timeout, const bool try_fallback,
                              const char *const referer) ;

//! Display a simple dialog box, and wait for the user's response.
    /**
       \param title Title of the dialog window.
       \param msg Main message displayed inside the dialog window.
       \param button1_label Label of the 1st button.
       \param button2_label Label of the 2nd button (\c 0 to hide button).
       \param button3_label Label of the 3rd button (\c 0 to hide button).
       \param button4_label Label of the 4th button (\c 0 to hide button).
       \param button5_label Label of the 5th button (\c 0 to hide button).
       \param button6_label Label of the 6th button (\c 0 to hide button).
       \param logo Image logo displayed at the left of the main message.
       \param is_centered Tells if the dialog window must be centered on the screen.
       \return Index of clicked button (from \c 0 to \c 5), or \c -1 if the dialog window has been closed by the user.
       \note
       - Up to 6 buttons can be defined in the dialog window.
       - The function returns when a user clicked one of the button or closed the dialog window.
       - If a button text is set to 0, the corresponding button (and the following) will not appear in the dialog box.
       At least one button must be specified.
    **/
    template&lt;typename t&gt;
    inline int dialog(const char *const title, const char *const msg,
                      const char *const button1_label, const char *const button2_label,
                      const char *const button3_label, const char *const button4_label,
                      const char *const button5_label, const char *const button6_label,
                      const CImg&lt;t&gt;&amp; logo, const bool is_centered=false) ;

//! Display a simple dialog box, and wait for the user's response \specialization.
    inline int dialog(const char *const title, const char *const msg,
                      const char *const button1_label, const char *const button2_label,
                      const char *const button3_label, const char *const button4_label,
                      const char *const button5_label, const char *const button6_label,
                      const bool is_centered) ;

//! Evaluate math expression.
    /**
       \param expression C-string describing the formula to evaluate.
       \param x Value of the pre-defined variable \c x.
       \param y Value of the pre-defined variable \c y.
       \param z Value of the pre-defined variable \c z.
       \param c Value of the pre-defined variable \c c.
       \return Result of the formula evaluation.
       \note Set \c expression to \c 0 to keep evaluating the last specified \c expression.
       \par Example
       \code
       const double
       res1 = cimg::eval("cos(x)^2 + sin(y)^2",2,2),  // will return '1'
       res2 = cimg::eval(0,1,1);                    // will return '1' too
       \endcode
    **/
    inline double eval(const char *const expression, const double x, const double y, const double z, const double c) ;

//! Fast distance algorithm.
    /** Finds (non-weighted) distance to nearest point below contour.
        \param in Input image.
        \param out Output image.
        \param thresh Threshold/height at which the contour line exists.
        \param method { 0=pixel-walking; 1=semi-exact; 2=vanvliet-euclidean }
        \param maxdist Maximum distance to trace/walk from each point.
    **/
void fast_dist (CImg&lt;unsigned char&gt;&amp; in, CImg&lt;float&gt;&amp; out, int thresh, const int method, int maxdist) ;

//! Short alias name.
    namespace cil = cimg_library_suffixed;

</body>
</html>
